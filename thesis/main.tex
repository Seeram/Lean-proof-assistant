\documentclass[a4paper,10pt,oneside]{report}%pridat twoside, do [] pre obojstrannu tlac
\pagestyle{headings}
\usepackage[top=2.5cm, bottom=2.5cm, left=3.5cm, right=2cm]{geometry} %odporucane okraje
\linespread{1.50}

%% Generally used
\usepackage{ebproof}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb, upgreek}
\usepackage{mathtools}
\usepackage{color}
%% Generally used

%% Lean specific
\usepackage[utf8x]{inputenc}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{errorcolor}{rgb}{1, 0, 0}           % bright red
\definecolor{stringcolor}{rgb}{0.5, 0.3, 0.2}    % brown
\usepackage{pict2e,picture}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}
%% Lean specific

%% Covering

\newcommand{\coveringA}{%
  \mathrel{-\mkern-4mu}<%
}
\newcommand{\coveringB}{\mathrel{\text{$\vcenter{\hbox{\pictcoveringB}}$}}}

\newcommand{\pictcoveringB}{%
  \begin{picture}(1em,.5em)
  \roundcap
  \put(0,.25em){\line(1,0){.6em}}
  \put(.6em,.25em){\line(3,1){.4em}}
  \put(.6em,.25em){\line(3,-1){.4em}}
  \end{picture}%
}
%% Covering

%% Powerset
\newcommand{\powerset}{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}
%% Powerset
\newcommand{\nothing}{\varnothing}

\newtheorem{theorem}{Theorem}


\author{Mat\'u\v{s} Behun}
\title{Lattice theory notes}

\begin{document}

\tableofcontents

\section{√övod}

%Pri procese roz≈°irovania matematickej te√≥rie vytv√°rame tvrdenia generalizuj√∫ce jej princ√≠py.
%Ak chceme aby n√°≈°a te√≥ria bola spr√°vna, v≈°etky jej tvrdenia musia by≈• logicky odvoden√© z postul√°tov alebo tvrden√≠ z nich odvoden√Ωch.
%Potvrdenie spr√°vnosti tvrdenia, vysloven√≠m predpokladu, axi√≥mu alebo nap√≠san√≠m formule ktor√∫ dostaneme aplik√°ciou dedukƒçn√©ho pravidla na niektor√© v postupnosti predch√°dzaj√∫ce formule naz√Ωvame d√¥kazom.

%% Je to pravda?
%Z kvalitat√≠vneho hƒæadiska pri vysloven√≠ d√¥kazu uva≈æujeme o v≈°eobecnosti d√¥kazu a spr√°vnosti aplik√°cie dedukƒçn√©ho pravidla.
%% Je to vhodn√Ω pr√≠klad(chcel som uviest priklad na prvy pohlad spravneho tvrdenia ktore bolo dokazane ako nespravne ? Ako spr√°vne citova≈•? N√°pad som mal odtiaƒæto https://en.wikipedia.org/wiki/List_of_disproved_mathematical_ideas
%O nutnosti korektn√©ho dokazovania tvrden√≠ hovor√≠ napr√≠klad tvrdenie z te√≥rie ƒç√≠sel o hornom ohraniƒçen√≠ poƒçtu prvoƒç√≠sel logaritmick√Ωm integr√°lom.

%\begin{equation}
    %\pi(x) \leq \int_{0}^{x} \frac{1}{ \ln{t} } dt
%\end{equation}

%Tvrdenie bolo pova≈æovan√© za spr√°vne Bernhardom Riemannom a evidencia to taktie≈æ naznaƒçovala.
%Nesk√¥r sa uk√°zalo ≈æe tvrdenie nie je spr√°vne pri ƒç√≠sle pod hodnotou $10^{317}$.
%% Doplni≈• rok
%Veta o 4 farb√°ch ktor√° bola vysloven√° v roku 1852 Francisom Guthrie ktor√° hovor√≠, ≈æe ka≈æd√° rovinn√° mapa je zafarbiteƒæn√° 4 farbami.
%% 18-faces
%T√°to veta bola nespr√°vne dok√°zan√° v roku Kempom (1879) and Taitom (1880). Kempov d√¥kaz bol vyvr√°ten√Ω o 10 rokov mapov s 18 stenami.
%% Je lep≈°ie sklo≈àova≈• cudzie men√°?
%Pri d√¥kaze tejto vety bol nesk√¥r v roku 1977 Appelom and Hakenom z ƒçasti vyu≈æit√Ω poƒç√≠taƒç pre kontrolu ≈°peci√°lnych diskr√©tnych pr√≠padov.


\section{Prirodzen√° intuionistick√° logika}

\subsection{Formalizovanie d√¥kazu}

D√¥kaz z te√≥rie usporiadania. Tak ako je Program = Proof

Ot√°zka ohƒæadne konzistentnosti d√¥kazu.

\subsection{Prirodzen√° dedukcia}

% Formula vyrokoveho poctu
\begin{theorem}[V√Ωrokov√° premenn√°, formula]
    Majme spoƒç√≠tateƒæn√∫ mno≈æinu $\mathcal{X}$ v√Ωrokov√Ωch premenn√Ωch. Mno≈æina v√Ωrokov
    alebo form√∫l $\mathcal{A}$ generovan√∫ nasledovnou gramatikou:
    \begin{equation}
        A, B ::= X | A \implies B | A \wedge B | A \vee B | \neg A | \top | \bot
    \end{equation}
    Kde $X \in \mathcal{X}$ reprezentuje v√Ωrokov√∫ premenn√∫, a $A, B \in \mathcal{A}$
    v√Ωrok.
\end{theorem}

V pr√≠pade nasledovn√©ho v√Ωroku je precedencia $\neg$ vy≈°≈°ia ako $\vee$ alebo $\wedge$
a t√° je vy≈°≈°ia ako $\implies$. Bin√°rne oper√°tory s√∫ asociat√≠vne sprava.

\begin{align*}
    \neg A \wedge B \wedge C &\implies A \vee B \\
    (\neg A \wedge (B \wedge C)) &\implies (A \vee B) \\
\end{align*}

\begin{theorem}
    Kontextom(syst√©m predpokladov) rozuemieme zoznam v√Ωrokov znaƒçen√Ωch
    \begin{equation}
        \Gamma = P_{1}, \dots , P_{n}
    \end{equation}
    Dedukciou naz√Ωvame dvojicu pozost√°vaj√∫cu z kontextu a v√Ωroku.
    \begin{equation}
        \Gamma \vdash A
    \end{equation}
\end{theorem}

V√Ωraz ƒç√≠tame ako $A$ je mo≈æn√© dok√°za≈• zo syst√©mu predpokladov $\Gamma$.

\begin{theorem}
    Dedukƒçn√© pravidlo pozost√°va z mno≈æiny dedukci√≠ $\Gamma_{i}$ ktor√© naz√Ωvame
    prepokladom. Doln√∫ ƒças≈• dedukƒçn√©ho pravidla $\Gamma$ naz√Ωvame z√°verom.
    \begin{equation}
        \begin{prooftree}
            \hypo{\Gamma_{1} \vdash A_{1}}
            \hypo{\dots}
            \hypo{\Gamma_{n} \vdash A_{n}}
            \infer3[]{\Gamma \vdash A}
        \end{prooftree}
    \end{equation}
\end{theorem}
Pravidl√° prirodzenej intuicionistickej logiky:
\begin{center}
    \begin{prooftree}
        \infer0[(ax)]{\Gamma,A,\Gamma' \vdash: A}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \implies B}
        \hypo{\Gamma \vdash A}
        \infer2[$(\implies_{E})$]{\Gamma : B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$\implies_{I}$]{\Gamma : B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{l}_{E})$]{\Gamma : A}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{r}_{E})$]{\Gamma : B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \hypo{\Gamma \vdash B}
        \infer2[$(\wedge_{I})$]{\Gamma \vdash A \wedge B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \vee B}
        \hypo{\Gamma, A \vdash C}
        \hypo{\Gamma, B \vdash C}
        \infer3[$(\vee_{E})$]{\Gamma \vdash C}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash B}
        \infer1[$(\vee_{I}^{r})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \infer1[$(\vee_{I}^{l})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash \neg A}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{E})$]{\Gamma \vdash \bot}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash \bot}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{I})$]{\Gamma \vdash \neg A}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{center}
    \begin{prooftree}
        \hypo{\Gamma \vdash \bot}
        \infer1[$(\bot_{E})$]{\Gamma \vdash A}
    \end{prooftree}
\end{center}

V pr√≠pade ≈æe tieto pravidl√° ƒç√≠tame zhora nadol hovor√≠me o dedukcii.
Ak ƒç√≠tame pravidl√° zdola nahor hovor√≠me o indukƒçnom sp√¥sobe.

\begin{theorem}
    Fragmentom intuionistickej logiky naz√Ωvame, syst√©m ktor√Ω dostaneme ak ho obmedz√≠me
        len na niektor√© z predch√°dzaj√∫cich pravidiel.
\end{theorem}

\begin{theorem}
    Implikaƒçn√Ωm fragmentom intuionistickej logiky dostaneme v pr√≠pade ak formuly
        bud√∫ tvoren√© gramatikou
    \begin{equation}
        A,B ::= X | A \implies B
    \end{equation}
    a pravidlami (ax), ($\implies_{E}$), ($\implies_{I}$)
\end{theorem}

% TODO spravit priklad
% (ùê¥‚àßùêµ)‚Üí((ùê¥‚Üíùê∂)‚Üí¬¨(ùêµ‚Üí¬¨ùê∂))

V pr√≠pade ≈æe chceme aby v√Ωrokove formuly koren≈°pondovali s typmi ktor√© su prezentovan√© nesk√¥r.
Ich booleova reprezent√°cia s hodnotami $1,0$ je nahraden√° ot√°zkou existencie prvkov v mno≈æine.
V pr√≠pade implik√°cie o existencii funkcie v mno≈æine.
Funkcie v programoch ale m√¥≈æu ma≈• pri rovnak√Ωch vstupoch a v√Ωstupoch ma≈• r√¥znu v√Ωpoƒçtov√∫ zlo≈æitos≈•.
D√¥vod preƒço by sme sa mali pozera≈• na d√¥kazy(podƒæa publik√°cie Gir11) v troch rovin√°ch.

\begin{itemize}
    \item 1. Booleovsk√Ω - tvrdenia s√∫ booleovsk√© hodnoty, zauj√≠mame sa o dok√°zateƒænos≈• tvrdenia
    \item 2. Existenƒçn√Ω - tvrdenia s√∫ mno≈æiny, ak√© funkcie m√¥≈æu by≈•
    \item 3. √ömyseln√Ω/Z√°merov√Ω(Intentional) - zauj√≠mame sa o zlo≈æitos≈• vytvoren√©ho d√¥kazu a ako sa zjednodu≈°√≠ cez (cut eliminitation)
\end{itemize}

\subsection{Intuicionizmus}

Jedn√Ωm zo smerov matematickej filozofie t√Ωkajucej sa rozvoja te√≥rie je kon≈°truktivizmus.
Kon≈°truktivizmus hovor√≠ o potrebe n√°js≈• alebo zostroji≈• matematick√Ω objekt k tomu
    aby bola dok√°zan√° jeho existencia.
Jeden z motivaƒçn√Ωch pr√≠kladov tak√©hoto pr√≠stupu je mo≈ænos≈• dok√°zania pravdivosti
v√Ωroku $p \vee \neg p$ cez d√¥kaz sporom $\neg p$ ktor√Ω nehovor√≠ ako zostroji≈• objekt
$p$ len o jeho existencii.
Tento smer tvor√≠ viacero "≈°k√¥l" okrem in√Ωch finitizmus, predikativizmus, intuicionizmus.
Intuitionizmus je teda kon≈°trukt√≠vny pr√≠stup k matematike v duchu
    Brouwera(1881-1966) a Heytinga(1898-1980).
Filozofick√Ωm z√°kladom tochto pr√≠stupu princ√≠p ≈æe matematika je v√Ωtvorom ment√°lnej
ƒçinnosti a nepozost√°va z v√Ωsledkov  form√°lnej manipul√°cie symbolov ktor√© s√∫ iba
sekund√°rne.
Jedn√Ωm z princ√≠pov intuicionizmus je odmietnutie tvrdenia postul√°tu klasickej
logiky a to z√°kona vyl√∫ƒçenia tretieho.

\begin{equation}
    p \vee \neg p
\end{equation}

D√¥vodom je z kon≈°trukt√≠vneho pohƒæadu nezmyselnos≈• uva≈æovania nad pravdivos≈•ou
    v√Ωroku nez√°visle od uva≈æovan√©ho tvrdenia.
V√Ωrok je teda pravdiv√Ω ak existuje d√¥kaz o jeho pravidovsti a nepravdiv√©
    ak existuje d√¥kaz ktor√Ω vedie k sporu.

\begin{itemize}
    \item konjukcii $ p \wedge q $ ako o v√Ωroku hovoriacom o existencii d√¥kazov $p$ a z√°rove≈à $q$,
    \item disjunkcii $ p \wedge q $ ako existencii kon≈°trukcii d√¥kazu jedn√©ho z v√Ωrokov $p, q$,
    \item $ p \implies q $ je met√≥da(funkcia) transform√°cie ka≈ædej kon≈°trukcie $p$ k d√¥kazu $q$,
    \item neexistencie d√¥kazu nepravdiv√©ho tvrdenia, iba d√¥kazu ktor√Ω vedie k sporu $p \implies \bot$
    \item kon≈°trukcia $\neg p$ je met√≥da ktor√° vytvor√≠ ka≈æd√∫ kon≈°trukciu $p$ na neexistuj√∫ci objekt
\end{itemize}

konjukcii $ A \wedge B $ ako $ A \times B $
$ A \vee B $ ako $ A \sqcup B $ disjunktne zjednotenie
$ \neg A = A \implies \perp $ existencie kontrapr√≠kladu

\section{Lambda kalkulus}

\begin{theorem}
    Majme nekoneƒçn√∫ mno≈æinu $ \mathcal{X}={x,y,z,\dots}$ ktor√Ωch elementy naz√Ωvame premenn√©.
Mno≈æinu $\Lambda$ tvoren√∫ $\lambda$-term√≠nmy je potom generovan√° nasledovnou gramatikou:
    \begin{equation}
        t, u ::= x | t u | \lambda x.t
    \end{equation}
\end{theorem}
\noindent V√Ωznam jednotliv√Ωch term√≠nov je
\begin{align*}
     x          & \textrm{ - je premennou }\\
     t u        & \textrm{ - je aplik√°ciou term√≠nu $t$ s argumentom $u$ }\\
    \lambda x.t & \textrm{ - je abstrakciou $t$ nad $x$ }
\end{align*}
Pr√≠klady lambda term√≠nov:

\begin{align*}
    & t x \\
    & (\lambda y . \lambda x . t y )) \\
    & (\lambda y.y x) (\lambda x . x) \\
    & t u v = ( t u ) v
\end{align*}

Aplik√°cia $\lambda$-term√≠nov je implicitne aplikovan√° zƒæava.

Pri v√Ωraze
\begin{equation}
    \lambda x . t x = \lambda x . (t x)
\end{equation}
je precedencia aplik√°cie vy≈°≈°ia ako abstrakcia.

A abstrakciu s troma argumentmi je mo≈æn√© prep√≠sa≈• do troch po sebe nasleduj√∫cich.
\begin{equation}
    \lambda x y z . t = \lambda x . \lambda y . \lambda z . t
\end{equation}

\begin{theorem}
    Premenn√° x sa vo v√Ωraze
    \begin{equation}
        \lambda x . t
    \end{equation}
    abstrakciou via≈æe na term√≠n $t$. O premennej $x$ hovor√≠me ≈æe je viazan√°.
    O premenn√Ωch ktor√© nie s√∫ viazan√© s√∫ voƒæn√©.
    \begin{align*}
        VP(x) &= {x} \\
        VP(\lambda x.t) &= VP(t)  \setminus \{x\} \\
        VP(t v) &= VP(t) \cup VP(v)
    \end{align*}
\end{theorem}

\begin{theorem}
    Premenovan√≠m naz√Ωvame nahradenie voƒæn√Ωch premenn√Ωch v term√≠ne.
    \begin{equation}
        t \{ y / x \}
    \end{equation}
\end{theorem}
V term√≠ne $t$ je premenovan√° premenn√° $x$ za $y$.

% TODO pridaj priklady
\subsection{$\alpha$-ekvivalencia}
\begin{theorem}
    O v√Ωrazov hovor√≠me ≈æe s√∫ alfa-ekvivalentn√© ak sa v√Ωrazy rovnaj√∫ a≈æ na premenovanie.
\end{theorem}

\begin{theorem}
    O substut√≠cii hovor√≠me pri nahraden√≠ jednej premenej druhou.
    \begin{equation}
        t [ y / x ]
    \end{equation}
\end{theorem}

Nahradenie je silnej≈°ie a vieme nahradi≈• aj premmenn√© viazann√© abstrakciou.

\subsection{$\beta$-ekvivalencia}

\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda x.t)u \to_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{\lambda}$)]{(\lambda x.t)u \rightarrow_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{l}$)]{t u \rightarrow_{\beta} t' u}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{u \to_{\beta} u'}
        \infer1[($\beta_{r}$)]{t u \rightarrow_{\beta} t u'}
    \end{prooftree}
\end{minipage}
\vskip 0.2in

% TODO vymysliet iny strom, tento je prevzaty
\begin{equation}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda y.y)x \to_{\beta} x}
        \infer1[($\beta_{l}$)]{(\lambda y.y)xz \to_{\beta} xz}
        \infer1[($\beta_{\alpha}$)]{\lambda x.(\lambda y.y)xz \to_{\beta} \lambda x . xz}
    \end{prooftree}
\end{equation}

\begin{theorem}
    Definujme rekurziu volania funkcie nasledovne
    \begin{align}
        f^{0}x &= x \\
        f^{n}x &= f(f^{n-1}x) \\
    \end{align}
    Potom Churchove ƒç√≠slo $c_{n}$ je $\lambda$-term√≠n
    \begin{equation}
        c_{n} = \lambda s . \lambda z . s^{n} (z)
    \end{equation}
\end{theorem}

Prirodzen√© ƒç√≠sla je potom definova≈•
\begin{align*}
    0 &= \lambda f x . x \\
    1 &= \lambda f x . f x \\
    1 &= \lambda f x . f (f x) \\
    2 &= \lambda f x . f ( f (f x))
\end{align*}

\begin{align*}
    succ(n) &=           (\lambda n f x .  f( n f x ))(\lambda f x . f^{n} x) \\
           &\to_{\beta} \lambda f x . f (( \lambda f x . f^{n} x ) f x)      \\
           &\to_{\beta} \lambda f x . f (( \lambda x . f^{n} x) x)           \\
           &\to_{\beta} \lambda f x . f (f^{n} x)                            \\
           &=           \lambda f x . f^{n+1} x                              \\
           &= n + 1
\end{align*}

Oper√°ciu sƒç√≠tania je potom mo≈æn√© definova≈• vykona≈•
\begin{theorem}
    $f_{+} = \lambda x. \lambda y. \lambda s. \lambda z. x s (y s z)$
\end{theorem}

Podobn√Ωm sp√¥sobom m√¥≈æeme vytvori≈• 
\begin{theorem}
    \begin{align*}
        True &= \lambda x y . x \\
        False &= \lambda x y . y
    \end{align*}
\end{theorem}

\begin{align*}
    if = \lambda b x y . b x y
\end{align*}

\begin{align*}
    if \textrm{ True } t u = (\lambda bxy.bxy)(\lambda xy.x) tu & \to_{\beta} (\lambda xy.(\lambda xy.x)xy)tu \\
                                                     & \to_{\beta} (\lambda y.( \lambda xy.x)ty)u \\
                                                     & \to_{\beta} (\lambda xy.x)tu \\
                                                     & \to_{\beta} (\lambda y.t)u \\
                                                     & \to_{\beta} t
\end{align*}

\begin{theorem}
    Jednoduch√Ω $\lambda$ kalkulus je ekvivalentn√Ω v√Ωpoƒçtovej sile turingovho stroja.
    Bez d√¥kazu
\end{theorem}

\section{Typovo jednoduch√Ω $\lambda$-calculus}

Typov√Ω lambda calculus je roz≈°√≠ren√≠m jednoduch√©ho o typy

\begin{theorem}
    Majme mno≈æinu $U$ spoƒç√≠tateƒæn√∫ nekoneƒçn√∫ abecedu obsahuj√∫cu typov√© premenn√©.
    Potom mno≈æina $\Pi$ obsahuje re≈•azce jednoduch√Ωch typov ktor√© su generovan√©
    gramatikov:
    \begin{equation}
        \Pi ::= U | (\Pi \to \Pi)
    \end{equation}
\end{theorem}

\begin{theorem}
    Kontextom rozumieme mno≈æinu $C$ tvoriacu 
    \begin{equation}
        { x_{1} : \tau_{1}, \dots, x_{n} : \tau_{n} }
    \end{equation}
    kde $\tau_{1}, \dots, \tau_{n} \in \Pi$ a $x_{1}, \dots , x_{n} \in$
    Koobor kontextu je mno≈æina obsahuj√∫ca
    \begin{equation}
        domain(\Gamma) = { x_{1}, \dots, x_{n} }
    \end{equation}
    Oboor kontextu je mno≈æina obsahuj√∫ca
    \begin{equation}
        range( \Gamma ) = { \tau \in \Pi  | (x : \tau ) \in \Gamma }
    \end{equation}
\end{theorem}

\noindent Pr√≠klady generovan√© gramatikou
\begin{itemize}
    \item $\vdash \lambda x.x : \sigma \to \sigma$
    \item $\vdash \lambda x. \lambda y.x : \sigma \to \tau \to \sigma$
    \item $\vdash \lambda x. \lambda y. \lambda z.x z (y z): (\sigma \to \tau \to \rho) \to (\rho \to \tau) \to \sigma \to \rho$
\end{itemize}

\begin{theorem}
    Postupnos≈• je trojica znaƒçen√°
    \begin{equation}
        \Gamma \vdash t : A
    \end{equation}
tvoren√° kontextom $\Gamma$, $\lambda$-term√≠nom $t$ a typom $A$.
\end{theorem}

Term√≠n $t$ je typu $A$ ak v kontexte $\Gamma$ ak je postupnos≈• derivovateƒæn√° pomocou pravidiel:
\begin{itemize}
    \item ax: v kontexte $x$ je typu $A$
    \item $\overset{I}{\rightarrow}$: ak je $x$ typu $A$, $t$ je typu B, potom
        funkcia $\lambda x.t$ ktor√° asociuje $x$ $t$ je typu $A \to B$
    \item $\overset{E}{\rightarrow}$: dan√° je funkcia $t$ je typu $A \to B$
        a argument $u$ je typu $A$, vysledok aplik√°cia $t u$ je typu $B$
\end{itemize}

\begin{center}
    \begin{prooftree}
        \infer0[ax]{\Gamma \vdash x : \Gamma(x)}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma , x : A \vdash t : B }
        \infer1[$\overset{I}{\rightarrow}$]{\Gamma \lambda x^{A}.t : A \to B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash t : A \to B }
        \hypo{\Gamma \vdash u : A }
        \infer2[$\overset{E}{\rightarrow}$]{\Gamma \vdash t u : B}
    \end{prooftree}
\end{minipage}

\section{Curry-Howardov izomorfizmus}

\begin{center}
    \begin{tabular}{ c c }
        Intuinistick√° logika & Typovo jednoduch√Ω $\lambda$ kalkulus \\
        \hline
        term√≠n                  & d√¥kaz \\
        typov√° premenn√°         & propoziƒçn√° premenn√° \\
    \end{tabular}
\end{center}

\begin{theorem}{Curry-Howard isomorphism}
    \begin{itemize}
        \item If $\Gamma \vdash M : \varphi \textrm{ potom } |\Gamma|  \vdash \varphi.$
        \item If $\Gamma \vdash \varphi \textrm{ potom existuje } M \in \Lambda_{\Pi}
            \textrm{ tak√© ≈æe } \Delta \vdash M : \varphi, \textrm{ kde }
            \Delta = { ( x_{\varphi} : \varphi ) | \varphi \in \Gamma }$
    \end{itemize}
\end{theorem}

\section{Poƒç√≠taƒçom asistovan√© dokazovanie}
    To com som vravel v prezentacii, historia, na zaciatku sa pouzivalo
\chapter{Lean dokazovac√≠ asistent}
    Lean je dokazovac√≠ asistent ktor√Ω bol vytvoren√Ω otvoren√Ω softv√©rov√Ω projekt
Leonardom de Mourom v Microsoft Reasearch v roku 2013.
    Jazyk sa neust√°le vyv√Ωja a moment√°lne sa nach√°dza vo ≈°tvrtej iter√°cii \cite{lean4} zatiaƒæ ƒço komunitn√Ω projekt matematickej kni≈ænice mathlib sa st√°le vyv√≠ja v tretej verzii\cite{lean3} vyv√Ωjanej od roku 2017.
    Implement√°cia Lean-u je v jazyku C++ a jeho jadro m√° 8000 riadkov.
    Prostredie je dostupn√© pre operaƒçn√© syst√©my Linux, Windows a Darwin.
    Interakt√≠vne prostredie pre dokazovanie je podporovan√© pre editory \emph{Emacs} a \emph{Visual Studio Code}.

    Lean podobne ako \emph{Coq} je zalo≈æen√© na kalkule kon≈°trukci√≠ ktor√Ω je zov≈°eobecnen√≠m te√≥rie jednoduch√Ωch typov
    a te√≥rii z√°vislostn√Ωch typov.
\section{Mathlib}
    Mathlib je komunitn√Ω projekt\cite{mathlib} ktor√©ho cieƒæom je zdru≈æova≈• matematick√∫
te√≥riu implementovan√∫ v Lean-e.
    Do projektu je mo≈æn√© jednoducho prispieva≈• po udelen√≠ privil√©gi√≠ niektor√Ωm zo
spr√°vcov repozit√°ra a odobren√≠m po≈æiadavky na zaƒçlenenie k√≥du.
    V√§ƒç≈°ina obsahu mathlibu obsahuje matematiku na vysoko≈°kolskej √∫rovni.
    V dobre p√≠sania pr√°ce je najvy≈°≈°ia hierarchia te√≥rie nasledovn√°:
\begin{lstlisting}
algebra/
category_theory/
data/
geometry/
measure_theory/
probability_theory/
algebraic_geometry/
combinatorics/
group_theory/
representation_theory/
algebraic_topology/
computability/
dynamics/
linear_algebra/
number_theory/
ring_theory/
analysis/
control/
field_theory/
logic/
order/
set_theory/
topology/
\end{lstlisting}
    V kontraste s in√Ωmi modern√Ωmi dokazovac√≠mi asistentami m√° mathlib mno≈æstvo
prispievateƒæov akademick√© vzdelanie v ƒçistej matematike\cite{mathlib_paper} ƒço
ovplyvnilo aj jeho obsah.

\section{V√Ωvojov√© prostredie}
    V na≈°om pr√≠pade sme pracovali vo v√Ωvojovom prostred√≠ \emph{Visual studio code}
v kombin√°ci√≠ s jeho leanovsk√Ωm roz≈°√≠ren√≠m ktor√© je mo≈æn√© nain≈°talova≈• cez
\emph{marketplace} Prostredie sa sklad√° z editora podporuj√∫ce UTF-8 znaky a okno s
interakt√≠vny v√Ωstupom reaguj√∫ce na polohu kurzora editora a kurzora poƒç√≠taƒçovej
my≈°i.
\begin{center}
    \begin{figure}[!ht]
        \centering
        \includegraphics[scale=0.25]{vscode_printscreen.png}
        \caption{V√Ωvojov√© prostredie}
    \end{figure}
\end{center}
    V pravom okne \emph{Lean infoview} je mo≈æn√© vidie≈• premenn√© s ich prisl√∫chaj√∫cimi
typmi a v pr√≠pade d√¥kazu aj formulu ktor√∫ je potrebn√© dok√°za≈• za znakom $\vdash$.
    Okrem toho poskytuje okno aj v√Ωstup zo zabudovan√Ωch pr√≠kazov prostredia
ako \emph{print} alebo \emph{reduce} ktor√© rozoberieme nesk√¥r.
    V pr√≠pade ≈æe sa nach√°dzame v taktickom m√≥de okrem zavedenia nov√Ωch predpokladov
alebo transorm√°cie existuj√∫cich je mo≈æn√© vidie≈• aj zmenu cieƒæa a podcieƒæov
napr√≠klad v pr√≠pade ≈æe sme sa dostali k d√¥kazu vymenovan√≠m pr√≠padov.
\section{Lambda kalkulus}
Pod pojmom Lean je mo≈æn√© rozumie≈• okrem dokazovacieho asistena aj funkcion√°lny programovac√≠
    jazyk.
V√Ωpoƒçtov√Ω model jednoduch√©ho lambda kalkulu je z programovac√≠ch paradigiem najbli≈æ≈°ie
    pr√°ve funkion√°lnemu sp√¥sobu programovania 
V nasleduj√∫cej ƒçasti predstavujeme z√°klady funkcion√°lneho programovania spolu 
    s typmi a n√°strojmi Lean-u na v√Ωvoj a mene≈æment menn√©ho priestoru.
\subsection{Kon≈°tanty, aplik√°cie}
    Deklar√°cia kon≈°tanty zav√°dza do syst√©mu nov√∫ deklar√°ciu bez defin√≠cie.
    Z tohto d√¥vodu sa ich pri rozvoji te√≥rie sna≈æ√≠me vyh√Ωba≈•.
    V nasleduj√∫cich pr√≠kladov budeme pracova≈• s prirodzen√Ωmi a cel√Ωmi ƒç√≠slami
ktor√Ωch ≈°trukt√∫ry s√∫ s√∫ƒças≈•ou kontextu bez nutnosti ich importova≈•.
\begin{lstlisting}
constant m : nat
\end{lstlisting}
    Hovor√≠ o deklarovan√≠ kon≈°tanty $m$ ktorej typ je \emph{nat}.
    Alternat√≠vny z√°pis pre prirodzen√© ƒç√≠slo je pomocou sekvencie \emph{\textbackslash nat}
alebo \emph{\textbackslash N} ktor√∫ skonvertuje leanovsk√© roz≈°√≠renie na znak $\mathbb{N}$.
    Vstavan√Ω pr√≠kaz ktor√Ω poskytuje typ v√Ωrazu zadan√©ho na argumente je \emph{\#check}:
\begin{lstlisting}
#check m
\end{lstlisting}
    Mrie≈æka na zaƒçiatku pr√≠kazu znaƒç√≠ zabudovan√Ω pr√≠kaz.
    V tomto pr√≠pade je to trivi√°lne tak ako bola kon≈°tanta zadefinovan√° s v√Ωstupom
v informaƒçnom okne:
\begin{lstlisting}
m : ‚Ñï
\end{lstlisting}
    Pre zadefinovanie viacer√Ωch kon≈°t√°nt jedn√Ωm pr√≠kazom a nie len v tomto pr√≠pade
existuje plur√°rna verzia pr√≠kazu \emph{constants}.

    Defin√≠cia kon≈°tanty typu funkcie medzi prirodzen√Ωmi ƒç√≠slami vyzer√° nasledovne:
\begin{lstlisting}
constant f : ‚Ñï ‚Üí ‚Ñï
constant h : ‚Ñï -> ‚Ñï -> ‚Ñï
\end{lstlisting}
    Aplik√°cia funkcie sa notaƒçne podob√° aplik√°cii v lambda kalkule kde argument
jednoducho prip√≠≈°eme za funkciu:
\begin{lstlisting}
#constants m n : ‚Ñï

#check f m
#check h m
#check h m n
\end{lstlisting}
    Zatiaƒæ ƒço v prvom pr√≠pade dostaneme typ $\mathbb{N}$ v druhom pr√≠pade
$\mathbb{N} \to \mathbb{N}$ a v tre≈•om vid√≠me aplik√°ciu na funkciu kde bude v√Ωsledn√Ωm
typom znova jednoduch√Ω typ $\mathbb{N}$.
    Aplik√°cia je asociat√≠vna z ƒæavej strany a  preto je nasleduj√∫ci v√Ωraz potrebn√© 
oz√°tvorkova≈• napravo inak dost√°vame typov√Ω error pre funkciu $g$ ktor√° oƒçak√°va 
cel√© ƒç√≠slo a nie typ funkcie f.
\begin{lstlisting}
constant f : ‚Ñï ‚Üí ‚Ñ§
constant g : ‚Ñ§ ‚Üí ‚Ñï
constant a : ‚Ñï

#check g (f a)
\end{lstlisting}
    Vo v√Ωchodiskovom pr√≠pade maj√∫ v≈°etky ƒç√≠sla v editore typ $\mathbb{N}$.
\begin{lstlisting}
#check 5
#check (-5 : ‚Ñ§)
\end{lstlisting}
    Pri deklar√°cia z√°porn√©ho ƒç√≠sla je tak nutn√© u≈æ explicitne uvies≈• typ.
Nasleduj√∫ce pr√≠klady ilustruj√∫ okrem funkcie $+$ aj implicitn√∫ konverziu medzi typmi.
\begin{lstlisting}
#constants (m : ‚Ñï) (n : ‚Ñ§)

#check 1 + 2
#check m + 1
#check n + 1
#check n + m
#check m + n
\end{lstlisting}
    V pr√≠pade prv√©ho pr√≠kladu dost√°vame typ $\mathbb{N}$ pre nespracovan√Ω v√Ωraz pre
ktor√Ω by sme mohli oƒçak√°va≈• v√Ωsledok $3$.
    Pre druh√Ω a tret√≠ v√Ωraz dost√°vame respekt√≠vne typy definovan√Ωch kon≈°t√°nt√Ωch
premenn√Ωch.
    Pri tre≈•om v√Ωraze je vhodn√© si uvedomi≈• u≈æ implicitn√∫ konverziu prirodzen√©ho
ƒç√≠sla na cel√©.
    Konverzia je e≈°te viac zrejm√° pri ≈°tvrtom v√Ωraze kde v√Ωsledn√Ωm typom je
$\mathbb{Z}$.
    Prekvapivo z piateho v√Ωrazu dost√°vame v informaƒçnom okne chybov√Ω v√Ωstup.
    Za neschopnos≈•ou dosta≈• typ stoj√≠ nedefinovan√° konverzia z cel√Ωch do prirodzen√Ωch
ƒç√≠sel.
    Za vysvetlen√≠m stoj√≠ sp√¥sob ak√Ωm pracuje pre≈•a≈æenie infixov√©ho oper√°tora $+$
podobn√Ωm sp√¥sobom ako pre triedy v jazyku $c++$ alebo $python$. ≈†tvrt√Ω a piaty
v√Ωraz je tak mo≈æn√© prep√≠sa≈• aj do tvaru:
\begin{lstlisting}
#check n.add(m)
#check m.add(n)
\end{lstlisting}
    Preto≈æe znak $+$ je pre≈•a≈æen√≠m funkcie \emph{add} nad ≈°trukt√∫rou mno≈æiny dan√Ωch
ƒç√≠sel.
\subsection{Abstrakcia}
    V predch√°dzaj√∫cej sekcii sme si uk√°zali explicitn√Ω typ ktor√Ω bol funkciou prirodzen√Ωmi
ƒç√≠slami ktor√Ω bol typu $\mathbb{N} \to \mathbb{N}$ alebo $\mathbb{N} \to \mathbb{N} \to \mathbb{N}$.
    V $\lambda$-kalklule koren≈°ponduje funkcia s abstrakciou. V Lean-e definujeme
anonymn√∫ funkciu alebo $\lambda$-v√Ωraz nasledovne.
\begin{lstlisting}
#check Œª x, x + x
\end{lstlisting}
    Typ argumentu x je odvoden√Ω z v√Ωrazu ktor√Ω na funkciu aplikujeme.
    Pre korektn√∫ aplik√°ciu mus√≠ ma≈• typ aj definovan√∫ funkciu sƒç√≠tania.
    Ak by sme chceli obmedzi≈• argument len na konkr√©tny typ rob√≠me to podobne ako
pri definovan√≠ kon≈°tanty. Potom aplik√°cia
\begin{lstlisting}
#constant (m : ‚Ñ§)

#check (Œª (x : ‚Ñï), x + x) (m : ‚Ñ§)
\end{lstlisting}
je u≈æ typovou chybou pri ktorej n√°m informaƒçn√© okno hl√°si
\begin{lstlisting}
type mismatch at application
  (Œª (x : ‚Ñï), x + x) m
term
  m
has type
  ‚Ñ§
but is expected to have type
  ‚Ñï
\end{lstlisting}
    Uvedieme si zop√°r pr√≠kladov vypoƒçtovo ekvivalentn√Ωch funkcii obdovu obdƒ∫≈ænika typu
$\mathbb{N} \to \mathbb{N} \to \mathbb{N}$
.
\begin{lstlisting}
#check Œª x y, x + x + y + y
#check Œª (x : ‚Ñï) (y : ‚Ñï), (x + x) + (y + y)
#check Œª (x y : ‚Ñï), (x + x) + (y + y)
#check Œª (x : ‚Ñï), Œª (y : ‚Ñï), (x + x) + (y + y)
\end{lstlisting}
    Zatiaƒæ ƒço prv√Ω pr√≠klad je polymorfn√Ω a fungoval by aj pri aplik√°cii cel√Ωch ƒç√≠sel,
nasleduj√∫ce s√∫ ekvivalentn√© z pohƒæadu typov a predstavuj√∫ in√Ω sp√¥sob z√°pisu.

    V pr√≠pade ≈æe by sme chceli z√≠ska≈• hodnotu z v√Ωrazu pou≈æ√≠jeme pr√≠kaz \emph{\#eval},
alebo \emph{\#reduce}. \emph{Reduce} na rozdiel od \emph{eval} pri vykon√°van√≠ pou≈æ√≠va
jadro na z√≠skanie typu a je tak menej efekt√≠vnym.
\begin{lstlisting}
#eval (Œª (x y : ‚Ñï), (x + x) + (y + y)) 2 3
\end{lstlisting}
    Aplik√°cia n√°m d√°va v√Ωsledok $10$ ktor√Ω je oƒçak√°vanou hodnotou.

    Pre pomenovanie alebo zadefinovanie takejto funkcie pou≈æ√≠vame pr√≠kaz \emph{def}
ktorej tvar v najjednoduch≈°ej podobe m√° tvar:
\begin{lstlisting}
def meno_definicie (argument_1 : typ) (argument_n : typ) :
    typ_navratovej_hodnoty 
:=
    telo funkcie
\end{lstlisting}
V pr√≠pade defin√≠cie ≈°tvorca aj s jeho v√Ωpoƒçtom
\begin{lstlisting}
def obvod_stvorca (x : ‚Ñï) (y : ‚Ñï) : ‚Ñï := x + x + y + y

#eval obsah_stvorca 3 5
\end{lstlisting}

    Kƒæ√∫ƒçov√© slovo \emph{def} alebo defin√≠cia m√° tak ako v matematike viacero
alternat√≠v ktor√© m√¥≈æeme vyu≈æ√≠va≈• v pr√≠pade ≈æe ide menej alebo viac v√Ωznamn√Ω objekt.
    Bez rozdielu tak m√¥≈æeme pou≈æ√≠va≈• \emph{lemma} alebo \emph{theorem}.
    Pre defin√≠ciu pr√≠kladu bez nutnosti definova≈• meno pou≈æ√≠vame kƒæ√∫ƒçov√© slovo
    \emph{example}.

\subsection{Typy}
    Doteraz sme uva≈æovali len s typmi mno≈æiny prirodzen√Ωch a cel√Ωch ƒç√≠sel
predstavuj√∫ce na pozad√≠ Leanu konkr√©te definovan√∫ ≈°trukt√∫ru.
    Typovanie v Lean-e ale podporuje urƒçenie abstraktn√©ho typu ktor√Ω patr√≠ univerzu(universe).
    Zavedenie t√Ωchto univerzov je motivan√© probl√©mom analogick√Ωm s Russelov√Ωm paradoxom 
a teda ƒçi mno≈æina v≈°etk√Ωch mno≈æ√≠n obsahuje sam√∫ seba.
    V te√≥rii typov sa jedn√° o Girardov paradox.
    Hierarchia t√Ωchto univerzov je usporiadan√° od 0 ƒço je univerzum tvoriace najjednoduch≈°ie
typy tak≈æe \emph{Type} alebo aj \emph{Type 0} je potom typom \emph{Type 1} ktor√Ω
je typom \emph{Type 2}.

    ≈†peci√°lne postavenie v typoch maj√∫ tvrdenia oznaƒçujeme \emph{Prop}.
    Okrem toho ≈æe v≈°etky d√¥kazy maj√∫ tento typ. 
    S√∫ postaven√© v hierachii oddelen√© na najni≈æ≈°ej √∫rovni a teda \emph{Prop} je 
typu \emph{Type}.
    Pre univerzum do ktor√©ho patr√≠ \emph{Prop} oznaƒçujeme \emph{Sort} ƒço je len 
alias.
Plat√≠ vz≈•ah \emph{Sort u + 1} = \emph{Type u}.

V tejto pr√°ci a ani vo v√§ƒç≈°ine pr√°ce s Leanom nie je potrebn√© vyu≈æ√≠va≈• hierachiu
    typov sofistikovanejsie ako prezentovan√Ωm sp√¥sobom.
\begin{lstlisting}
universe u v

constant (a : Typu u) (b : Type v)
\end{lstlisting}
Alebo je mo≈æn√© vyu≈æi≈• substituƒçn√∫ syntax kde \emph{*} znamen√° pre ƒæubovoƒæn√© univerzum
a v pr√≠pade \emph{\_} nech√°me doplni≈• typ automaticky Lean-om.
\begin{lstlisting}
constant f : Type _ ‚Üí Type _
constant g : Type

#check f g
\end{lstlisting}
    Kontrola typu aplik√°cie n√°m vyp√≠≈°e typ \emph{Type u\_1} ƒço je sp√¥sob Lean-u oznaƒçova≈•
e≈°te neurƒçen√Ω typ bez konkr√©tneho univerza.
\subsection{Premenn√©}
    V pr√≠pade ≈æe sa sna≈æ√≠me definova≈• viacero funkci√≠ s rovnak√Ωmi arugmentami alebo
pou≈æ√≠va≈• objekt ktor√©ho typ je vyjadren√Ω komplikovanej≈°√≠m z√°pisom je vhodn√© si
z√°pis zjednodu≈°i≈• premenn√Ωmi.
    Z inak na pohƒæad komplikovan√©ho z√°pisu
\begin{lstlisting}
universes u v

def kompozicia (Œ± : Type u) (Œ≤ : Type v) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (x : Œ±) :
    Œ±
:=
    g (f x)

def kompozicia‚ÇÇ (Œ± : Type u) (Œ≤ : Type v) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (x : Œ≤) :
    Œ≤
:=
    f (g x)
\end{lstlisting}
    tak dost√°vame.
    Premenn√© vstupuju do predpokladov defin√≠cii len tam kde s√∫ pou≈æ√≠t√© v jej tele.
\begin{lstlisting}
universes u v

variables Œ± : Type u
variables Œ≤ : Type v

def kompozicia (x : Œ±) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ± := g (f x)
def kompozicia‚ÇÇ (y : Œ≤) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ≤ := f (g y)
\end{lstlisting}
Vstupn√© argumenty dokonca m√¥≈æeme vynecha≈• √∫plne.
\begin{lstlisting}
variables (f : Œ± ‚Üí Œ≤)
          (g : Œ≤ ‚Üí Œ±)

def kompozicia : Œ± := g (f x)
def kompozicia‚ÇÇ : Œ≤ := f (g y)
\end{lstlisting}
D√¥kazy to u≈æ ale m√¥≈æe robi≈• v ist√Ωch pr√≠padoch na prv√Ω pohƒæad zm√§toƒçn√©.
Pre doplnenie dod√°vame ≈æe nie je nutn√© ani definova≈• n√°vratov√Ω typ $\alpha$
    respekt√≠ve $\beta$, explicitn√© urƒçenie n√°vratov√©ho typu je ale vhodn√© nie len
    pre ƒçitateƒæa ale aj pre overenie spr√°vnosti v√Ωsledn√©ho typu.
\subsection{Kontext, menn√Ω priestor}
    Pre ovl√°danie menn√©ho priestoru a kontextu existuj√∫ v Lean-e r√¥zne mechanizmy
z ktor√Ωch si pop√≠≈°eme len tie najd√¥le≈æitej≈°ie.
    Najjednoduch≈°√≠m je s√∫bor, ktor√©ho defin√≠cie, kon≈°tanty a premenn√© vstupuj√∫ do
kontextu pri deklar√°cii a na konci s√∫boru zanikn√∫.
    Import obsahu in√Ωch s√∫borov sa rob√≠ jednoduch√Ωm pr√≠kazom \emph{import} ktor√Ω
mus√≠ by≈• deklarovan√Ω na zaƒçiatku s√∫boru. V s√∫borovej hierachii sa potom od najvy≈°≈°ej
√∫rovne v jednej z vyhƒæad√°van√Ωch ciest vnorujeme cez bodku.
\begin{lstlisting}
import order.lattice
\end{lstlisting}
    Sa sna≈æ√≠ n√°js≈• prieƒçinok \emph{order} so s√∫borom \emph{lattice.lean}.
    V aktu√°lnej verzii Lean-u v ƒçase p√≠sania pr√°ce sa d√° zisti≈• zoznam prehƒæad√°van√Ωch
ciest prep√≠naƒçom \emph{path} priamo programu \emph{lean}.

    Deklar√°cie premenn√Ωch definovan√© v argumetnoch defin√≠cie prepisuj√∫ vonkaj≈°√≠ kontext.
    V pr√≠pade ≈æeby sme chceli rozdeli≈• kontext s√∫boru na men≈°ie sekcie jednoduch√Ωm
nastrojom je dvojica \emph{section nazov\_sekcie}, \emph{end nazov\_sekcie}.
\begin{lstlisting}
section prirodzene_cisla
  variable Œ± : ‚Ñï
end prirodzene_cisla

section cele_cisla
  variable Œ± : ‚Ñ§
end cele_cisla
\end{lstlisting}
    Pou≈æ√≠vanej≈°√≠m je menn√Ω priestor \emph{namespace nazov} ktor√Ω po zadefinovan√≠ pon√∫ka
mo≈ænos≈• op√§tovn√©ho zavedenia kontextu a vnorenie podobne ako rovnomenn√Ω mechanizmus
v jazyku C++.
\begin{lstlisting}
universe u

namespace skryty

  variable (Œ± : Type u)
  namespace priestor
    def identita (a : Œ±) : Œ± := a
  end priestor
end skryty

#check skryty.priestor.identita

open skryty.priestor

#check identita
\end{lstlisting}
\section{Dokazovanie}

    K dokazovaniu v Leane je mo≈æn√© pristupova≈• viacer√Ωmi sp√¥sobmi.
    Po poskytnut√≠ d√¥kazu vn√∫torne Lean-u nez√°le≈æ√≠ na sp√¥sobe ak√Ωm bolo tvrdenie 
dok√°zan√©.
    Prv√Ωm sp√¥sobom je priamoƒçiara kon≈°trukcia pomocou funkci√≠ typu ktor√° je d√¥sledkom
tak ako to vypl√Ωva z Curry-Howardovho izomorfizmu.
    Druh√Ωm sp√¥sobom je sp√§tn√© dokazovanie ktor√© vyu≈æ√≠va taktick√Ω m√≥d za pomocoi
sady pr√≠kazov poloautomatiz√°cie.
    V leanovskej komunite je preferovan√Ω pr√°ve druh√Ω sp√¥sob hoci pre jednoducho
dok√°zateƒæn√© tvrdenia staƒç√≠ a je vyu≈æ√≠van√° aj dopredn√° verzia.

\subsection{Dopredn√© dokazovanie}
    D√¥kaz zostaven√Ω len z $\lambda$-funkci√≠ ktor√© transformuj√∫ argumenty
na v√Ωsledn√Ω typ je pri zlo≈æitej≈°√≠ch d√¥kazoch ≈•a≈æko ƒçitateƒæn√Ω.
    Pre lep≈°iu ƒçitateƒænos≈• poskytuje Lean-e n√°stroje ktor√© sa sna≈æia kon≈°truova≈• d√¥kazy tak
aby boli ƒçitateƒæn√© ako tie klasick√©.
    Nasleduj√∫ci pr√≠klad:
\begin{lstlisting}
variables p d : Prop

def plati_predpoklad : p ‚Üí d ‚Üí p := Œª hp : p, Œª hd : d, hp
\end{lstlisting}
    Je mo≈æn√© prep√≠sa≈• do ƒçitateƒænej≈°ieho s rovnak√Ωm sp√¥sobom kon≈°trukcie na
\begin{lstlisting}
def plati_predpoklad : p ‚Üí d ‚Üí p :=
  assume hp : p,
  assume hd : d,
  show p, from hp
\end{lstlisting}
Pre lep≈°iu predstavu toho ƒço sa deje na pozad√≠ Lean poskytuje v√Ωstup:
\begin{lstlisting}
pq: Prop
hp: p
hq: q
‚ä¢ p
\end{lstlisting}

    Defin√≠cia hovor√≠ o trivi√°lnom tvrden√≠ ak z $p$ vypl√Ωva $d$ tak plat√≠ $p$. Voƒæn√Ωm
prekladom sa d√° d√¥kaz ƒç√≠ta≈• ako:

\begin{itemize}
    \item Predpokladajme hp,
    \item a predpokladajme hd,
    \item potom vieme uk√°za≈• ≈æe plat√≠ p z predpokladu hp.
\end{itemize}

    O ƒçosi zlo≈æitej≈°√≠m pr√≠kladom je tvrdenie ≈æe ak plat√≠ $p$ konjukcia $q$ tak potom
plat√≠ $q$ konjukcia $p$.

\begin{lstlisting}
def symetria_konjukcie : p ‚àß q ‚Üí q ‚àß p :=
  assume hpq : p ‚àß q,
    have hp   : p     := and.left  hpq,
    have hq   : q     := and.right hpq,
    have hqp  : q ‚àß p := and.intro hq hp,
  show q ‚àß p, from hqp
\end{lstlisting}

    Konjukciu v editore je mo≈æn√© nap√≠sa≈• cez \emph{\textbackslash and}.
    Ak sa pozrieme na typ konjukcie a funkci√≠ ktor√© sme dostali cez pr√≠kaz check.
    Dostaneme v√Ωstup:

\begin{lstlisting}
and : Prop ‚Üí Prop ‚Üí Prop
and.left : ?M_1 ‚àß ?M_2 ‚Üí ?M_1
and.right : ?M_1 ‚àß ?M_2 ‚Üí ?M_2
and.intro : ?M_1 ‚Üí ?M_2 ‚Üí ?M_1 ‚àß ?M_2
\end{lstlisting}

    ƒåo intuit√≠vne koren≈°ponduje s t√Ωm ƒço od t√Ωchto funkci√≠ oƒçak√°vame.
    Tento d√¥kaz je roz≈°√≠ren√≠ o pr√≠kaz have ktor√Ω vytv√°ra predpoklad z existuj√∫cich.
    V poslednej f√°ze d√¥kazu je interakt√≠vny v√Ωstup:

\begin{lstlisting}
pq: Prop
hpq: p ‚àß q
hp: p
hq: q
hqp: q ‚àß p
‚ä¢ q ‚àß p
\end{lstlisting}

\subsection{Sp√§tn√© dokazovanie}

V doprednom dokazovan√≠ sme sa sna≈æili transformova≈• predpoklady tak aby na konci
    bol v√Ωsledkom d√¥sledok.
Ako evokuje n√°zov v sp√§tnom dokazovan√≠ sa sna≈æ√≠me transformova≈• cieƒæ tak aby sme
    sa dostali k jedn√©mu z predpokladov.
Pre tento √∫ƒçel existuje v Lean-e ≈°peci√°lny stav v dokazovan√≠ ktor√Ω naz√Ωvame taktick√Ω
    m√≥d.
Na rozdiel od dopredn√©ho dokazovania je nutn√© ovl√°da≈• v√§ƒç≈°iu sadu pr√≠kazov ktor√©
    priamo transformuj√∫ cieƒæ.
Dokazovanie je tak u≈æ≈°ie prepojen√© s interakt√≠vnym prostred√≠m a pripom√≠na tak hru.
ƒéal≈°ou v√Ωhodou tohto dokazovania je mo≈ænos≈• vyu≈æitie umelej inteligencie pri vyhƒæadan√≠
vyhƒæadavn√≠ d√¥kazu.
Tak√Ωto pr√≠stup je obzvl√°≈°≈• u≈æitoƒçn√Ω napr√≠klad v pr√≠pade ≈æe mus√≠me dok√°za≈• identitu
    ktorej d√¥kaz je pracn√Ω, a tvor√≠ ho veƒæa za sebou nasleduj√∫cich vyu≈æit√≠ in√Ωch
    ident√≠t ako napr√≠klad vyu≈æitie komutativity alebo asociativity.
U≈æ≈°ie prepojenie s prostred√≠m a automatiz√°cia vyhƒæadania d√¥kazu tohto m√≥du ale
    ide na √∫kor priamej ƒçitateƒænosti.
Pre √∫plnos≈• dopl≈àame ≈æe v taktickom m√≥de nie je nutn√© transformova≈• cieƒæ a je mo≈æn√©
    vyu≈æi≈• kon≈°trukcie dopredn√©ho d√¥kazu.

Pre dokazovanie v taktickom m√≥de pou≈æ√≠vame kon≈°trukciue ktor√° je ohraniƒçen√°
    kon≈°trukciou \emph{begin} a \emph{end}.

\begin{lstlisting}
def symetria_konjukcie : p ‚àß q ‚Üí q ‚àß p :=
  begin
    intro h,
    cases h with p q,
    split,
    exact q,
    exact p
  end
\end{lstlisting}

D√¥kaz zaƒç√≠na zaveden√≠m predpokladu z implik√°cie k ostatn√Ωm o ktor√Ωch tvrd√≠me ≈æe
    s√∫ pravdiv√© pr√≠kazom \emph{intro} a rozdelen√≠m konjukcie pr√≠kazom \emph{cases}
    s argumentom zavedenej konjukcie a ich explicitn√Ωm pomenovan√≠m.
V√Ωstup z informaƒçnom okne potom obsahuje.

\begin{lstlisting}
pq: Prop
p: p
q: q
‚ä¢ q ‚àß p
\end{lstlisting}

Pr√≠kazom \emph{split} potom rozdel√≠me cieƒæ na podciele kde sa sna≈æ√≠me dok√°za≈•
ƒæav√∫ a prav√∫ stranu ktor√∫ vid√≠me v informaƒçnom okne ako:

\begin{lstlisting}
2 goals
pq: Prop
h_left: p
h_right: q
‚ä¢ q
pq: Prop
h_left: p
h_right: q
‚ä¢ p
\end{lstlisting}

D√¥kaz potom uzatvor√≠me pr√≠kazom \emph{exact} ktor√Ω uk√°≈æe na jeden z predpokladov
    s rovnak√Ωm typom ako cieƒæ.

\subsubsection{Abstraktn√© ≈°trukt√∫ry v Lean-e}
    V matematike a tak isto aj v programovan√≠ sa ƒçasto vyskytuj√∫ mno≈æiny objetkov
nad ktor√Ωmi je mo≈æn√© vykon√°va≈• oper√°cie bez ohƒæadu na ich obsah pri splnen√≠
urƒçit√Ωch podmienok.
    V matematike hovor√≠me o ≈°trukt√∫rach ktor√© maj√∫ striktn√∫ defin√≠ciu v programovan√≠
sa d√° voƒæne hovori≈• o triedach.
    Matematick√© ≈°trukt√∫ry v Lean-e su navrhovan√© pr√°ve pomocou mechanizmu tried.
    Kde defin√≠cii triedy zodpoved√° ≈°trukt√∫ra obsahuj√∫ca z defin√≠ce vypl√Ωvaj√∫ce podmienky.
    Potom in≈°tanciou triedy m√¥≈æe by≈• znova ≈°trukt√∫ra ktor√° je definovan√° na u≈æ≈°ej mno≈æine
znova spƒ∫≈àaj√∫cej podmienky, pr√≠kladom je vz≈•ah grupy a podgrupy alebo
priestoru a podpriestoru.
    Alebo in√° mno≈æina ktor√° spƒ∫≈àa okrem podmienok p√¥vodnej ≈°trukt√∫ry ƒèal≈°ie ktor√© ju
obohacuj√∫.
    Pr√≠kladom tak√©ho vz≈•ahu m√¥≈æe by≈• monoid ktor√Ω je mno≈æinou s asociat√≠vnou oper√°ciou
a semigrupou ktor√° m√° aj neutr√°lny prvok.
    Medzi popisovan√Ωmi ≈°trukt√∫rami a konkr√©tnym objektom stoj√≠ e≈°te jedna √∫rove≈à
abstrakcie t√Ωkaj√∫ca sa mno≈æiny na ktorej je ≈°trukt√∫ra definovan√°, hovor√≠m
o line√°rnych grup√°ch ktor√© su definovan√© nad invertovateƒæn√Ωmi maticami alebo 
    3-dimenzion√°lnom vektorovom priestore.
    Dobrou anal√≥giou z programovania m√¥≈æe by≈• trieda reprezentuj√∫ca zoznam ktorej
obsah tvoria objekty inej triedy.
    V silne typovom jazyku ako C++ sa tento mechanizmus naz√Ωva ≈°abl√≥na(template).
    Analogick√Ωm mechanizmom v Lean-e s√∫ z√°vislostn√© typy.

\chapter{Te√≥ria usporiadania}
    V tejto kapitole sa budeme sna≈æi≈• uk√°za≈• mo≈ænosti Lean-u a vyu≈æitie u≈æ existuj√∫cich
defin√≠cii v mathlibe pre dok√°zanie viet t√Ωkaj√∫cich sa te√≥rie usporiadania.
    Pre tento √∫ƒçel je Lean ide√°lny z pohƒæadu na≈°ich mo≈ænost√≠ definovania vlastnost√≠
usporiadania, ktor√© n√°sledne mo≈æno aplikova≈• na abstraktn√∫ mno≈æinu objektov.
    % Toto by bolo dobr√© rozpracova≈• ƒèalej, mo≈æno konkr√©tny pr√≠klad
    V√Ωsledn√Ω typ je potom odvoden√Ω na z√°klade z√°vislostn√Ωch typov.
    Usporiadanie je jednoducho intuit√≠vne uchopiteƒæn√° vlastnos≈• bez matematick√Ωch
preddispoz√≠ci√≠.
    V ka≈ædodennom ≈æivote porovn√°vame svoju v√Ω≈°ku, ƒças, ktor√Ω trval na vybehnutie do kopca
alebo aj ƒç√≠selne neohodnoten√©, subjekt√≠vne merateƒæn√© objekty ako ktor√Ω album
od skupiny preferujem.
    Na ot√°zky si potom vieme odpoveda≈• "ja som vy≈°≈°√≠", "zabehol si pomal≈°ie" alebo
tieto albumy s√∫ neporovnateƒæn√©.

Te√≥ria usporiadania sa sna≈æ√≠ tieto vlastnoti form√°lne definova≈• a rozv√≠ja≈• ƒèalej
ot√°zkami ako, ak√© je horn√© celej mno≈æiny objektov. Existuje ohraniƒçenie horn√© alebo
doln√© pre ƒæubovoƒæn√∫ podmno≈æinu objektov?
    Pre struƒçnos≈• sa v r√°mcii defin√≠cii obmedz√≠me len na defin√≠ciu usporiadania
ako rel√°cie, ƒçi≈æe podmno≈æinu kartezi√°nskeho s√∫ƒçinu dvoch mno≈æ√≠n.

\begin{theorem}
    Majme mno≈æinu $P$, potom usporiadanie alebo ƒçiastoƒçn√© usporiadanie na mno≈æine
    $P$ je bin√°rna rel√°cia $\leq$ tak√° ≈æe, pre v≈°etky $x,y,z \in P$
    \begin{itemize}
        \item $x \leq x$ vlastno≈• reflexivity
        \item $x \leq y$ a $y \leq x$ implikuje $x = y$ antisymetria
        \item $x \leq y$ a $y \leq z$ impikuje $x \leq z$ tranzitivita
    \end{itemize}
\end{theorem}

    Ide√°lnym n√°strojom pre uva≈æovanie nad usporiadan√≠m s√∫ \emph{Hasseho} diagramy.
    Ako pr√≠klad uv√°dzame diagram "kocky".

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.15]{cube.png}
    \caption{Usporiadania $\mathcal{P}(\{a,b,c\})$}
\end{figure}

    Na obr√°zku je usporiadanie v≈°etk√Ωch podmno≈æ√≠n trojprvkovej mno≈æiny $\{ a,b,c \}$.
    Usporiadanie tvor√≠ bin√°rna rel√°cia kardinality podmno≈æ√≠nm priƒçom porovn√°vame
len podmno≈æiny obsahuj√∫ce spoloƒçn√Ω prvok.
    Vy≈°≈°ie s√∫ polo≈æen√© v√§ƒç≈°ie prvky a porovnateƒæn√Ωmi prvkami pova≈æujeme len tie,
ktor√© s√∫ "pokryt√©" jednosmernou cestou cez orientovan√© hrany grafu.

    V Leane je usporiadanie definovan√© ako roz≈°√≠renie triedy predusporiadania, ktor√°
je rel√°ciou, ktor√° nem√° oproti ƒçiastoƒçn√©mu usporiadaniu vlastnos≈• antisymetrie.

\begin{lstlisting}
class has_le       (Œ± : Type u) := (le : Œ± ‚Üí Œ± ‚Üí Prop)
class has_lt       (Œ± : Type u) := (lt : Œ± ‚Üí Œ± ‚Üí Prop)

class preorder (Œ± : Type u) extends has_le Œ±, has_lt Œ± :=
(le_refl : ‚àÄ a : Œ±, a ‚â§ a)
(le_trans : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c)
(lt := Œª a b, a ‚â§ b ‚àß ¬¨ b ‚â§ a)
(lt_iff_le_not_le : ‚àÄ a b : Œ±, a < b ‚Üî (a ‚â§ b ‚àß ¬¨ b ‚â§ a) . order_laws_tac) -- toto chceme aj vysvetlit
\end{lstlisting}
ƒåiastoƒçn√© usporiadanie je potom roz≈°√≠ren√≠m predusporiadania o vlastnos≈• antysymetrie.
\begin{lstlisting}
class partial_order (Œ± : Type u) extends preorder Œ± :=
(le_antisymm : ‚àÄ a b : Œ±, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b)
\end{lstlisting}

DOPLN PRIKLAD NAJLEPSIE AK NAS USPORIADANY POSET Z PRIKLADU

\subsubsection{Zv√§z}
    Zv√§z je usporiadan√° mno≈æina, pre ktor√∫ navy≈°e plat√≠, ≈æe pre ka≈æd√© 2 prvky $a, b$
vieme n√°js≈• prvok $c$, ktor√Ω je ich jedineƒçn√Ωm najmen≈°√≠m horn√Ωm, respekt√≠ve(\emph{supremum})
najv√§ƒç≈°√≠m doln√Ωm ohraniƒçen√≠m(\emph{infinum}).
    V pr√≠pade intervalu re√°lnych ƒç√≠sel je toto ohraniƒçenie jednoducho predstaviteƒæn√©
ako bod ohraniƒçuj√∫ce mno≈æinu na ƒç√≠selnej osi.
    Ak ide o ƒçiastoƒçn√© usporiadanie, n√°zov je pre tieto ohraniƒçenia prvkov
motivovan√Ω zobrezn√≠m na grafe.
    \emph{Spojenie} $\sqcup, \vee$ pre supremum, respekt√≠ve \emph{priesek} $\sqcap, \wedge$ pre infinum.
    Popisnej≈°√≠m n√°zvom pre zv√§z je preklad anglicky pou≈æ√≠van√©ho n√°zvu \emph{lattice}
"mrie≈æka" tak isto motivovan√° zobrazen√≠m tak√©ho usporiadania na grafe.
    Pri dokazovan√≠ viet o zv√§zoch je ƒçasto vyu≈æ√≠van√° vlastnos≈• duality najmen≈°ieho
horn√©ho a du√°lne najv√§ƒç≈°ieho doln√©ho ohraniƒçenie pre druh√∫ polovicu d√¥kazu.
    V pr√≠pade zv√§zu je t√°to vlastnos≈• vyu≈æit√° rovno v defin√≠cii zv√§zu ako spojenie
du√°lnej defin√≠cie supr√©moveho a infinumov√©ho semizv√§zvu.

\begin{lstlisting}
class has_sup (Œ± : Type u) := (sup : Œ± ‚Üí Œ± ‚Üí Œ±)
class has_inf (Œ± : Type u) := (inf : Œ± ‚Üí Œ± ‚Üí Œ±)

infix ‚äî := has_sup.sup
infix ‚äì := has_inf.inf

class semilattice_sup (Œ± : Type u) extends has_sup Œ±, partial_order Œ± :=
(le_sup_left : ‚àÄ a b : Œ±, a ‚â§ a ‚äî b)
(le_sup_right : ‚àÄ a b : Œ±, b ‚â§ a ‚äî b)
(sup_le : ‚àÄ a b c : Œ±, a ‚â§ c ‚Üí b ‚â§ c ‚Üí a ‚äî b ‚â§ c)

class semilattice_inf (Œ± : Type u) extends has_inf Œ±, partial_order Œ± :=
(inf_le_left : ‚àÄ a b : Œ±, a ‚äì b ‚â§ a)
(inf_le_right : ‚àÄ a b : Œ±, a ‚äì b ‚â§ b)
(le_inf : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ b ‚äì c)

class lattice (Œ± : Type u) extends semilattice_sup Œ±, semilattice_inf Œ±
\end{lstlisting}

Na nasleduj√∫cich grafoch si uk√°≈æeme ako vyzeraj√∫ zv√§zy.

PRIDAT VLASTNY PRIKLAD, OPYTAT SA
\begin{lstlisting}
def poset_nat : sublattice ‚Ñï :=
    { carrier := {n : ‚Ñï | 1 ‚â§ n},
    inf_mem :=
      begin¬∑
        intro a,
        intro b,
        intro a_set,
        intro b_set,
        simp at a_set,
        simp at b_set,
        simp,
        split,
        exact a_set,
        exact b_set,
      end,
    sup_mem := by finish,
}
\end{lstlisting}

\subsubsection{Modul√°rne zv√§zy}

V nasleduj√∫com √∫seku si uk√°≈æeme vetu t√Ωkaj√∫cu sa ≈°peci√°lneho typu zv√§zu s vlastnos≈•ou
    modularity a uk√°≈æeme si form√°lny d√¥kaz a jej implement√°ciu v Leane, ktor√∫ si
    podrobne rozoberieme.

O zv√§ze $L$ hovor√≠me, ≈æe je modul√°rny, v pr√≠pade, ≈æe m√° nasleduj√∫cu vlastnos≈•.

\begin{equation*}
    (\forall x,y,z \in L) x \geq y \implies x \wedge ( y \vee z) = (x \wedge y) \vee z
\end{equation*}

V Leane definovan√Ω ako roz≈°√≠renie zv√§zu:

\begin{lstlisting}
class modular_lattice(Œ± : Type u) extends lattice Œ± :=
  (modular_law: ‚àÄ (x u v : Œ± ), (x ‚â§ u) ‚Üí u ‚äì (v ‚äî x) = (u ‚äì v) ‚äî x )
\end{lstlisting}

V nasleduj√∫com √∫seku si uk√°≈æeme vetu o modul√°rnom izomorfizme a podrobne
    si rozoberieme implement√°ciu jej d√¥kazu s obsahom prostredia v Leane.

TODO ZJEDNOTIT ZNACENIE DEFINICIE A LEAN-u
\subsection{Modul√°rne zv√§zy}
    \begin{theorem} \emph{Veta o izomorfizme modul√°rnych zv√§zov}
    Nech L je modul√°rnym zv√§zom a $a, b \in L$. Potom
        \begin{equation}
            \varphi_{b}: x \mapsto x \wedge b, x \in [a, a \vee b],
        \end{equation}
    Je izomorfizmom medzi intervalmi $[a, a \vee b]$ a $[ a \wedge b, b]$.
    Inverzn√Ωm izomorfizmom je
        \begin{equation}
            \psi_{a}: y \mapsto x \vee a, y \in [a \wedge b, b].
        \end{equation}
    \end{theorem}
    \emph{D√¥kaz}.  Staƒç√≠ uk√°za≈•, ≈æe $\varphi_{b}\psi_{a}(y) = y$ pre v≈°etky $x \in [a, a \vee b]$.
    Z duality vypl√Ωva, ≈æe $\varphi_{b}\psi_{a}(y) = y$ pre v≈°etky
        $y \in [a \wedge b, b]$,
    Majme $x \in [a, a \vee b]$. Potom
        $\psi_{a}\varphi_{b} = ( x \wedge b ) \vee a$ nerovnos≈• $a \leq x$ plat√≠
        potom aj modularita
        \begin{equation}
            \varphi_{a}\psi_{b}(x) =
            ( x \wedge b ) \vee a =
            x \wedge ( b \vee a) =
            x
        \end{equation}
        preto≈æe
        \[
            \pushQED{\qed}
            x \leq a \vee b. \qedhere
            \popQED
        \]

    Predstaven√Ω d√¥kaz je zn√°zornen√Ω na nasleduj√∫com grafe.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.35]{modular_lattice_isomorphism.png}
    \caption{Izomorfizmus modul√°rneho zv√§zu}
\end{figure}

    V pr√≠pade form√°lneho d√¥kazu sme sa mohli v ƒçasti d√¥kazu odk√°za≈• na dualitu. 
    V pr√≠ n√°vrhu d√¥kazu v Leane mus√≠me uk√°za≈• d√¥kaz z "oboch" str√°n.

\begin{lstlisting}
theorem modular_lattice_isomorphism { Œ±: Type u } [ modular_lattice Œ± ]
{ u v w x y : Œ± } :
  x ‚â§ u ‚Üí
  x ‚â• v ‚Üí
  x ‚â• u ‚äì v ‚Üí
  x ‚â§ u ‚äî v ‚Üí
  u ‚äì ( v ‚äî x ) = x ‚àß (u ‚äì x) ‚äî v = x
  :=
  begin
 1        intros h1 h2 h3 h4,
 2        split,
 3        {
 4          rw modular_lattice.modular_law,
 5          exact sup_eq_right.mpr h3,
 6          exact h1
 7        },
 8        {
 9          rw inf_comm,
10          rw ‚Üê modular_lattice.modular_law,
11          exact inf_eq_left.mpr h4,
11          exact h2
12        }
  end
\end{lstlisting}
    Zaƒç√≠name v taktickom m√≥de pr√°zdnou kon≈°trukciou \emph{begin} a \emph{end}
    Interakt√≠vne prostredie vyzer√° nasledovne.
\begin{lstlisting}
Œ±: Type u
_inst_1: modular_lattice Œ±
u v w x y : Œ±
‚ä¢ x ‚â§ u ‚Üí x ‚â• v ‚Üí x ‚â• u ‚äì v ‚Üí x ‚â§ u ‚äî v ‚Üí u ‚äì (v ‚äî x) = x ‚àß u ‚äì x ‚äî v = x
\end{lstlisting}
    Prv√Ωm krokom d√¥kazu je presunutie predpokladov zo sledu implik√°cii do
prostredia pre ƒèal≈°iu pr√°cu s nimi s oznaƒçen√≠m $h1,h2,h3,h4$.
\begin{lstlisting}
Œ±: Type u
_inst_1: modular_lattice Œ±
uvwxy: Œ±
h1: x ‚â§ u
h2: x ‚â• v
h3: x ‚â• u ‚äì v
h4: x ‚â§ u ‚äî v
‚ä¢ u ‚äì (v ‚äî x) = x ‚àß u ‚äì x ‚äî v = x
\end{lstlisting}
    Cieƒæ potom pozost√°va z konjukcie, kde v druhej ƒçasti m√°me v√Ωraz implicitne
oz√°tvorkovan√Ω zƒæava.
    V√Ωraz rozdel√≠me do dvoch podcieƒæov pr√≠kazom \emph{split}, a pre lep≈°iu
ƒçitateƒænos≈• oz√°tvorkujeme mno≈æinov√Ωmi z√°tvorkami. Nach√°dzame sa v stave
\begin{lstlisting}
  begin
    intros h1 h2 h3 h4,
    split,
    {
    },
    {
    }
  end
\end{lstlisting}
v ktorom n√°m lean ukazuje prostredie, kde mus√≠me dok√°za≈• ƒæav√∫ ƒças≈• konjukcie.
\begin{lstlisting}
‚ä¢ u ‚äì (v ‚äî x) = x
\end{lstlisting}
Na cieƒæ pou≈æijeme z defin√≠cie modul√°rneho zv√§zu vlastnos≈• modularity
\begin{lstlisting}
    (modular_law: ‚àÄ (x u v : Œ± ), (x ‚â§ u) ‚Üí u ‚äì (v ‚äî x) = (u ‚äì v) ‚äî x )
\end{lstlisting}
a transformujeme prep√≠≈°eme cieƒæ cez pr√≠kaz
\begin{lstlisting}
rw modular_lattice.modular_law,
\end{lstlisting}
na nasleduj√∫ci, kde m√° $u \sqcap v$ vy≈°≈°iu precedenciu
\begin{lstlisting}
‚ä¢ u ‚äì v ‚äî x = x
\end{lstlisting}
    Nasleduj√∫ca transform√°cia vy≈æaduje znalos≈• u≈æ dok√°zan√Ωch defin√≠ci√≠, ktor√©
boli dok√°zan√© pre podkladov√© ≈°trukt√∫ry. Pou≈æijeme nasleduj√∫cu defin√≠ciu, ktor√° vych√°dza
z kontextu \emph{semilattice\_sup}.
\begin{lstlisting}
% @[simp] theorem sup_eq_right : a ‚äî b = b ‚Üî a ‚â§ b :=    / TODO NEZABUDNUT
%  le_antisymm_iff.trans $ by simp [le_refl]             / ODKOMENTOVAT
    \end{lstlisting}
    Zauj√≠mavos≈•ou je, ≈æe si Lean dok√°≈æe substiuova≈• v√Ωraz $u \sqcap v$ za $a$ z uveden√©ho
v√Ωrazu. Pri pou≈æit√≠ vety dost√°vame ekvivalenciu, ktor√° je definovan√° ako ≈°trukt√∫ra.
\begin{lstlisting}
structure iff (a b : Prop) : Prop :=
    intro :: (mp : a ‚Üí b)
             (mpr : b ‚Üí a)
\end{lstlisting}
Z tejto ≈°trukt√∫ry pou≈æijeme implik√°ciu smeruj√∫ca doƒæava nasledovne:
\begin{lstlisting}
    exact sup_eq_right.mpr h3,
\end{lstlisting}
    Cieƒæ je teda transformovan√Ω na:
\begin{lstlisting}
‚ä¢ x ‚â§ u
\end{lstlisting}
ƒço je u≈æ uveden√Ω predpoklad $h1$. T√Ωmto sme dok√°zali jeden z podcieƒæov.
    V tejto chv√≠li by sme sa v literat√∫re mohli odvola≈• na dualitu v√Ωrazov.
    V Leane mus√≠me poskytn√∫≈• d√¥kaz aj o druhom cieli. Ideme dok√°za≈•
\begin{lstlisting}
‚ä¢ u ‚äì x ‚äî v = x
\end{lstlisting}
V tejto chv√≠li chceme znova pou≈æi≈• modularitu, leanu je, ale potrebn√© explicitne poveda≈•,
    ≈æe chceme prep√≠sa≈• v√Ωraz nach√°dzaj√∫ci na pravej strane rovnosti pomocou symbolu
ƒæavej ≈°√≠pky.
\begin{lstlisting}
rw ‚Üê modular_lattice.modular_law,
\end{lstlisting}
    Pou≈æijeme du√°lnu vetu
    du√°lnu k \emph{sup\_eq\_right}.
\begin{lstlisting}
@[simp] theorem inf_eq_left : a ‚äì b = a ‚Üî a ‚â§ b
\end{lstlisting}
    a vyu≈æijeme opaƒçn√© predpoklady k predch√°dzaj√∫cim $h2, h4$.
\begin{lstlisting}
{
    rw ‚Üê modular_lattice.modular_law,
    exact inf_eq_left.mpr h4,
    exact h2
}
\end{lstlisting}

Po dok√°zan√≠ druh√©ho cieƒæa sme dok√°zali cel√∫ vetu. $\square$

\begin{thebibliography}{xx}
    \bibitem{Mimram} Samuel Mimram, Program = Proof, Indenpendently published(July 3, 2020), ISBN-13: 979-8615591839
    \bibitem{SorensenUrzyczyn} Morten Heine B. S√∏rensen, Pawel Urzyczyn, Lectures on the Curry-Howard Isomorphism,
        Elsevier Science (April 4, 2013),  ISBN-13 : 978-0444545961
    \bibitem{lean3} https://github.com/leanprover/lean
    \bibitem{lean4} https://github.com/leanprover/lean4
    \bibitem{mathlib} https://github.com/leanprover-community/mathlib
    \bibitem{mathlib_paper} https://leanprover-community.github.io/papers/mathlib-paper.pdf
\end{thebibliography}

Slovicka na ktore nepoznam preklad a ne
\begin{itemize}
    \item kalkul alebob kalkulus
    \item namespace - niƒç lep≈°ie ma nenapad√° ako menn√Ω priestor
    \item universe - univerzum
\end{itemize}

\end{document}

\begin{verbatim}
    structure point :=
      ( x : nat )
      ( y : nat )

    /-- alternative notation -/
    structure point_alternative :=
      mk :: (x : nat) (Y : nat)

    def p1 : point :=
    {
      x   := 10,
      y   := 20,
    }

    /- same point, different notation, same notation for ordered seti -/
    def p2 : point := $\langle 10, 20 \rangle$

    /- instance only one part of structure, rest implicitly from other instance
    def p3 : point := {
        x := 20,
        ..p
    }
\end{verbatim}

% sposob ukladania kodu

\subsubsection{Type classes}

