\documentclass[a4paper,10pt,oneside]{report}%pridat twoside, do [] pre obojstrannu tlac
\pagestyle{headings}
\usepackage[top=2.5cm, bottom=2.5cm, left=3.5cm, right=2cm]{geometry} %odporucane okraje
\linespread{1.50}

%% Generally used
\usepackage{ebproof}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb, upgreek}
\usepackage{mathtools}
\usepackage{color}
\usepackage[T1]{fontenc}
%% Generally used

%% Lean specific
\usepackage[utf8x]{inputenc}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{errorcolor}{rgb}{1, 0, 0}           % bright red
\definecolor{stringcolor}{rgb}{0.5, 0.3, 0.2}    % brown
\usepackage{pict2e,picture}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}
%% Lean specific

%% Covering

\newcommand{\coveringA}{%
  \mathrel{-\mkern-4mu}<%
}
\newcommand{\coveringB}{\mathrel{\text{$\vcenter{\hbox{\pictcoveringB}}$}}}

\newcommand{\pictcoveringB}{%
  \begin{picture}(1em,.5em)
  \roundcap
  \put(0,.25em){\line(1,0){.6em}}
  \put(.6em,.25em){\line(3,1){.4em}}
  \put(.6em,.25em){\line(3,-1){.4em}}
  \end{picture}%
}
%% Covering

%% Powerset
\newcommand{\powerset}{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}
%% Powerset
\newcommand{\nothing}{\varnothing}

\newtheorem{theorem}{Theorem}


\author{Mat\'u\v{s} Behun}
\title{Lattice theory notes}

\begin{document}

\tableofcontents

\section{√övod}

%Pri procese roz≈°irovania matematickej te√≥rie vytv√°rame tvrdenia generalizuj√∫ce jej princ√≠py.
%Ak chceme aby n√°≈°a te√≥ria bola spr√°vna, v≈°etky jej tvrdenia musia by≈• logicky odvoden√© z postul√°tov alebo tvrden√≠ z nich odvoden√Ωch.
%Potvrdenie spr√°vnosti tvrdenia, vysloven√≠m predpokladu, axi√≥mu alebo nap√≠san√≠m formule ktor√∫ dostaneme aplik√°ciou dedukƒçn√©ho pravidla na niektor√© v postupnosti predch√°dzaj√∫ce formule naz√Ωvame d√¥kazom.

%% Je to pravda?
%Z kvalitat√≠vneho hƒæadiska pri vysloven√≠ d√¥kazu uva≈æujeme o v≈°eobecnosti d√¥kazu a spr√°vnosti aplik√°cie dedukƒçn√©ho pravidla.
%% Je to vhodn√Ω pr√≠klad(chcel som uviest priklad na prvy pohlad spravneho tvrdenia ktore bolo dokazane ako nespravne ? Ako spr√°vne citova≈•? N√°pad som mal odtiaƒæto https://en.wikipedia.org/wiki/List_of_disproved_mathematical_ideas
%O nutnosti korektn√©ho dokazovania tvrden√≠ hovor√≠ napr√≠klad tvrdenie z te√≥rie ƒç√≠sel o hornom ohraniƒçen√≠ poƒçtu prvoƒç√≠sel logaritmick√Ωm integr√°lom.

%\begin{equation}
    %\pi(x) \leq \int_{0}^{x} \frac{1}{ \ln{t} } dt
%\end{equation}

%Tvrdenie bolo pova≈æovan√© za spr√°vne Bernhardom Riemannom a evidencia to taktie≈æ naznaƒçovala.
%Nesk√¥r sa uk√°zalo ≈æe tvrdenie nie je spr√°vne pri ƒç√≠sle pod hodnotou $10^{317}$.
%% Doplni≈• rok
%Veta o 4 farb√°ch ktor√° bola vysloven√° v roku 1852 Francisom Guthrie ktor√° hovor√≠, ≈æe ka≈æd√° rovinn√° mapa je zafarbiteƒæn√° 4 farbami.
%% 18-faces
%T√°to veta bola nespr√°vne dok√°zan√° v roku Kempom (1879) and Taitom (1880). Kempov d√¥kaz bol vyvr√°ten√Ω o 10 rokov mapov s 18 stenami.
%% Je lep≈°ie sklo≈àova≈• cudzie men√°?
%Pri d√¥kaze tejto vety bol nesk√¥r v roku 1977 Appelom and Hakenom z ƒçasti vyu≈æit√Ω poƒç√≠taƒç pre kontrolu ≈°peci√°lnych diskr√©tnych pr√≠padov.

\chapter{Curry-Howardov izomorfizmus}
\section{Formalizovanie d√¥kazu}
\section{Intuicionistick√° logika}
    Kon≈°truktivizmus je jeden z filozofick√Ωch smerov ktor√Ω hovor√≠ o tom ≈æe vedmosti
s√∫ tvoren√© a mali by by≈• zahrnut√© k doteraz poznan√©mu.
    Tento filozofick√Ω smer mal vplyv aj na matematiku kde sa na jeho z√°klade
vytvorilo viacero "≈°k√¥l" ako finitizmus, predikativizmus, intuicionizmus.
    \emph{Intuitionizmus} ako jeden z nich je teda kon≈°trukt√≠vny pr√≠stup k matematike
v duchu Brouwera(1881-1966) a Heytinga(1898-1980).
    % toto tu je z tej matematickej logiky
    Filozofick√Ωm z√°kladom tohto pr√≠stupu je princ√≠p ≈æe matematika je v√Ωtvorom ment√°lnej
ƒçinnosti a nepozost√°va z v√Ωsledkov form√°lnej manipul√°cie symbolov ktor√© s√∫ iba
sekund√°rne.
    Jedn√Ωm z princ√≠pov je tak odmietnutie postul√°tu z√°kona vyl√∫ƒçenia tretieho
z klasickej logiky.
\begin{equation}
    p \vee \neg p
\end{equation}
    V pr√≠pade d√¥kazu sporom nad v√Ωrokom $p$ je mo≈æn√© dok√°za≈• existenciu $p$,
ƒço je z kon≈°trukt√≠vneho pohƒæadu nezmysel preto≈æe uva≈æujeme nad pravdivos≈•ou
    v√Ωroku nez√°visle od uva≈æovan√©ho tvrdenia.
V√Ωrok v intuicionistickej logike je teda pravdiv√Ω ak existuje d√¥kaz o jeho pravidovsti
a nepravdiv√Ω ak existuje d√¥kaz ktor√Ω vedie k sporu.
    % a toto je zo sochora
    V logike definujeme d√¥kaz ako z nejak√Ωch predpokladov ako koneƒçn√∫ postupnos≈•
form√∫l, pri ktor√Ωch tvorbe m√¥≈æeme v ka≈ædrom kroku spravi≈• jeden z nasleduj√∫cich
√∫konov:
\begin{itemize}
    \item Nap√≠sa≈• postul√°t alebo axi√≥m logiky
    \item Nap√≠sa≈• jeden z predpokladov
    \item Nap√≠sa≈• formulu, ktor√∫ dostaneme aplik√°ciou dedukƒçn√©ho pravidla na niektorej
formuly predch√°dzaj√∫cej v postupnosti.
\end{itemize}
    V≈°etky tieto kroky si postupne zavedieme aj s dedukƒçn√Ωmi pravidlami.
    Pre lep≈°ie pochopenie pojmu formuly a premennej uv√°dzame ich nasleduj√∫cu defin√≠ciu:
    % vyrok, premenna ~ vyrokova premenna
\begin{theorem}[V√Ωrokov√° premenn√°, formula]
    Majme spoƒç√≠tateƒæn√∫ mno≈æinu $\mathcal{X}$ v√Ωrokov√Ωch premenn√Ωch. Mno≈æina premenn√Ωch
    alebo form√∫l $\mathcal{A}$ generujeme nasledovnou gramatikou:
    \begin{equation}
        A, B ::= X | A \implies B | A \wedge B | A \vee B | \neg A | \top | \bot
    \end{equation}
    Kde $X \in \mathcal{X}$ reprezentuje v√Ωrokov√∫ premenn√∫, a $A, B \in \mathcal{A}$
    v√Ωrok.
\end{theorem}
    Formulu ktor√∫ tvor√≠ len v√Ωrokov√° premenn√° naz√Ωvame atomickou.
    U≈æ v √∫vode tohto textu sme hovorili o postul√°te alebo axi√≥me z√°kone v√Ωluƒçenia
tretieho ktor√Ω je formulou.
    ƒéal≈°√≠mi pr√≠kladom formuly generovanej uvedenou gramatikou je:
\begin{align*}
    \neg A \wedge B \wedge C &\implies A \vee B \\
\end{align*}
    V pr√≠pade ≈æe by sme chceli predch√°dzaj√∫cu formulu ohodnoti≈• je precendencia
neg√°cie vy≈°≈°ia ako konjukcie a disjunkcie a tie ju maj√∫ vy≈°≈°iu ako implik√°cia.
V pr√≠pade formuly obsahuj√∫cej viac za id√∫cich bin√°rnych oper√°torov plat√≠ asoci√°cia
zprava.
    V pr√≠pade ≈æe chceme uvies≈• jeden z predpokladov do d√¥kazu vyber√°me z mno≈æiny
ktor√∫ naz√Ωvame kontextom.
\begin{theorem}
    Kontextom(syst√©m predpokladov) rozumieme zoznam v√Ωrokov znaƒçen√Ωch
    \begin{equation}
        \Gamma = P_{1}, \dots , P_{n}
    \end{equation}
    Dedukciou naz√Ωvame dvojicu pozost√°vaj√∫cu z kontextu a v√Ωroku.
    \begin{equation}
        \Gamma \vdash A
    \end{equation}
\end{theorem}
    V√Ωraz $\Gamma \vdash A$ ƒç√≠tame ako premenn√∫ $A$ je mo≈æn√© dok√°za≈• zo syst√©mu 
predpokladov $\Gamma$.
    Nad uveden√Ωmi predpokladmi a postul√°tmi potom pomocou dekuƒçn√Ωch pravidiel prirodzenej
intucionistickej logiky potom odv√°dzame nov√© formuly a roz≈°irujeme tak te√≥riu.
    Zau≈æ√≠vanou not√°ciou pre dedukƒçn√© pravidl√° je nasledovn√°:
    \begin{equation}
        \begin{prooftree}
            \hypo{\Gamma_{1} \vdash A_{1}}
            \hypo{\dots}
            \hypo{\Gamma_{n} \vdash A_{n}}
            \infer3[]{\Gamma \vdash A}
        \end{prooftree}
    \end{equation}
    Horn√∫ ƒças≈• tvor√≠ mno≈æinu dedukci√≠ $\Gamma_{i}$ ktor√© naz√Ωvame prepokladom a
dolnej $\Gamma$ ktor√∫ naz√Ωvame z√°verom.
    V pr√≠pade ≈æe ƒç√≠tame dedkuƒçn√© pravidlo alebo dedkuƒçn√Ω strom tvoren√Ω tak√Ωmito
pravidlami zhora nadol hovor√≠me o dedukcii v opaƒçnom smere o indukcii.
    Prirodzen√° intucionistick√° logika obsahuje nasleduj√∫ce pravidl√°:
\begin{center}
    \begin{prooftree}
        \infer0[(ax)]{\Gamma,A,\Gamma' \vdash A}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \implies B}
        \hypo{\Gamma \vdash A}
        \infer2[$(\implies_{E})$]{\Gamma \vdash B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$\implies_{I}$]{\Gamma \vdash B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{l}_{E})$]{\Gamma \vdash A}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{r}_{E})$]{\Gamma \vdash B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \hypo{\Gamma \vdash B}
        \infer2[$(\wedge_{I})$]{\Gamma \vdash A \wedge B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \vee B}
        \hypo{\Gamma, A \vdash C}
        \hypo{\Gamma, B \vdash C}
        \infer3[$(\vee_{E})$]{\Gamma \vdash C}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash B}
        \infer1[$(\vee_{I}^{r})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \infer1[$(\vee_{I}^{l})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash \neg A}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{E})$]{\Gamma \vdash \bot}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash \bot}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{I})$]{\Gamma \vdash \neg A}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{center}
    \begin{prooftree}
        \hypo{\Gamma \vdash \bot}
        \infer1[$(\bot_{E})$]{\Gamma \vdash A}
    \end{prooftree}
\end{center}
    Z√°verom pravidiel s doln√Ωm indexom $E$ maj√∫ v z√°vere v√Ωrokov√© premenn√©.
    Pravidl√° s doln√Ωm indexom $I$ √∫vadzaj√∫ neatomick√© formuly.
    Pravidlo $\implies_{E}$ je zn√°me ako \emph{modus ponens}.
    Fragmentom logiky naz√Ωvame, syst√©m ktor√Ω dostaneme ak sa obmedz√≠me len na niektor√©
z dedkuƒçn√Ωch pravidiel.
    My uvedieme implikaƒçn√Ω fragment ktor√Ω je potom pou≈æit√Ω v Curry-Howardovom
izomorfizme.
\begin{theorem}
    Implikaƒçn√Ωm fragmentom intuionistickej logiky dostaneme v pr√≠pade ak formuly
        bud√∫ tvoren√© gramatikou
    \begin{equation}
        A,B ::= X | A \implies B
    \end{equation}
    a pravidlami (ax), ($\implies_{E}$), ($\implies_{I}$)
\end{theorem}
    Aj keƒè tento fragment tvor√≠ len jedna formula a v√Ωrokov√© premenn√© je mo≈æn√©
pomocou nich odvodi≈• logicky ekvivalentn√© formuly tvoren√© gramatikou uvedenou na
zaƒçiatku.

% TODO spravit priklad
% (ùê¥‚àßùêµ)‚Üí((ùê¥‚Üíùê∂)‚Üí¬¨(ùêµ‚Üí¬¨ùê∂))

\section{$\lambda$-kalkulus}
    $\lambda$-kalkulus je v√Ωpoƒçtov√Ω model ktor√Ω sa v informatike vyu≈æ√≠va pre svoju
jednoduchos≈• a vypoƒçtov√∫ schopnos≈•.
    Napriek tomu ≈æe form√°lne tento model tvoria len tri v√Ωrazy je jeho v√Ωpoƒçtov√°
schopnos≈• rovn√° \emph{Turingovmu stroju}.
    To znamen√° ≈æe v ≈àom dok√°≈æeme naprogramova≈• v≈°etky algoritmy ktor√© dok√°≈æe
spracova≈• klasick√Ω poƒç√≠taƒç.
    Pre tieto vlastnosti je vyu≈æ√≠van√Ω aj ako z√°klad pre v≈°etky funkcion√°lne programovacie
jazyky.
    V tejto sekcii si ho form√°lne uvedieme aj s pr√≠kladmi ktor√© ukazuj√∫ ako je
v ≈àom mo≈æn√© zak√≥dova≈• jednoduch√© algoritmy.

\begin{theorem}
    Mno≈æinu $\Lambda$ tvoren√∫ $\lambda$-v√Ωrazmi je potom generovan√° nasledovnou gramatikou:
    \begin{equation}
        t, u ::= x | t u | \lambda x.t
    \end{equation}
    Kde prv√Ω v√Ωraz $x$ patr√≠ do nekoneƒçnej spoƒç√≠tateƒænej mno≈æiny $\mathcal{X}={x,y,z,\dots}$
premenn√Ωch.
\end{theorem}
    Jednotliv√© v√Ωrazy maj√∫ nasledovn√Ω v√Ωznam:
\begin{align*}
     x          & \textrm{ - je premennou }\\
     t u        & \textrm{ - je aplik√°ciou v√Ωrazu $t$ s argumentom $u$ }\\
    \lambda x.t & \textrm{ - je abstrakciou $t$ nad $x$ }
\end{align*}
    Premenn√° $x$ sa vo v√Ωraze $\lambda x . t$ via≈æe na term√≠n $t$. O premennej
$x$ hovor√≠me ≈æe je viazan√° inak je voƒæn√°.

\begin{center}
    \begin{align*}
        VP(x) &= {x} \\
        VP(\lambda x.t) &= VP(t)  \setminus \{x\} \\
        VP(t v) &= VP(t) \cup VP(v)
    \end{align*}
\end{center}
    Aplik√°cia $\lambda$-v√Ωrazov je implicitne aplikovan√° zƒæava.
    Precedencia aplik√°cie je vy≈°≈°ia ako u abstrakcie.
\begin{equation*}
    \lambda x . t x = \lambda x . (t x)
\end{equation*}
    Abstrakciu viacer√Ωch argumentov je mo≈æn√© prep√≠sa≈• do tvaru po sebe id√∫cich
abstrakci√≠ s jednotliv√Ωmi argumentami.
\begin{equation*}
    \lambda x y z . t = \lambda x . \lambda y . \lambda z . t
\end{equation*}
    Pr√≠kladmi $\lambda$-v√Ωrazov m√¥≈æu by≈•:
\begin{align*}
    & t x                             \\
    & (\lambda y . \lambda x . t y )) \\
    & (\lambda y.y x) (\lambda x . x) \\
\end{align*}
    %Premenovan√≠m naz√Ωvame nahradenie voƒæn√Ωch premenn√Ωch vo v√Ωraze.
    %\begin{equation*}
        %t \{ y / x \}
    %\end{equation*}
    %Kde vo v√Ωraze $t$ je premenovan√° premenn√° $x$ za $y$.

    \begin{theorem}
        O substut√≠cii hovor√≠me pri nahraden√≠ jednej premenej druhou.
        \begin{equation}
            t [ y / x ]
        \end{equation}
    \end{theorem}
    %Nahradenie je silnej≈°ie ako premenovanie preto≈æe dok√°≈æe nahradi≈• aj premmenn√©
%viazann√© abstrakciou.
    %Tento rozdiel prezentujeme aj na nasleduj√∫com pr√≠klade:
    %\begin{align*}
        %(\lambda x . t ) \{ u / x \} &= \lambda x . t\\
        %(\lambda x . t ) [ u / x ]   &= \lambda x . (t [ u / x ] )
    %\end{align*}

    Z doteraz uveden√Ωch v√Ωrazov n√°m v√Ωpoƒçet ƒçiastoƒçne pripom√≠nala len aplik√°cia na
jednoduch√Ω v√Ωraz.
    Ak za v√Ωraz dosad√≠me jednoduch√∫ abstrakciu, aplik√°ciu tvor√≠ nahradenie
viazanej premmenej vo v√Ωraze abstrakcie za aplikovan√∫ premenn√∫.
    Tento √∫kon n√°m zjednodu≈°uje v√Ωraz na jednoduch√∫ aplik√°ciu.
    Toto zjednodu≈°ovanie sa vol√° $\beta$-redukciou.
    Od komplikovanej≈°√≠ch v√Ωrazov sa tak dost√°vame k jednoduch≈°√≠m predstavuj√∫cimi
v√Ωsledky v√Ωpoƒçtu.
    $\beta$-redukcia predstavuje postupnos≈• v ktorej aplikujeme pravidl√°
aplik√°cii.
    Form√°lne je $\beta$-redukcia definovan√° aplikovan√Ωm t√Ωchto pravidiel.
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda x.t)u \to_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{\lambda}$)]{(\lambda x.t)u \rightarrow_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{l}$)]{t u \rightarrow_{\beta} t' u}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{u \to_{\beta} u'}
        \infer1[($\beta_{r}$)]{t u \rightarrow_{\beta} t u'}
    \end{prooftree}
\end{minipage}
\vskip 0.2in


% TODO vymysliet iny strom, tento je prevzaty
TU TREBA VYMYSLIET INY STROM
\begin{equation}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda y.y)x \to_{\beta} x}
        \infer1[($\beta_{l}$)]{(\lambda y.y)xz \to_{\beta} xz}
        \infer1[($\beta_{\alpha}$)]{\lambda x.(\lambda y.y)xz \to_{\beta} \lambda x . xz}
    \end{prooftree}
\end{equation}
    Pre lep≈°iu predstavu uv√°dzame komplikovanej≈°ie pr√≠klady ktor√Ωmi je mo≈æn√©
z√°kodova≈• prirodzen√© ƒç√≠sla a jednoduch√∫ podmienku z programovania.
\begin{theorem}
    Definujme rekurziu volania funkcie nasledovne
    \begin{align*}
        f^{0}x &= x \\
        f^{n}x &= f(f^{n-1}x) \\
    \end{align*}
    Potom Churchove ƒç√≠slo $c_{n}$ je $\lambda$-term√≠n
    \begin{equation*}
        c_{n} = \lambda s . \lambda z . s^{n} (z)
    \end{equation*}
\end{theorem}
    Prirodzen√© ƒç√≠sla je potom mo≈æn√© definova≈•
\begin{align*}
    0 &= \lambda f x . x \\
    1 &= \lambda f x . f x \\
    1 &= \lambda f x . f (f x) \\
    2 &= \lambda f x . f ( f (f x))
\end{align*}
\begin{align*}
    nasledovnik(n) &=           (\lambda n f x .  f( n f x ))(\lambda f x . f^{n} x) \\
                   &\to_{\beta} \lambda f x . f (( \lambda f x . f^{n} x ) f x)      \\
                   &\to_{\beta} \lambda f x . f (( \lambda x . f^{n} x) x)           \\
                   &\to_{\beta} \lambda f x . f (f^{n} x)                            \\
                   &=           \lambda f x . f^{n+1} x                              \\
                   &= n + 1
\end{align*}
    Oper√°ciu sƒç√≠tania je potom mo≈æn√© definova≈• vykona≈•
\begin{equation*}
    f_{+} = \lambda x. \lambda y. \lambda s. \lambda z. x s (y s z)
\end{equation*}
    Pred vytvoren√≠m v√Ωrazu ktor√Ω predstavuje podmienku si potrebujeme z√°kodova≈•
booleovsk√© hodnoty:
    \begin{align*}
        True &= \lambda x y . x \\
        False &= \lambda x y . y
    \end{align*}
    Podmienku potom predstavuje nasleduj√∫ci v√Ωraz, na ktor√Ω potom aplikujeme $\lambda$-v√Ωraz
predstavuj√∫ci logick√∫ podmienku.
\begin{align*}
    if = \lambda b x y . b x y
\end{align*}
    Jednotliv√© vetvy v√Ωpoƒçtu potom predsatvuj√∫ ƒèal≈°ie dva v√Ωrazy aplikovan√© na cel√Ω
v√Ωraz podmienky a v√Ωrazu.
    Po aplik√°cii v√Ωrazov $t,u$ cez $\beta$-redukcie dost√°vame na konci v√Ωraz $t$
v pr√≠pade pravdiv√©ho vyhodnotenia a $u$ respekt√≠ve $t$ v pr√≠pade nepravdiv√©ho.

\begin{align*}
    if \textrm{ True } t u = (\lambda bxy.bxy)(\lambda xy.x) t u & \to_{\beta} (\lambda xy.(\lambda xy.x)xy)tu \\
                                                     & \to_{\beta} (\lambda y.( \lambda xy.x)ty)u \\
                                                     & \to_{\beta} (\lambda xy.x)tu \\
                                                     & \to_{\beta} (\lambda y.t)u \\
                                                     & \to_{\beta} t
\end{align*}

\section{Typovo jednoduch√Ω $\lambda$-calculus}
    Typov√Ω jednoduch√Ω $\lambda$-kalkulus je roz≈°√≠ren√≠m o jednoduch√© typy ktor√©
priradzujeme $\lambda$-v√Ωrazom.
    V√Ωraz $t : T$ tak m√¥≈æeme interpretova≈• sp√¥sobom "$t$ patr√≠ mno≈æine $T$" alebo
z v√Ωpoƒçtov√©ho "v√Ωsledkom v√Ωrazu $t$ je typ $T$". Z praktick√©ho hƒæadiska sa s typmi
stret√°vame v statiscky typov√Ωch programovac√≠ch jazykoch kde n√°m zaruƒçuj√∫ ≈æe typovo
spr√°vny v√Ωsledok.
\begin{theorem}
    Majme spoƒç√≠tateƒæn√∫ mno≈æinu $U$ obsahuj√∫cu typov√© premenn√©. Jednoduch√© typy
    s√∫ potom generovan√© gramatikou
    \begin{equation*}
        A,B ::= U | (A \to B)
    \end{equation*}
\end{theorem}
    Teda okrem jednoduchn√Ωch typov s√∫ typmi aj funkcie medzi nimi.
Precedencia zlo≈æenia funkci√≠ typov je zƒæava $A \to ( A  \to B )$. Mno≈æinu
tvoriacu premenn√© ktor√Ωm s√∫ priraden√© typy naz√Ωvame kontextom.
\begin{theorem}
    Kontextom je:
    \begin{equation*}
        { x_{1} : \tau_{1}, \dots, x_{n} : \tau_{n} }
    \end{equation*}
    kde $\tau_{1}, \dots, \tau_{n} \in \Pi$ a $x_{1}, \dots , x_{n} \in$
    Koobor kontextu je mno≈æina obsahuj√∫ca
    \begin{equation*}
        domain(\Gamma) = { x_{1}, \dots, x_{n} }
    \end{equation*}
    Oboor kontextu je mno≈æina obsahuj√∫ca
    \begin{equation*}
        range( \Gamma ) = { \tau \in \Pi  | (x : \tau ) \in \Gamma }
    \end{equation*}
\end{theorem}
Pr√≠kladmi jednoduch√Ωch typov generovan√© gramatikou.
\begin{itemize}
    \item $\vdash \lambda x.x : \sigma \to \sigma$
    \item $\vdash \lambda x. \lambda y.x : \sigma \to \tau \to \sigma$
    \item $\vdash \lambda x. \lambda y. \lambda z.x z (y z): (\sigma \to \tau \to \rho) \to (\rho \to \tau) \to \sigma \to \rho$
\end{itemize}

V√Ωraz $t$ je typu $A$ ak v kontexte $\Gamma$ existuje postupnos≈• pravidiel postupnos≈• derivovateƒæn√° pomocou pravidiel:

\begin{center}
    \begin{prooftree}
        \infer0[ax]{\Gamma \vdash x : \Gamma(x)}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma , x : A \vdash t : B }
        \infer1[$\overset{I}{\rightarrow}$]{\Gamma \lambda x^{A}.t : A \to B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash t : A \to B }
        \hypo{\Gamma \vdash u : A }
        \infer2[$\overset{E}{\rightarrow}$]{\Gamma \vdash t u : B}
    \end{prooftree}
\end{minipage}

\begin{itemize}
    \item ax: v kontexte $x$ je typu $A$
    \item $\overset{I}{\rightarrow}$: ak je $x$ typu $A$, $t$ je typu B, potom
        funkcia $\lambda x.t$ ktor√° asociuje $x$ $t$ je typu $A \to B$
    \item $\overset{E}{\rightarrow}$: dan√° je funkcia $t$ je typu $A \to B$
        a argument $u$ je typu $A$, vysledok aplik√°cia $t u$ je typu $B$
\end{itemize}

Pr√≠klad odvodenia typu.

\section{Curry-Howardov izomorfizmus}

    V √∫vode kapitoly sme popisovali kon≈°truktivistick√Ω pr√≠stup ktor√Ω hovoril
o nutnosti skon≈°truova≈• objekt pre jeho d√¥kaz.
    Teda ak chceme dok√°za≈• nejak√© tvrdenie potom ho mus√≠me zostroji≈• z mno≈æiny
predpokladov a axi√≥m.
    \emph{Curry-Howard} si v≈°imli ≈æe zostrojovanie d√¥kazu pripom√≠na v√Ωpoƒçet.
    Pre d√¥kaz implik√°cie $a implies b$ mus√≠me uk√°za≈• na z√°klade predpokladu $a$
d√¥sledok $b$ v kon≈°truktivizme zostroji≈• objekt $b$ z objektu $a$ a
z v√Ωpoƒçtov√©ho hƒæadiska zostroji≈• funkciu s v√Ωstupom $b$ na z√°klade vstupu $a$.

    Pri predstaven√≠ jednoduch√Ωch typov sme vraveli o mo≈ænosti interpret√°cie v√Ωrazu
$t : T$ ako $t$ patr√≠ do nejakej mno≈æiny $T$.
    Z kon≈°trukt√≠vneho pohƒæadu sme o logick√Ωch tvrdeniach hovorili ako o objektoch
ktor√© maj√∫ svoje vymedzenie z logick√©ho hƒæadiska.
    V tomto zmysle z mno≈æinov√©ho hƒæadiska prepojenie medzi typov√Ωm $\lambda$-kalkulom
a logikou prepojenie zn√°zornen√© v nasleduj√∫cej tabuƒæke.
\begin{center}
    \begin{tabular}{ c c }
        Logika &                Typovo jednoduch√Ω $\lambda$ kalkulus \\
        \hline
        tvrdenia                & typy \\
        d√¥kaz tvrdenia $T$      & $\lambda$-v√Ωraz $t$ typu $T$ \\
        $T \implies P$          & typ $T \to P$ \\
        $T \wedge P$            & typ $T \times P$
    \end{tabular}
\end{center}
    Posledn√Ω pr√≠klad tvor√≠ kos√∫ƒçinov√Ω typ ktor√Ω je usporiadanou dvojicou dvoch typov
ktor√Ω je aj priamo podporovan√Ω Lean-om.
    V sekcii o intuicionistickej logike sme zaviedli gramatiku implikaƒçn√©ho fragmetnu
intucionistickej logiky s troma dedkuƒçn√Ωmi pravidlami $(\implies_{E})$,
    $(\implies_{I})$, $(ax)$.
    V te√≥rii jednoduch√Ωch typov sme zase ukonƒçili pravidlami ktor√© odv√°dzaj√∫
typ pomocou pravidiel $(\overset{I}{\rightarrow})$, $(\overset{E}{\rightarrow})$.



    Pre √∫plnos≈• dod√°vame aj form√°lnu defin√≠ciu:

\begin{theorem}{Curry-Howard isomorphism}
    \begin{itemize}
        \item If $\Gamma \vdash M : \varphi \textrm{ potom } |\Gamma|  \vdash \varphi.$
        \item If $\Gamma \vdash \varphi \textrm{ potom existuje } M \in \Lambda_{\Pi}
            \textrm{ tak√© ≈æe } \Delta \vdash M : \varphi, \textrm{ kde }
            \Delta = { ( x_{\varphi} : \varphi ) | \varphi \in \Gamma }$
    \end{itemize}
\end{theorem}

    

\chapter{Lean dokazovac√≠ asistent}
    Lean je dokazovac√≠ asistent ktor√Ω bol vytvoren√Ω otvoren√Ω softv√©rov√Ω projekt
Leonardom de Mourom v Microsoft Reasearch v roku 2013.
    Jazyk sa neust√°le vyv√Ωja a moment√°lne sa nach√°dza vo ≈°tvrtej iter√°cii \cite{lean4} zatiaƒæ ƒço komunitn√Ω projekt matematickej kni≈ænice mathlib sa st√°le vyv√≠ja v tretej verzii\cite{lean3} vyv√Ωjanej od roku 2017.
    Implement√°cia Lean-u je v jazyku C++ a jeho jadro m√° 8000 riadkov.
    Prostredie je dostupn√© pre operaƒçn√© syst√©my Linux, Windows a Darwin.
    Interakt√≠vne prostredie pre dokazovanie je podporovan√© pre editory \emph{Emacs} a \emph{Visual Studio Code}.

    Lean podobne ako \emph{Coq} je zalo≈æen√© na kalkule kon≈°trukci√≠ ktor√Ω je zov≈°eobecnen√≠m te√≥rie jednoduch√Ωch typov
    a te√≥rii z√°vislostn√Ωch typov.
\section{Mathlib}
    % zdruzovat mozem vcelarov
    Mathlib je komunitn√Ω projekt\cite{mathlib} ktor√©ho cieƒæom je zdru≈æova≈• matematick√∫
te√≥riu implementovan√∫ v Lean-e.
    Do projektu je mo≈æn√© jednoducho prispieva≈• po udelen√≠ privil√©gi√≠ niektor√Ωm zo
spr√°vcov repozit√°ra a odobren√≠m po≈æiadavky na zaƒçlenenie k√≥du.
    V√§ƒç≈°ina obsahu mathlibu obsahuje matematiku na vysoko≈°kolskej √∫rovni.
    V dobre p√≠sania pr√°ce je najvy≈°≈°ia hierarchia te√≥rie nasledovn√°:
\begin{lstlisting}
algebra/
category_theory/
data/
geometry/
measure_theory/
probability_theory/
algebraic_geometry/
combinatorics/
group_theory/
representation_theory/
algebraic_topology/
computability/
dynamics/
linear_algebra/
number_theory/
ring_theory/
analysis/
control/
field_theory/
logic/
order/
set_theory/
topology/
\end{lstlisting}
    V kontraste s in√Ωmi modern√Ωmi dokazovac√≠mi asistentami m√° mathlib mno≈æstvo
prispievateƒæov akademick√© vzdelanie v ƒçistej matematike\cite{mathlib_paper} ƒço
ovplyvnilo aj jeho obsah.

\section{V√Ωvojov√© prostredie}
    V na≈°om pr√≠pade sme pracovali vo v√Ωvojovom prostred√≠ \emph{Visual studio code}
v kombin√°ci√≠ s jeho leanovsk√Ωm roz≈°√≠ren√≠m ktor√© je mo≈æn√© nain≈°talova≈• cez
\emph{marketplace} Prostredie sa sklad√° z editora podporuj√∫ce UTF-8 znaky a okno s
interakt√≠vny v√Ωstupom reaguj√∫ce na polohu kurzora editora a kurzora poƒç√≠taƒçovej
my≈°i.
\begin{center}
    \begin{figure}[!ht]
        \centering
        \includegraphics[scale=0.25]{vscode_printscreen.png}
        \caption{V√Ωvojov√© prostredie}
    \end{figure}
\end{center}
    V pravom okne \emph{Lean infoview} je mo≈æn√© vidie≈• premenn√© s ich prisl√∫chaj√∫cimi
typmi a v pr√≠pade d√¥kazu aj formulu ktor√∫ je potrebn√© dok√°za≈• za znakom $\vdash$.
    Okrem toho poskytuje okno aj v√Ωstup zo zabudovan√Ωch pr√≠kazov prostredia
ako \emph{print} alebo \emph{reduce} ktor√© rozoberieme nesk√¥r.
    V pr√≠pade ≈æe sa nach√°dzame v taktickom m√≥de okrem zavedenia nov√Ωch predpokladov
alebo transorm√°cie existuj√∫cich je mo≈æn√© vidie≈• aj zmenu cieƒæa a podcieƒæov
napr√≠klad v pr√≠pade ≈æe sme sa dostali k d√¥kazu vymenovan√≠m pr√≠padov.
\section{Lambda kalkulus}
Pred predstaven√≠m techn√≠k dokazovania je nutn√© sa obozn√°mi≈• s prvkami funkcionion√°lneho
    programovania v Leane.
V√Ωpoƒçtov√Ω model jednoduch√©ho $\lambda$-kalkulu je z programovac√≠ch paradigiem najbli≈æ≈°ie
pr√°ve funkcion√°lnemu sp√¥sobu programovania.
V nasleduj√∫cej ƒçasti predstavujeme z√°klady funkcion√°lneho programovania spolu
    s typmi a n√°strojmi Lean-u na v√Ωvoj a mene≈æment priestor mien.
\subsection{Kon≈°tanty, aplik√°cie}
    Deklar√°cia kon≈°tanty zav√°dza do syst√©mu nov√∫ deklar√°ciu bez defin√≠cie.
    Z tohto d√¥vodu sa ich pri rozvoji te√≥rie sna≈æ√≠me vyh√Ωba≈•.
    V nasleduj√∫cich pr√≠kladov budeme pracova≈• s prirodzen√Ωmi a cel√Ωmi ƒç√≠slami
ktor√Ωch ≈°trukt√∫ry s√∫ s√∫ƒças≈•ou kontextu bez nutnosti ich importova≈•.
\begin{lstlisting}
constant m : nat
\end{lstlisting}
    Hovor√≠ o deklarovan√≠ kon≈°tanty $m$ ktorej typ je \emph{nat}.
    Alternat√≠vny z√°pis pre prirodzen√© ƒç√≠slo je pomocou sekvencie \emph{\textbackslash nat}
alebo \emph{\textbackslash N} ktor√∫ skonvertuje leanovsk√© roz≈°√≠renie na znak $\mathbb{N}$.
    Vstavan√Ω pr√≠kaz ktor√Ω poskytuje typ v√Ωrazu zadan√©ho na argumente je \emph{\#check}:
\begin{lstlisting}
#check m
\end{lstlisting}
    Mrie≈æka na zaƒçiatku pr√≠kazu znaƒç√≠ zabudovan√Ω pr√≠kaz.
    V tomto pr√≠pade je to trivi√°lne tak ako bola kon≈°tanta zadefinovan√° s v√Ωstupom
v informaƒçnom okne:
\begin{lstlisting}
m : ‚Ñï
\end{lstlisting}
    Pre zadefinovanie viacer√Ωch kon≈°t√°nt jedn√Ωm pr√≠kazom a nie len v tomto pr√≠pade
existuje plur√°rna verzia pr√≠kazu \emph{constants}.

    Defin√≠cia kon≈°tanty typu funkcie medzi prirodzen√Ωmi ƒç√≠slami vyzer√° nasledovne:
\begin{lstlisting}
constant f : ‚Ñï ‚Üí ‚Ñï
constant h : ‚Ñï -> ‚Ñï -> ‚Ñï
\end{lstlisting}
    Aplik√°cia funkcie sa notaƒçne podob√° aplik√°cii v $\lambda$kalkule kde argument
jednoducho prip√≠≈°eme za funkciu:
\begin{lstlisting}
#constants m n : ‚Ñï

#check f m
#check h m
#check h m n
\end{lstlisting}
    Zatiaƒæ ƒço v prvom pr√≠pade dostaneme typ $\mathbb{N}$ v druhom pr√≠pade
$\mathbb{N} \to \mathbb{N}$ a v tre≈•om vid√≠me aplik√°ciu na funkciu kde bude v√Ωsledn√Ωm
typom znova jednoduch√Ω typ $\mathbb{N}$.
    Aplik√°cia je asociat√≠vna z ƒæavej strany a  preto je nasleduj√∫ci v√Ωraz potrebn√© 
oz√°tvorkova≈• napravo inak dost√°vame typov√Ω error pre funkciu $g$ ktor√° oƒçak√°va 
cel√© ƒç√≠slo a nie typ funkcie f.
\begin{lstlisting}
constant f : ‚Ñï ‚Üí ‚Ñ§
constant g : ‚Ñ§ ‚Üí ‚Ñï
constant a : ‚Ñï

#check g (f a)
\end{lstlisting}
    Vo v√Ωchodiskovom pr√≠pade maj√∫ v≈°etky ƒç√≠sla v editore typ $\mathbb{N}$.
\begin{lstlisting}
#check 5
#check (-5 : ‚Ñ§)
\end{lstlisting}
    Pri deklar√°cii z√°porn√©ho ƒç√≠sla je tak nutn√© u≈æ explicitne uvies≈• typ.
Nasleduj√∫ce pr√≠klady ilustruj√∫ okrem funkcie $+$ aj implicitn√∫ konverziu medzi typmi.
\begin{lstlisting}
#constants (m : ‚Ñï) (n : ‚Ñ§)

#check 1 + 2
#check m + 1
#check n + 1
#check n + m
#check m + n
\end{lstlisting}
    V pr√≠pade prv√©ho pr√≠kladu dost√°vame typ $\mathbb{N}$ pre nespracovan√Ω v√Ωraz pre
ktor√Ω by sme mohli oƒçak√°va≈• v√Ωsledok $3$.
    Pre druh√Ω a tret√≠ v√Ωraz dost√°vame respekt√≠vne typy definovan√Ωch kon≈°t√°nt√Ωch
premenn√Ωch.
    Pri tre≈•om v√Ωraze je vhodn√© si uvedomi≈• u≈æ implicitn√∫ konverziu prirodzen√©ho
ƒç√≠sla na cel√©.
    Konverzia je e≈°te viac zrejm√° pri ≈°tvrtom v√Ωraze kde v√Ωsledn√Ωm typom je
$\mathbb{Z}$.
    Prekvapivo z piateho v√Ωrazu dost√°vame v informaƒçnom okne chybov√Ω v√Ωstup.
    Za neschopnos≈•ou dosta≈• typ stoj√≠ nedefinovan√° konverzia z cel√Ωch do prirodzen√Ωch
ƒç√≠sel.
    Za vysvetlen√≠m stoj√≠ sp√¥sob ak√Ωm pracuje pre≈•a≈æenie infixov√©ho oper√°tora $+$
podobn√Ωm sp√¥sobom ako pre triedy v jazyku $c++$ alebo $python$. ≈†tvrt√Ω a piaty
v√Ωraz je tak mo≈æn√© prep√≠sa≈• aj do tvaru:
\begin{lstlisting}
#check n.add(m)
#check m.add(n)
\end{lstlisting}
    Preto≈æe znak $+$ je pre≈•a≈æen√≠m funkcie \emph{add} nad ≈°trukt√∫rou mno≈æiny dan√Ωch
ƒç√≠sel.
\subsection{Abstrakcia}
    V predch√°dzaj√∫cej sekcii sme si uk√°zali explicitn√Ω typ ktor√Ω bol funkciou prirodzen√Ωmi
ƒç√≠slami ktor√Ω bol typu $\mathbb{N} \to \mathbb{N}$ alebo $\mathbb{N} \to \mathbb{N} \to \mathbb{N}$.
    V $\lambda$-kalklule zodpovedaj√∫ funkcie abstrakci√°m. V Lean-e definujeme
anonymn√∫ funkciu alebo $\lambda$-v√Ωraz nasledovne.
\begin{lstlisting}
#check Œª x, x + x
\end{lstlisting}
    Typ argumentu x je odvoden√Ω z v√Ωrazu ktor√Ω na funkciu aplikujeme.
    Pre korektn√∫ aplik√°ciu mus√≠ ma≈• typ aj definovan√∫ funkciu sƒç√≠tania.
    Ak by sme chceli obmedzi≈• argument len na konkr√©tny typ rob√≠me to podobne ako
pri definovan√≠ kon≈°tanty. Potom aplik√°cia
\begin{lstlisting}
#constant (m : ‚Ñ§)

#check (Œª (x : ‚Ñï), x + x) (m : ‚Ñ§)
\end{lstlisting}
je u≈æ typovou chybou pri ktorej n√°m informaƒçn√© okno hl√°si
\begin{lstlisting}
type mismatch at application
  (Œª (x : ‚Ñï), x + x) m
term
  m
has type
  ‚Ñ§
but is expected to have type
  ‚Ñï
\end{lstlisting}
    Uvedieme si zop√°r pr√≠kladov vypoƒçtovo ekvivalentn√Ωch funkcii obvodu obdƒ∫≈ænika typu
$\mathbb{N} \to \mathbb{N} \to \mathbb{N}$
.
\begin{lstlisting}
#check Œª x y, x + x + y + y
#check Œª (x : ‚Ñï) (y : ‚Ñï), (x + x) + (y + y)
#check Œª (x y : ‚Ñï), (x + x) + (y + y)
#check Œª (x : ‚Ñï), Œª (y : ‚Ñï), (x + x) + (y + y)
\end{lstlisting}
    Zatiaƒæ ƒço prv√Ω pr√≠klad je polymorfn√Ω a fungoval by aj pri aplik√°cii cel√Ωch ƒç√≠sel,
nasleduj√∫ce s√∫ ekvivalentn√© z pohƒæadu typov a predstavuj√∫ in√Ω sp√¥sob z√°pisu.

    V pr√≠pade ≈æe by sme chceli z√≠ska≈• hodnotu z v√Ωrazu pou≈æ√≠jeme pr√≠kaz \emph{\#eval},
alebo \emph{\#reduce}. \emph{Reduce} na rozdiel od \emph{eval} pri vykon√°van√≠ pou≈æ√≠va
jadro na z√≠skanie typu a je tak menej efekt√≠vnym.
\begin{lstlisting}
#eval (Œª (x y : ‚Ñï), (x + x) + (y + y)) 2 3
\end{lstlisting}
    Aplik√°cia n√°m d√°va v√Ωsledok $10$ ktor√Ω je oƒçak√°vanou hodnotou.

    Pre pomenovanie alebo zadefinovanie takejto funkcie pou≈æ√≠vame pr√≠kaz \emph{def}
ktorej tvar v najjednoduch≈°ej podobe m√° tvar:
\begin{lstlisting}
def meno_definicie (argument_1 : typ) (argument_n : typ) :
    typ_navratovej_hodnoty 
:=
    telo funkcie
\end{lstlisting}
V pr√≠pade defin√≠cie ≈°tvorca aj s jeho v√Ωpoƒçtom
\begin{lstlisting}
def obvod_stvorca (x : ‚Ñï) (y : ‚Ñï) : ‚Ñï := x + x + y + y

#eval obsah_stvorca 3 5
\end{lstlisting}

    Kƒæ√∫ƒçov√© slovo \emph{def} ktor√© pou≈æ√≠vame je funkƒçne bez funkƒçn√©ho roziedlu mo≈æn√©
zameni≈• za \emph{theorem}, \emph{lemma}. V pr√≠pade ≈æe chceme uvies≈• iba pr√≠klad
kde meno by p√¥sobilo nadbytoƒçne pou≈æ√≠vame slovo \emph{example}.

\subsection{Typy}
    Doteraz sme uva≈æovali len s typmi mno≈æiny prirodzen√Ωch a cel√Ωch ƒç√≠sel
predstavuj√∫ce na pozad√≠ Leanu konkr√©tne definovan√∫ ≈°trukt√∫ru.
    Typovanie v Lean-e ale podporuje zavedenie nov√©ho abstraktn√©ho typu ktor√Ω patr√≠ univerzu(universe).
    Zavedenie t√Ωchto univerz je motivan√© probl√©mom analogick√Ωm s Russelov√Ωm paradoxom 
a teda ƒçi mno≈æina v≈°etk√Ωch mno≈æ√≠n obsahuje sam√∫ seba.
    V te√≥rii typov sa jedn√° o Girardov paradox.
    Hierarchia t√Ωchto univerz je usporiadan√° od 0 ƒço je univerzum tvoriace najjednoduch≈°ie
typy tak≈æe \emph{Type} alebo aj \emph{Type 0} je potom typom \emph{Type 1} ktor√Ω
je typom \emph{Type 2}.

    ≈†peci√°lne postavenie v typoch maj√∫ tvrdenia oznaƒçujeme \emph{Prop}.
    Okrem toho ≈æe v≈°etky d√¥kazy maj√∫ tento typ. 
    S√∫ postaven√© v hierachii oddelen√© na najni≈æ≈°ej √∫rovni a teda \emph{Prop} je 
typu \emph{Type}.
    Univerzum do ktor√©ho patr√≠ \emph{Prop} oznaƒçujeme \emph{Sort} ƒço je len 
alias.
Plat√≠ vz≈•ah \emph{Sort u + 1} = \emph{Type u}.

V tejto pr√°ci a ani vo v√§ƒç≈°ine pr√°ce s Leanom nie je potrebn√© vyu≈æ√≠va≈• hierachiu
    typov sofistikovanejsie ako prezentovan√Ωm sp√¥sobom.
\begin{lstlisting}
universe u v

constant (a : Typu u) (b : Type v)
\end{lstlisting}
Alebo je mo≈æn√© vyu≈æi≈• substituƒçn√∫ syntax kde \emph{*} znamen√° pre ƒæubovoƒæn√© univerzum
a v pr√≠pade \emph{\_} nech√°me doplni≈• typ automaticky Lean-om.
\begin{lstlisting}
constant f : Type _ ‚Üí Type _
constant g : Type

#check f g
\end{lstlisting}
    Kontrola typu aplik√°cie n√°m vyp√≠≈°e typ \emph{Type u\_1} ƒço je sp√¥sob Lean-u oznaƒçova≈•
e≈°te neurƒçen√Ω typ bez konkr√©tneho univerza.
\subsection{Premenn√©}
    V pr√≠pade ≈æe sa sna≈æ√≠me definova≈• viacero funkci√≠ s rovnak√Ωmi arugmentami alebo
pou≈æ√≠va≈• objekt ktor√©ho typ je vyjadren√Ω komplikovanej≈°√≠m z√°pisom je vhodn√© si
z√°pis zjednodu≈°i≈• premenn√Ωmi.
    Z inak na pohƒæad komplikovan√©ho z√°pisu
\begin{lstlisting}
universes u v

def kompozicia (Œ± : Type u) (Œ≤ : Type v) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (x : Œ±) :
    Œ±
:=
    g (f x)

def kompozicia‚ÇÇ (Œ± : Type u) (Œ≤ : Type v) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (x : Œ≤) :
    Œ≤
:=
    f (g x)
\end{lstlisting}
    tak dost√°vame.
    Premenn√© vstupuju do predpokladov defin√≠cii len tam kde s√∫ pou≈æ√≠t√© v jej tele.
\begin{lstlisting}
universes u v

variables Œ± : Type u
variables Œ≤ : Type v

def kompozicia (x : Œ±) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ± := g (f x)
def kompozicia‚ÇÇ (y : Œ≤) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ≤ := f (g y)
\end{lstlisting}
    Vstupn√© argumenty dokonca m√¥≈æeme vynecha≈• √∫plne, v niektor√Ωch pr√≠padoch to ale
m√¥≈æe by≈• kontraprodukt√≠vne.
\begin{lstlisting}
variables (f : Œ± ‚Üí Œ≤)
          (g : Œ≤ ‚Üí Œ±)

def kompozicia : Œ± := g (f x)
def kompozicia‚ÇÇ : Œ≤ := f (g y)
\end{lstlisting}
Pre doplnenie dod√°vame ≈æe nie je nutn√© ani definova≈• n√°vratov√Ω typ $\alpha$
    respekt√≠ve $\beta$, explicitn√© urƒçenie n√°vratov√©ho typu je ale vhodn√© nie len
    pre ƒçitateƒæa ale aj pre overenie spr√°vnosti v√Ωsledn√©ho typu.
\subsection{Kontext, priestor mien}
    Pre ovl√°danie menn√©ho priestoru a kontextu existuj√∫ v Lean-e r√¥zne mechanizmy
z ktor√Ωch si pop√≠≈°eme len tie najd√¥le≈æitej≈°ie.
    Najjednoduch≈°√≠m je s√∫bor, ktor√©ho defin√≠cie, kon≈°tanty a premenn√© vstupuj√∫ do
kontextu pri deklar√°cii a na konci s√∫boru zanikn√∫.
    Import obsahu in√Ωch s√∫borov sa rob√≠ jednoduch√Ωm pr√≠kazom \emph{import} ktor√Ω
mus√≠ by≈• deklarovan√Ω na zaƒçiatku s√∫boru. V s√∫borovej hierachii sa potom od najvy≈°≈°ej
√∫rovne v jednej z vyhƒæad√°van√Ωch ciest vnorujeme cez bodku.
\begin{lstlisting}
import order.lattice
\end{lstlisting}
    Sa sna≈æ√≠ n√°js≈• prieƒçinok \emph{order} so s√∫borom \emph{lattice.lean}.
    V aktu√°lnej verzii Lean-u v ƒçase p√≠sania pr√°ce sa d√° zisti≈• zoznam prehƒæad√°van√Ωch
ciest prep√≠naƒçom \emph{path} priamo programu \emph{lean}.

    Deklar√°cie premenn√Ωch definovan√© v argumetnoch defin√≠cie prepisuj√∫ vonkaj≈°√≠ kontext.
    V pr√≠pade ≈æeby sme chceli rozdeli≈• kontext s√∫boru na men≈°ie sekcie jednoduch√Ωm
nastrojom je dvojica \emph{section nazov\_sekcie}, \emph{end nazov\_sekcie}.
\begin{lstlisting}
section prirodzene_cisla
  variable Œ± : ‚Ñï
end prirodzene_cisla

section cele_cisla
  variable Œ± : ‚Ñ§
end cele_cisla
\end{lstlisting}
    Pou≈æ√≠vanej≈°√≠m je menn√Ω priestor \emph{namespace nazov} ktor√Ω po zadefinovan√≠ pon√∫ka
mo≈ænos≈• op√§tovn√©ho zavedenia kontextu a vnorenie podobne ako rovnomenn√Ω mechanizmus
v jazyku C++.
\begin{lstlisting}
universe u

namespace skryty

  variable (Œ± : Type u)
  namespace priestor
    def identita (a : Œ±) : Œ± := a
  end priestor
end skryty

#check skryty.priestor.identita

open skryty.priestor

#check identita
\end{lstlisting}
\section{Dokazovanie}

    K dokazovaniu v Leane je mo≈æn√© pristupova≈• viacer√Ωmi sp√¥sobmi.
    Po poskytnut√≠ d√¥kazu u≈æ vn√∫torne Lean-u nez√°le≈æ√≠ na sp√¥sobe ak√Ωm bolo tvrdenie
dok√°zan√©.
    Prv√Ωm sp√¥sobom je priamoƒçiara kon≈°trukcia typu pomocou funkci√≠.
    Druh√Ωm sp√¥sobom je sp√§tn√© dokazovanie ktor√© vyu≈æ√≠va taktick√Ω m√≥d za pomoci
sady pr√≠kazov poloautomatiz√°cie.
    V leanovskej komunite je preferovan√Ω pr√°ve druh√Ω sp√¥sob hoci pre jednoducho
dok√°zateƒæn√© tvrdenia staƒç√≠ a je vyu≈æ√≠van√° aj dopredn√° verzia.

\subsection{Dopredn√© dokazovanie}
    D√¥kaz zostaven√Ω len z $\lambda$-funkci√≠ ktor√© transformuj√∫ argumenty
na v√Ωsledn√Ω typ je pri zlo≈æitej≈°√≠ch d√¥kazoch ≈•a≈æko ƒçitateƒæn√Ω.
    Pre lep≈°iu ƒçitateƒænos≈• poskytuje Lean n√°stroje ktor√© sa sna≈æia kon≈°truova≈• d√¥kazy tak
aby boli ƒçitateƒæn√© ako tie klasick√©.
\begin{lstlisting}
variables p d : Prop

def plati_predpoklad : p ‚Üí d ‚Üí p := Œª hp : p, Œª hd : d, hp
\end{lstlisting}
    Predch√°dzaj√∫ci pr√≠klad je mo≈æn√© prep√≠sa≈• do ƒçitateƒænej≈°ej verzie
\begin{lstlisting}
def plati_predpoklad : p ‚Üí d ‚Üí p :=
  assume hp : p,
  assume hd : d,
  show p, from hp
\end{lstlisting}
Pre lep≈°iu predstavu toho ƒço sa deje na pozad√≠ Lean poskytuje v√Ωstup:
\begin{lstlisting}
pq: Prop
hp: p
hq: q
‚ä¢ p
\end{lstlisting}

    Defin√≠cia hovor√≠ o trivi√°lnom tvrden√≠ ak z $p$ vypl√Ωva $d$ tak plat√≠ $p$. Voƒæn√Ωm
prekladom sa d√° d√¥kaz ƒç√≠ta≈• ako:

\begin{itemize}
    \item Predpokladajme hp,
    \item a predpokladajme hd,
    \item potom vieme uk√°za≈• ≈æe plat√≠ p z predpokladu hp.
\end{itemize}

    O ƒçosi zlo≈æitej≈°√≠m pr√≠kladom je tvrdenie ≈æe ak plat√≠ $p$ konjukcia $q$ tak potom
plat√≠ $q$ konjukcia $p$.

\begin{lstlisting}
def symetria_konjukcie : p ‚àß q ‚Üí q ‚àß p :=
  assume hpq : p ‚àß q,
    have hp   : p     := and.left  hpq,
    have hq   : q     := and.right hpq,
    have hqp  : q ‚àß p := and.intro hq hp,
  show q ‚àß p, from hqp
\end{lstlisting}

    Konjukciu v editore je mo≈æn√© nap√≠sa≈• cez \emph{\textbackslash and}.
    Ak sa pozrieme na typ konjukcie a funkci√≠ ktor√© sme dostali cez pr√≠kaz check.
    Dostaneme v√Ωstup:

\begin{lstlisting}
and : Prop ‚Üí Prop ‚Üí Prop
and.left : ?M_1 ‚àß ?M_2 ‚Üí ?M_1
and.right : ?M_1 ‚àß ?M_2 ‚Üí ?M_2
and.intro : ?M_1 ‚Üí ?M_2 ‚Üí ?M_1 ‚àß ?M_2
\end{lstlisting}

    ƒåo intuit√≠vne koren≈°ponduje s t√Ωm ƒço od t√Ωchto funkci√≠ oƒçak√°vame.
    Tento d√¥kaz je roz≈°√≠ren√≠ o pr√≠kaz have ktor√Ω vytv√°ra predpoklad z existuj√∫cich.
    V poslednej f√°ze d√¥kazu je interakt√≠vny v√Ωstup:

\begin{lstlisting}
pq: Prop
hpq: p ‚àß q
hp: p
hq: q
hqp: q ‚àß p
‚ä¢ q ‚àß p
\end{lstlisting}

\subsection{Sp√§tn√© dokazovanie}

V doprednom dokazovan√≠ sme sa sna≈æili transformova≈• predpoklady tak aby na konci
    bol v√Ωsledkom d√¥sledok.
Ako evokuje n√°zov v sp√§tnom dokazovan√≠ sa sna≈æ√≠me transformova≈• cieƒæ tak aby sme
    sa dostali k jedn√©mu z predpokladov.
Pre tento √∫ƒçel existuje v Lean-e ≈°peci√°lny sp√¥sob dokazovania ktor√Ω naz√Ωvame taktick√Ω
    m√≥d.
Na rozdiel od dopredn√©ho dokazovania je nutn√© ovl√°da≈• v√§ƒç≈°iu sadu pr√≠kazov ktor√©
    priamo transformuj√∫ cieƒæ.
Dokazovanie je tak u≈æ≈°ie prepojen√© s interakt√≠vnym prostred√≠m a pripom√≠na tak hru.
ƒéal≈°ou v√Ωhodou tohto dokazovania je mo≈ænos≈• vyu≈æitie umelej inteligencie pri vyhƒæadan√≠
d√¥kazu.
Tak√Ωto pr√≠stup je obzvl√°≈°≈• u≈æitoƒçn√Ω napr√≠klad v pr√≠pade ≈æe mus√≠me dok√°za≈• identitu
    ktorej d√¥kaz je pr√°cny, a tvor√≠ ho veƒæa za sebou nasleduj√∫cich vyu≈æit√≠ in√Ωch
    ident√≠t ako napr√≠klad vyu≈æitie komutativity alebo asociativity.
U≈æ≈°ie prepojenie s prostred√≠m a automatiz√°cia vyhƒæadania d√¥kazu tohto m√≥du ale
    ide na √∫kor priamej ƒçitateƒænosti.
Pre √∫plnos≈• dopl≈àame ≈æe v taktickom m√≥de nie je nutn√© transformova≈• cieƒæ a je mo≈æn√©
    vyu≈æi≈• aj kon≈°trukcie dopredn√©ho d√¥kazu.

Pre dokazovanie v taktickom m√≥de pou≈æ√≠vame kon≈°trukciue ktor√° je ohraniƒçen√°
    kon≈°trukciou \emph{begin} a \emph{end}.

\begin{lstlisting}
def symetria_konjukcie : p ‚àß q ‚Üí q ‚àß p :=
  begin
    intro h,
    cases h with p q,
    split,
    exact q,
    exact p
  end
\end{lstlisting}

D√¥kaz zaƒç√≠na zaveden√≠m predpokladu z implik√°cie k ostatn√Ωm o ktor√Ωch tvrd√≠me ≈æe
    s√∫ pravdiv√© pr√≠kazom \emph{intro} a rozdelen√≠m konjukcie pr√≠kazom \emph{cases}
    s argumentom zavedenej konjukcie a ich explicitn√Ωm pomenovan√≠m.
V√Ωstup z informaƒçnom okne potom obsahuje.

\begin{lstlisting}
pq: Prop
p: p
q: q
‚ä¢ q ‚àß p
\end{lstlisting}

Pr√≠kazom \emph{split} potom rozdel√≠me cieƒæ na podciele kde sa sna≈æ√≠me dok√°za≈•
ƒæav√∫ a prav√∫ stranu ktor√∫ vid√≠me v informaƒçnom okne ako:

\begin{lstlisting}
2 goals
pq: Prop
h_left: p
h_right: q
‚ä¢ q
pq: Prop
h_left: p
h_right: q
‚ä¢ p
\end{lstlisting}

D√¥kaz potom uzatvor√≠me pr√≠kazom \emph{exact} ktor√Ω uk√°≈æe na jeden z predpokladov
    s rovnak√Ωm typom ako cieƒæ.

\section{Abstraktn√© ≈°trukt√∫ry v Lean-e}
    V matematike a tak isto aj v programovan√≠ sa ƒçasto vyskytuj√∫ objetkov
nad ktor√Ωmi je mo≈æn√© vykon√°va≈• oper√°cie bez ohƒæadu na ich obsah pri splnen√≠
urƒçit√Ωch podmienok.
    V matematike hovor√≠me o ≈°trukt√∫rach ktor√© maj√∫ striktn√∫ defin√≠ciu v programovan√≠
sa d√° voƒæne hovori≈• o triedach.
    Matematick√© ≈°trukt√∫ry v Lean-e su navrhovan√© pr√°ve pomocou mechanizmu tried.
    Kde defin√≠cii triedy zodpoved√° ≈°trukt√∫ra spƒ∫≈àaj√∫ca z defin√≠ce vypl√Ωvaj√∫ce podmienky.
    Potom in≈°tanciou triedy m√¥≈æe by≈• znova ≈°trukt√∫ra ktor√° je definovan√° na u≈æ≈°ej mno≈æine
znova spƒ∫≈àaj√∫cej podmienky, pr√≠kladom je vz≈•ah grupy a podgrupy alebo
priestoru a podpriestoru.
    Alebo in√° mno≈æina ktor√° spƒ∫≈àa okrem podmienok p√¥vodnej ≈°trukt√∫ry ƒèal≈°ie ktor√© ju
obohacuj√∫.
    Pr√≠kladom tak√©ho vz≈•ahu m√¥≈æe by≈• pologrupa ktor√Ω je mno≈æinou s asociat√≠vnou oper√°ciou
a pologrupou ktor√° m√° aj neutr√°lny prvok.

\subsection{Indukt√≠vne ≈°trukt√∫ry}

    Indukt√≠vne ≈°trukt√∫ry predstavuj√∫ notaƒçne siln√Ω n√°stroj pre defin√≠ciu objektov
ktor√Ωch prepojenia medzi prvkami s√∫ prepojen√© jednoduchou asoci√°ciou.
    Jednoduch√Ωm pr√≠kladom je zoznam kde asoci√°ciou medzi prvkami tvor√≠ vz≈•ah
usporiadania.
    Komplikovanej≈°√≠ klasick√Ω pr√≠klad tvoria stromov√© ≈°trukt√∫ry tvoriace uzly
s viacer√Ωmi nasledovn√≠kmi patriace jedn√©mu uzlu.
    V matematike sa s indukciou stret√°vame pri defin√≠cii prirodzen√Ωch ƒç√≠sel
cez Peanove axi√≥my.
    Dve z t√Ωchto axi√≥m hovoria:
\begin{itemize}
    \item 0 je ƒç√≠slo
    \item Ak $a$ je ƒç√≠slo potom nasledovn√≠k $a$ je tie≈æ ƒç√≠slo.
\end{itemize}
    Prv√© pravidlo hovor√≠ o z√°kladnom pr√≠pade, v pr√≠pade zoznamu alebo stromu pr√°zdny
zoznam respekt√≠ve strom.
    Implement√°cia prirodzen√Ωch ƒç√≠sel pomocou indukƒçnej ≈°trukt√∫ry by mohla vyzera≈•
nasledovne:
\begin{lstlisting}
inductive prirodzene : Type
  | nula        : prirodzene
  | nasledovnik : prirodzene ‚Üí prirodzene
\end{lstlisting}
    Za kƒæ√∫ƒçov√Ωm slovom inductive nasleduje n√°zov a sada kon≈°truktorov s n√°vratov√Ωmi
typmi.
    U≈æ z n√°zvu vypl√Ωva s√∫vislos≈• s d√¥kazom s matematickou indukciou kde platnos≈•
nejak√©ho tvrdenia $P(n)$ pre v≈°etky prirodzen√© ƒç√≠sla sa dokazuje pre
\begin{itemize}
    \item $P(0)$, t.j. z√°kladn√Ω pr√≠pad
    \item $\forall n \in \mathbb{N}, P(n) \implies P(n+1)$, indukƒçn√Ω krok
\end{itemize}
    Pre tento typ d√¥kazu existuje v Leane v taktickom m√≥de pr√≠kaz \emph{induction}.
\begin{lstlisting}
example : 5 * n = 4 * n + n :=
    begin
      induction n with d hd,
      ...
    end
\end{lstlisting}
    Po pr√≠kaze induction sa informaƒçnom nach√°dzaju dva ciele pre obe kon≈°truktory
prirodzen√Ωch ƒç√≠sel \emph{nat.zero} a \emph{nat.succ} podobne ako v na≈°ej uvedenej
≈°trukt√∫re a z√°kladnemu pr√≠padu a tvrdeniam matematickej indukcie dokazuj√∫cej platnos≈•
$P$.
\begin{lstlisting}
case nat.zero
‚ä¢ 5 * 0 = 4 * 0 + 0

case nat.succ
d: ‚Ñï
hd: 5 * d = 4 * d + d
‚ä¢ 5 * d.succ = 4 * d.succ + d.succ
\end{lstlisting}

    V pr√≠klade ktor√Ω sme uviedli s√∫ znamienk√° $+$ a $*$ ktor√© pou≈æ√≠vame
v oper√°ciach nad typom na≈°ej indukt√≠vnej ≈°trukt√∫ry.
    V√Ωsledkom oboch bin√°rnych oper√°cii je znova prirodzen√© ƒç√≠slo.
    Podƒæa predpokladov typ ktor√Ω prisl√∫cha ich defin√≠cii je
$prirodzene \to prirodzene \to prirodzene$.
    Jednou z v√Ωhod indkuƒçne definovan√Ωch ≈°trukt√∫r je jednoduchos≈• definovania
rekurz√≠vnych funkci√≠ ktor√© operuj√∫ nad t√Ωmito ≈°trukt√∫rami.
\begin{lstlisting}
variables (a b: prirodzene)

open prirodzene

def sucet : prirodzene ‚Üí prirodzene ‚Üí prirodzene
  | a    nula         := a
  | a (nasledovnik b) := nasledovnik (sucet a b)
\end{lstlisting}
    V tomto pr√≠pade znamen√° not√°cia $|$ pr√≠pad v ktorom sa sna≈æ√≠me n√°js≈• zhodu
s poskytnut√Ωm arugmentom a n√°vratov√Ω typ.
    V tre≈•om pr√≠pade ide o rekurz√≠vne pravidlo ktor√© z argumentu $b$ vytvor√≠ jedo
predchodcu.
    Cel√© pravidlo potom vr√°ti nasledovn√≠ka zo s√∫ƒçtu prv√©ho argumentu a predchodcu
druh√©ho.
    Rekurzia tak pren√°≈°a vlastnos≈• nasledovania z prv√©ho na druh√Ω argument a≈æ
sa argumenty nezhoduj√∫ s prv√Ωm pravidlom a teda argument u≈æ nem√° predchodcu.
    Pre √∫plnos≈• dod√°vame aj technick√Ω detail definovania znamienka $+$ ako volania
funkcie s√∫ƒçtu:
\begin{lstlisting}
local infix ` + ` := sucet
\end{lstlisting}

\subsection{Jednoduch√© ≈°trukt√∫ry}
    V pr√≠pade ≈æe by jeden z kon≈°truktorov neobsahoval typ ktor√Ω poskytuje funkciu
medzi typmi samotnej ≈°trukt√∫ry, ide o obyƒçajn√∫ ≈°trukt√∫ru.
    Ich vyu≈æitie je najm√§ pri definovan√≠ t√Ωch matematick√Ωch a v lean-e maj√∫
≈°peci√°lnu syntax.
    V pr√≠klade uv√°dzame ekvivalentn√© sp√¥soby definovania ≈°trukt√∫r.
\begin{lstlisting}
structure vector :=
  mk :: (x y: ‚Ñï)

structure vector‚ÇÇ :=
  (x : ‚Ñ§)
  (y : ‚Ñ§)
\end{lstlisting}
    Vytv√°ranie objektov danej ≈°trukt√∫ry m√° explicitn√© priradzovanie prvkom
podƒæa n√°zvov v pr√≠pade jednoduch√Ωch ≈°trukt√∫r je vhodnej≈°ie priradzovanie na
z√°klade poriadia z defin√≠cie ≈°turkt√∫ry.
\begin{lstlisting}
def v‚ÇÇ : vector‚ÇÇ :=
  {
    x := 10,
    y := 20,
  }

#check (‚ü®10, 20‚ü© : vector)
\end{lstlisting}
    K jednotliv√Ωm prvkom ≈°trukt√∫ry pristupujeme cez bodku:
\begin{lstlisting}
#eval v.x
\end{lstlisting}
    tak vracia hodnotu 10.
    Pre modelovanie hierarchie kde jedna ≈°trut√∫ra roz≈°iruje druh√∫ pou≈æ√≠vame
kƒæ√∫ƒçov√© slovo \emph{extends}.
    Roz≈°√≠renie na≈°ej ≈°trukt√∫ry o ƒèal≈°iu dimenziu vyzer√° nasledovne:
\begin{lstlisting}
structure vector‚ÇÉ extends vector‚ÇÇ :=
  (z : ‚Ñ§)

def ‚à®‚ÇÉ‚ÇÅ : vector‚ÇÉ :=
  { x := 1, y := 2, z := 3}
\end{lstlisting}
    V pr√≠pade ≈æe chceme vytvori≈• objekt z ro≈°√≠renej ≈°trukt√∫ry a m√°me k dispoz√≠cii
jeho podkladov√Ω je ƒçastov vyu≈æ√≠van√° not√°cia.
\begin{lstlisting}
def ‚à®‚ÇÉ‚ÇÇ : vector‚ÇÉ :=
{
    z := 10, ..v‚ÇÇ
}
\end{lstlisting}

Tu e≈°te vysvetl√≠m z√°vistlostn√© typy.

\subsection{Typov√© triedy}
    Typov√© triedy poskytuj√∫ mechanizmus pomocou ktor√©ho zluƒçujeme rozdielnym ≈°trukt√∫ram
s rovnakou vlastnos≈•ou do tried.
    Pr√≠kladom m√¥≈æu by≈• ma≈• vlastnos≈• usporiadania, ≈°trukt√∫ra m√° reprezentanta alebo
je grupou.
    Po zadefinovan√≠ triedy potom ≈°trukt√∫ru prirad√≠me do tried in≈°tancovan√≠m.
    In≈°tancovanie pre ≈°trukt√∫ry potom b√Ωva odli≈°n√© v z√°vislosti defin√≠cie ≈°trukt√∫ry.
    Vykon√°vanie d√¥kazov nad typovou triedou potom umo≈æ≈àuje zredukova≈• mno≈æstvo defin√≠cii.
    Nad na≈°imi defin√≠ciami vektorov m√¥≈æeme definova≈• dƒ∫≈æku.
\begin{lstlisting}
class length (Œ± : Type u) :=
  (length : Œ± ‚Üí ‚Ñù)
\end{lstlisting}
    Potom k defin√≠ciam ≈°trukt√∫r prid√°me in≈°tancie.
\begin{lstlisting}
instance vector‚ÇÇ_length : length vector‚ÇÇ :=
 { length := Œª (v : vector‚ÇÇ), sqrt(v.x * v.x + v.y * v.y) }

instance vecotr‚ÇÉ_length : length vector‚ÇÉ :=
 { length := Œª (v : vector‚ÇÉ), sqrt(v.x * v.x + v.y * v.y + v.z * v.z) }
\end{lstlisting}
    Triedu potom vyu≈æ√≠vame v defin√≠ciach uveden√≠m do hranat√Ωch z√°tvoriek aj s
argumentom.
\begin{lstlisting}
def meno_definicie (argument : Type) [ dlzka argument ] : Type :=
begin
    ...
end
\end{lstlisting}

K√≥d v tejto sekcii som e≈°te neskontroloval preto≈æe mi prestal fungova≈• lean.

\chapter{Te√≥ria usporiadania}
    V tejto kapitole sa budeme sna≈æi≈• uk√°za≈• mo≈ænosti Lean-u a vyu≈æitie u≈æ existuj√∫cich
defin√≠cii v mathlibe pre dok√°zanie viet t√Ωkaj√∫cich sa te√≥rie usporiadania.
    Pre tento √∫ƒçel je Lean ide√°lny z pohƒæadu na≈°ich mo≈ænost√≠ definovania vlastnost√≠
usporiadania, ktor√© n√°sledne mo≈æno aplikova≈• na abstraktn√∫ mno≈æinu objektov.
    % Toto by bolo dobr√© rozpracova≈• ƒèalej, mo≈æno konkr√©tny pr√≠klad
    V√Ωsledn√Ω typ je potom odvoden√Ω na z√°klade z√°vislostn√Ωch typov.
    Usporiadanie je jednoducho intuit√≠vne uchopiteƒæn√° vlastnos≈• bez matematick√Ωch
preddispoz√≠ci√≠.
    V ka≈ædodennom ≈æivote porovn√°vame svoju v√Ω≈°ku, ƒças, ktor√Ω trval na vybehnutie do kopca
alebo aj ƒç√≠selne neohodnoten√©, subjekt√≠vne merateƒæn√© objekty ako ktor√Ω album
od skupiny preferujem.
    Na ot√°zky si potom vieme odpoveda≈• "ja som vy≈°≈°√≠", "zabehol si pomal≈°ie" alebo
tieto albumy s√∫ neporovnateƒæn√©.

Te√≥ria usporiadania sa sna≈æ√≠ tieto vlastnoti form√°lne definova≈• a rozv√≠ja≈• ƒèalej
ot√°zkami ako, ak√© je horn√© celej mno≈æiny objektov. Existuje ohraniƒçenie horn√© alebo
doln√© pre ƒæubovoƒæn√∫ podmno≈æinu objektov?
    Pre struƒçnos≈• sa v r√°mcii defin√≠cii obmedz√≠me len na defin√≠ciu usporiadania
ako rel√°cie, ƒçi≈æe podmno≈æinu kartezi√°nskeho s√∫ƒçinu dvoch mno≈æ√≠n.

\begin{theorem}
    Majme mno≈æinu $P$, potom usporiadanie alebo ƒçiastoƒçn√© usporiadanie na mno≈æine
    $P$ je bin√°rna rel√°cia $\leq$ tak√° ≈æe, pre v≈°etky $x,y,z \in P$
    \begin{itemize}
        \item $x \leq x$ vlastno≈• reflexivity
        \item $x \leq y$ a $y \leq x$ implikuje $x = y$ antisymetria
        \item $x \leq y$ a $y \leq z$ impikuje $x \leq z$ tranzitivita
    \end{itemize}
\end{theorem}

    Ide√°lnym n√°strojom pre uva≈æovanie nad usporiadan√≠m s√∫ \emph{Hasseho} diagramy.
    Ako pr√≠klad uv√°dzame diagram "kocky".

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.15]{cube.png}
    \caption{Usporiadania $\mathcal{P}(\{a,b,c\})$}
\end{figure}

    Na obr√°zku je usporiadanie v≈°etk√Ωch podmno≈æ√≠n trojprvkovej mno≈æiny $\{ a,b,c \}$.
    Usporiadanie tvor√≠ bin√°rna rel√°cia kardinality podmno≈æ√≠nm priƒçom porovn√°vame
len podmno≈æiny obsahuj√∫ce spoloƒçn√Ω prvok.
    Vy≈°≈°ie s√∫ polo≈æen√© v√§ƒç≈°ie prvky a porovnateƒæn√Ωmi prvkami pova≈æujeme len tie,
ktor√© s√∫ "pokryt√©" jednosmernou cestou cez orientovan√© hrany grafu.

    V Leane je usporiadanie definovan√© ako roz≈°√≠renie triedy predusporiadania, ktor√°
je rel√°ciou, ktor√° nem√° oproti ƒçiastoƒçn√©mu usporiadaniu vlastnos≈• antisymetrie.

\begin{lstlisting}
class has_le       (Œ± : Type u) := (le : Œ± ‚Üí Œ± ‚Üí Prop)
class has_lt       (Œ± : Type u) := (lt : Œ± ‚Üí Œ± ‚Üí Prop)

class preorder (Œ± : Type u) extends has_le Œ±, has_lt Œ± :=
(le_refl : ‚àÄ a : Œ±, a ‚â§ a)
(le_trans : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c)
(lt := Œª a b, a ‚â§ b ‚àß ¬¨ b ‚â§ a)
(lt_iff_le_not_le : ‚àÄ a b : Œ±, a < b ‚Üî (a ‚â§ b ‚àß ¬¨ b ‚â§ a) . order_laws_tac) -- toto chceme aj vysvetlit
\end{lstlisting}
ƒåiastoƒçn√© usporiadanie je potom roz≈°√≠ren√≠m predusporiadania o vlastnos≈• antysymetrie.
\begin{lstlisting}
class partial_order (Œ± : Type u) extends preorder Œ± :=
(le_antisymm : ‚àÄ a b : Œ±, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b)
\end{lstlisting}

DOPLN PRIKLAD NAJLEPSIE AK NAS USPORIADANY POSET Z PRIKLADU

\subsubsection{Zv√§z}
    Zv√§z je usporiadan√° mno≈æina, pre ktor√∫ navy≈°e plat√≠, ≈æe pre ka≈æd√© 2 prvky $a, b$
vieme n√°js≈• prvok $c$, ktor√Ω je ich jedineƒçn√Ωm najmen≈°√≠m horn√Ωm, respekt√≠ve(\emph{supremum})
najv√§ƒç≈°√≠m doln√Ωm ohraniƒçen√≠m(\emph{infinum}).
    V pr√≠pade intervalu re√°lnych ƒç√≠sel je toto ohraniƒçenie jednoducho predstaviteƒæn√©
ako bod ohraniƒçuj√∫ce mno≈æinu na ƒç√≠selnej osi.
    Ak ide o ƒçiastoƒçn√© usporiadanie, n√°zov je pre tieto ohraniƒçenia prvkov
motivovan√Ω zobrezn√≠m na grafe.
    \emph{Spojenie} $\sqcup, \vee$ pre supremum, respekt√≠ve \emph{priesek} $\sqcap, \wedge$ pre infinum.
    Popisnej≈°√≠m n√°zvom pre zv√§z je preklad anglicky pou≈æ√≠van√©ho n√°zvu \emph{lattice}
"mrie≈æka" tak isto motivovan√° zobrazen√≠m tak√©ho usporiadania na grafe.
    Pri dokazovan√≠ viet o zv√§zoch je ƒçasto vyu≈æ√≠van√° vlastnos≈• duality najmen≈°ieho
horn√©ho a du√°lne najv√§ƒç≈°ieho doln√©ho ohraniƒçenie pre druh√∫ polovicu d√¥kazu.
    V pr√≠pade zv√§zu je t√°to vlastnos≈• vyu≈æit√° rovno v defin√≠cii zv√§zu ako spojenie
du√°lnej defin√≠cie supr√©moveho a infinumov√©ho semizv√§zvu.

\begin{lstlisting}
class has_sup (Œ± : Type u) := (sup : Œ± ‚Üí Œ± ‚Üí Œ±)
class has_inf (Œ± : Type u) := (inf : Œ± ‚Üí Œ± ‚Üí Œ±)

infix ‚äî := has_sup.sup
infix ‚äì := has_inf.inf

class semilattice_sup (Œ± : Type u) extends has_sup Œ±, partial_order Œ± :=
(le_sup_left : ‚àÄ a b : Œ±, a ‚â§ a ‚äî b)
(le_sup_right : ‚àÄ a b : Œ±, b ‚â§ a ‚äî b)
(sup_le : ‚àÄ a b c : Œ±, a ‚â§ c ‚Üí b ‚â§ c ‚Üí a ‚äî b ‚â§ c)

class semilattice_inf (Œ± : Type u) extends has_inf Œ±, partial_order Œ± :=
(inf_le_left : ‚àÄ a b : Œ±, a ‚äì b ‚â§ a)
(inf_le_right : ‚àÄ a b : Œ±, a ‚äì b ‚â§ b)
(le_inf : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ b ‚äì c)

class lattice (Œ± : Type u) extends semilattice_sup Œ±, semilattice_inf Œ±
\end{lstlisting}

Na nasleduj√∫cich grafoch si uk√°≈æeme ako vyzeraj√∫ zv√§zy.

PRIDAT VLASTNY PRIKLAD, OPYTAT SA
\begin{lstlisting}
def poset_nat : sublattice ‚Ñï :=
    { carrier := {n : ‚Ñï | 1 ‚â§ n},
    inf_mem :=
      begin¬∑
        intro a,
        intro b,
        intro a_set,
        intro b_set,
        simp at a_set,
        simp at b_set,
        simp,
        split,
        exact a_set,
        exact b_set,
      end,
    sup_mem := by finish,
}
\end{lstlisting}

\subsubsection{Modul√°rne zv√§zy}

V nasleduj√∫com √∫seku si uk√°≈æeme vetu t√Ωkaj√∫cu sa ≈°peci√°lneho typu zv√§zu s vlastnos≈•ou
    modularity a uk√°≈æeme si form√°lny d√¥kaz a jej implement√°ciu v Leane, ktor√∫ si
    podrobne rozoberieme.

O zv√§ze $L$ hovor√≠me, ≈æe je modul√°rny, v pr√≠pade, ≈æe m√° nasleduj√∫cu vlastnos≈•.

\begin{equation*}
    (\forall x,y,z \in L) x \geq y \implies x \wedge ( y \vee z) = (x \wedge y) \vee z
\end{equation*}

V Leane definovan√Ω ako roz≈°√≠renie zv√§zu:

\begin{lstlisting}
class modular_lattice(Œ± : Type u) extends lattice Œ± :=
  (modular_law: ‚àÄ (x u v : Œ± ), (x ‚â§ u) ‚Üí u ‚äì (v ‚äî x) = (u ‚äì v) ‚äî x )
\end{lstlisting}

V nasleduj√∫com √∫seku si uk√°≈æeme vetu o modul√°rnom izomorfizme a podrobne
    si rozoberieme implement√°ciu jej d√¥kazu s obsahom prostredia v Leane.

TODO ZJEDNOTIT ZNACENIE DEFINICIE A LEAN-u
\subsection{Modul√°rne zv√§zy}
    \begin{theorem} \emph{Veta o izomorfizme modul√°rnych zv√§zov}
    Nech L je modul√°rnym zv√§zom a $a, b \in L$. Potom
        \begin{equation}
            \varphi_{b}: x \mapsto x \wedge b, x \in [a, a \vee b],
        \end{equation}
    Je izomorfizmom medzi intervalmi $[a, a \vee b]$ a $[ a \wedge b, b]$.
    Inverzn√Ωm izomorfizmom je
        \begin{equation}
            \psi_{a}: y \mapsto x \vee a, y \in [a \wedge b, b].
        \end{equation}
    \end{theorem}
    \emph{D√¥kaz}.  Staƒç√≠ uk√°za≈•, ≈æe $\varphi_{b}\psi_{a}(y) = y$ pre v≈°etky $x \in [a, a \vee b]$.
    Z duality vypl√Ωva, ≈æe $\varphi_{b}\psi_{a}(y) = y$ pre v≈°etky
        $y \in [a \wedge b, b]$,
    Majme $x \in [a, a \vee b]$. Potom
        $\psi_{a}\varphi_{b} = ( x \wedge b ) \vee a$ nerovnos≈• $a \leq x$ plat√≠
        potom aj modularita
        \begin{equation}
            \varphi_{a}\psi_{b}(x) =
            ( x \wedge b ) \vee a =
            x \wedge ( b \vee a) =
            x
        \end{equation}
        preto≈æe
        \[
            \pushQED{\qed}
            x \leq a \vee b. \qedhere
            \popQED
        \]

    Predstaven√Ω d√¥kaz je zn√°zornen√Ω na nasleduj√∫com grafe.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.35]{modular_lattice_isomorphism.png}
    \caption{Izomorfizmus modul√°rneho zv√§zu}
\end{figure}

    V pr√≠pade form√°lneho d√¥kazu sme sa mohli v ƒçasti d√¥kazu odk√°za≈• na dualitu. 
    V pr√≠ n√°vrhu d√¥kazu v Leane mus√≠me uk√°za≈• d√¥kaz z "oboch" str√°n.

\begin{lstlisting}
theorem modular_lattice_isomorphism { Œ±: Type u } [ modular_lattice Œ± ]
{ u v w x y : Œ± } :
  x ‚â§ u ‚Üí
  x ‚â• v ‚Üí
  x ‚â• u ‚äì v ‚Üí
  x ‚â§ u ‚äî v ‚Üí
  u ‚äì ( v ‚äî x ) = x ‚àß (u ‚äì x) ‚äî v = x
  :=
  begin
 1        intros h1 h2 h3 h4,
 2        split,
 3        {
 4          rw modular_lattice.modular_law,
 5          exact sup_eq_right.mpr h3,
 6          exact h1
 7        },
 8        {
 9          rw inf_comm,
10          rw ‚Üê modular_lattice.modular_law,
11          exact inf_eq_left.mpr h4,
11          exact h2
12        }
  end
\end{lstlisting}
    Zaƒç√≠name v taktickom m√≥de pr√°zdnou kon≈°trukciou \emph{begin} a \emph{end}
    Interakt√≠vne prostredie vyzer√° nasledovne.
\begin{lstlisting}
Œ±: Type u
_inst_1: modular_lattice Œ±
u v w x y : Œ±
‚ä¢ x ‚â§ u ‚Üí x ‚â• v ‚Üí x ‚â• u ‚äì v ‚Üí x ‚â§ u ‚äî v ‚Üí u ‚äì (v ‚äî x) = x ‚àß u ‚äì x ‚äî v = x
\end{lstlisting}
    Prv√Ωm krokom d√¥kazu je presunutie predpokladov zo sledu implik√°cii do
prostredia pre ƒèal≈°iu pr√°cu s nimi s oznaƒçen√≠m $h1,h2,h3,h4$.
\begin{lstlisting}
Œ±: Type u
_inst_1: modular_lattice Œ±
uvwxy: Œ±
h1: x ‚â§ u
h2: x ‚â• v
h3: x ‚â• u ‚äì v
h4: x ‚â§ u ‚äî v
‚ä¢ u ‚äì (v ‚äî x) = x ‚àß u ‚äì x ‚äî v = x
\end{lstlisting}
    Cieƒæ potom pozost√°va z konjukcie, kde v druhej ƒçasti m√°me v√Ωraz implicitne
oz√°tvorkovan√Ω zƒæava.
    V√Ωraz rozdel√≠me do dvoch podcieƒæov pr√≠kazom \emph{split}, a pre lep≈°iu
ƒçitateƒænos≈• oz√°tvorkujeme mno≈æinov√Ωmi z√°tvorkami. Nach√°dzame sa v stave
\begin{lstlisting}
  begin
    intros h1 h2 h3 h4,
    split,
    {
    },
    {
    }
  end
\end{lstlisting}
v ktorom n√°m lean ukazuje prostredie, kde mus√≠me dok√°za≈• ƒæav√∫ ƒças≈• konjukcie.
\begin{lstlisting}
‚ä¢ u ‚äì (v ‚äî x) = x
\end{lstlisting}
Na cieƒæ pou≈æijeme z defin√≠cie modul√°rneho zv√§zu vlastnos≈• modularity
\begin{lstlisting}
    (modular_law: ‚àÄ (x u v : Œ± ), (x ‚â§ u) ‚Üí u ‚äì (v ‚äî x) = (u ‚äì v) ‚äî x )
\end{lstlisting}
a transformujeme prep√≠≈°eme cieƒæ cez pr√≠kaz
\begin{lstlisting}
rw modular_lattice.modular_law,
\end{lstlisting}
na nasleduj√∫ci, kde m√° $u \sqcap v$ vy≈°≈°iu precedenciu
\begin{lstlisting}
‚ä¢ u ‚äì v ‚äî x = x
\end{lstlisting}
    Nasleduj√∫ca transform√°cia vy≈æaduje znalos≈• u≈æ dok√°zan√Ωch defin√≠ci√≠, ktor√©
boli dok√°zan√© pre podkladov√© ≈°trukt√∫ry. Pou≈æijeme nasleduj√∫cu defin√≠ciu, ktor√° vych√°dza
z kontextu \emph{semilattice\_sup}.
\begin{lstlisting}
% @[simp] theorem sup_eq_right : a ‚äî b = b ‚Üî a ‚â§ b :=    / TODO NEZABUDNUT
%  le_antisymm_iff.trans $ by simp [le_refl]             / ODKOMENTOVAT
    \end{lstlisting}
    Zauj√≠mavos≈•ou je, ≈æe si Lean dok√°≈æe substiuova≈• v√Ωraz $u \sqcap v$ za $a$ z uveden√©ho
v√Ωrazu. Pri pou≈æit√≠ vety dost√°vame ekvivalenciu, ktor√° je definovan√° ako ≈°trukt√∫ra.
\begin{lstlisting}
structure iff (a b : Prop) : Prop :=
    intro :: (mp : a ‚Üí b)
             (mpr : b ‚Üí a)
\end{lstlisting}
Z tejto ≈°trukt√∫ry pou≈æijeme implik√°ciu smeruj√∫ca doƒæava nasledovne:
\begin{lstlisting}
    exact sup_eq_right.mpr h3,
\end{lstlisting}
    Cieƒæ je teda transformovan√Ω na:
\begin{lstlisting}
‚ä¢ x ‚â§ u
\end{lstlisting}
ƒço je u≈æ uveden√Ω predpoklad $h1$. T√Ωmto sme dok√°zali jeden z podcieƒæov.
    V tejto chv√≠li by sme sa v literat√∫re mohli odvola≈• na dualitu v√Ωrazov.
    V Leane mus√≠me poskytn√∫≈• d√¥kaz aj o druhom cieli. Ideme dok√°za≈•
\begin{lstlisting}
‚ä¢ u ‚äì x ‚äî v = x
\end{lstlisting}
V tejto chv√≠li chceme znova pou≈æi≈• modularitu, leanu je, ale potrebn√© explicitne poveda≈•,
    ≈æe chceme prep√≠sa≈• v√Ωraz nach√°dzaj√∫ci na pravej strane rovnosti pomocou symbolu
ƒæavej ≈°√≠pky.
\begin{lstlisting}
rw ‚Üê modular_lattice.modular_law,
\end{lstlisting}
    Pou≈æijeme du√°lnu vetu
    du√°lnu k \emph{sup\_eq\_right}.
\begin{lstlisting}
@[simp] theorem inf_eq_left : a ‚äì b = a ‚Üî a ‚â§ b
\end{lstlisting}
    a vyu≈æijeme opaƒçn√© predpoklady k predch√°dzaj√∫cim $h2, h4$.
\begin{lstlisting}
{
    rw ‚Üê modular_lattice.modular_law,
    exact inf_eq_left.mpr h4,
    exact h2
}
\end{lstlisting}

Po dok√°zan√≠ druh√©ho cieƒæa sme dok√°zali cel√∫ vetu. $\square$

\begin{thebibliography}{xx}
    \bibitem{Mimram} Samuel Mimram, Program = Proof, Indenpendently published(July 3, 2020), ISBN-13: 979-8615591839
    \bibitem{SorensenUrzyczyn} Morten Heine B. S√∏rensen, Pawel Urzyczyn, Lectures on the Curry-Howard Isomorphism,
        Elsevier Science (April 4, 2013),  ISBN-13 : 978-0444545961
    \bibitem{lean3} https://github.com/leanprover/lean
    \bibitem{lean4} https://github.com/leanprover/lean4
    \bibitem{mathlib} https://github.com/leanprover-community/mathlib
    \bibitem{mathlib_paper} https://leanprover-community.github.io/papers/mathlib-paper.pdf
\end{thebibliography}

Slovicka na ktore nepoznam preklad a ne
\begin{itemize}
    \item kalkul alebob kalkulus
    \item namespace - priestor mien
    \item universe - univerzum
\end{itemize}

\end{document}

\begin{verbatim}
    structure point :=
      ( x : nat )
      ( y : nat )

    /-- alternative notation -/
    structure point_alternative :=
      mk :: (x : nat) (Y : nat)

    def p1 : point :=
    {
      x   := 10,
      y   := 20,
    }

    /- same point, different notation, same notation for ordered seti -/
    def p2 : point := $\langle 10, 20 \rangle$

    /- instance only one part of structure, rest implicitly from other instance
    def p3 : point := {
        x := 20,
        ..p
    }
\end{verbatim}

% sposob ukladania kodu

\subsubsection{Type classes}

