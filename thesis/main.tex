\documentclass[a4paper,10pt,oneside]{report}%pridat twoside, do [] pre obojstrannu tlac
\pagestyle{headings}
\usepackage[top=2.5cm, bottom=2.5cm, left=3.5cm, right=2cm]{geometry} %odporucane okraje
\linespread{1.50}

%% Generally used
\usepackage{ebproof}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb, upgreek}
\usepackage{mathtools}
\usepackage{color}
\usepackage{pdfpages}
\usepackage[slovak]{babel}
\usepackage[T1]{fontenc}
%% Generally used

% USE PACKAGE BABEL SLOVAK

\renewcommand{\thesection}{\arabic{section}}

%% Lean specific
\usepackage[utf8x]{inputenc}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{errorcolor}{rgb}{1, 0, 0}           % bright red
\definecolor{stringcolor}{rgb}{0.5, 0.3, 0.2}    % brown
\usepackage{pict2e,picture}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}
%% Lean specific

%% Covering

\newcommand{\coveringA}{%
  \mathrel{-\mkern-4mu}<%
}
\newcommand{\coveringB}{\mathrel{\text{$\vcenter{\hbox{\pictcoveringB}}$}}}

\newcommand{\pictcoveringB}{%
  \begin{picture}(1em,.5em)
  \roundcap
  \put(0,.25em){\line(1,0){.6em}}
  \put(.6em,.25em){\line(3,1){.4em}}
  \put(.6em,.25em){\line(3,-1){.4em}}
  \end{picture}%
}
%% Covering

%% Powerset
\newcommand{\powerset}{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}
%% Powerset
\newcommand{\nothing}{\varnothing}

\newtheorem{theorem}{Veta}[chapter]
\newtheorem{definition}{Defin√≠cia}[chapter]

\author{Mat\'u\v{s} Behun}
\title{Dokazovanie viet v syst√©me Lean}

\begin{document}

%\setlength{\belowdisplayskip}{7pt} \setlength{\belowdisplayshortskip}{5pt}
%\setlength{\abovedisplayskip}{7pt} \setlength{\abovedisplayshortskip}{5pt}


%\thispagestyle{empty}
%{
    %\topmargin=0pt
    %\centerline {\large \bf{Slovensk√° technick√° univerzia v Bratislave}}
    %\vskip 0.2cm
    %\centerline{\large \bf{Stavebn√° fakulta}}
    %\vskip 0.2cm
    %Evidenƒçn√© ƒç√≠slo: SvF-5343-54946 
    %\vskip 5.0cm
    %\centerline{\Large \bf{Dokazovanie viet v syst√©me Lean}}
    %\vskip 0.2cm
    %\vskip 0.5cm
    %\centerline{\large \bf{Diplomov√° pr√°ca}}
    %\vskip 7cm          %\vskip 2cm             %zmena kvoli zobrazovaniu dnesneho datumu
    %\normalsize
    %\begin{tabular}[l]{p{0.27\textwidth}p{0.73\textwidth}}
        %≈†tud√≠jny program: & matematicko poƒç√≠taƒçov√© modelovanie  \\
        %Odbor: & matematika  \\
        %Department: & Katedra matematiky a deskript√≠vnej geometrie\\
        %Ved√∫ci pr√°ce: & doc. Mgr. Gejza Jenƒça, PhD. \\
    %\end{tabular}
    %\vskip 3cm
    %\centerline{\large \bf{Bratislava 2021}}
    %\vskip 0.2cm
    %\centerline{\large \bf{Mat\'u\v{s} Behun}}
%}

%\newpage

%% Odkomentovat
%%% \includepdf[pages={1}]{zadanieDiplomovka.pdf}

%\newpage

\section{Abstrakt}

    Pr√°ca sa zaober√° dokazovac√≠m asistentom Lean ktor√Ω je zalo≈æen√Ω na te√≥rii
z√°vislostn√Ωch typov.
    Opisujeme z√°kladn√∫ syntax Lean-u pre tvorbu defin√≠cii a ≈°trukt√∫r a pr√°cu s typmi
ktor√© reprezentuj√∫ matematick√© tvrdenia a sp√¥soby ich dokazovania.
    Podrobne rozober√°me n√°≈° pr√≠spevok ≈°trukt√∫ry podzv√§zu do projektu mathlib a
d√¥kazu vety o izomorfizme intervalov v r√°mcii te√≥rie ƒçiastoƒçn√©ho usporiadania.
    S√∫ƒças≈•ou pr√°ce je aj opis prepojenia logiky a v√Ωpoƒçtov√Ωch modelov zn√°me ako
Curry-Howardov izomorfizmus.

    \textbf{Kƒæ√∫ƒçov√© slov√°}: Lean, asistent dokazovania, te√≥ria ƒçiastoƒçn√©ho usporiadania, Curry-Howardov izomorfizmus

~\\

    This diploma thesis describes proof assistant Lean based on dependent type theory.
    We describe basic syntax of Lean for creating and working with definitions, structures and
types that are representing mathematical propositions and their proofs.
    In detail we describe our contribution of structure of sublattice to project mathlib
as well as theorem of modular lattice isomorphism.
    Part of the work conisist of connection between logic and computational model
known as Curry-Howard isomorphism.
    
    \textbf{Keywords}: Lean, proof assistant, partial order theory, Curry-Howard isomorphism

\newpage

\tableofcontents

\newpage

\chapter{√övod}
    Dokazovac√≠ asistenti obsahuj√∫ interakt√≠vne prostredie ktor√© na z√°klade vstupu
pou≈æ√≠vateƒæa tvoria form√°lne d√¥kazy.
    T√°to diplomov√° pr√°ca sa zaober√° dokazovac√≠om asistentom Lean ktor√Ω je
zalo≈æen√Ω na te√≥rii z√°vistlostn√Ωch typoch.
    V √∫vode pr√°ce uv√°dzame teoreticky nevyhnut√∫ ƒças≈• intuicionistickej logiky
a jednoduchej te√≥rie typov aby sme uk√°zali prepojenie medzi logikou a v√Ωpoƒçtov√Ωmi
modelmi ktor√© je zn√°me ako Curry-Howardov izomorfizmus.

    Druh√° kapitola opisuje prostredie Lean-u, jeho z√°kladn√∫ syntax a pr√°cu s 
typmi ktor√© s√∫ jeho z√°kladn√Ωm prvkom.
    Poskytujeme pohƒæad na dva sp√¥soby dokazovania. Dopredn√Ωm sp√¥sobom ktor√© je priamym
poskytnut√≠m $\lambda$-v√Ωrazu, a sp√§tn√Ωm v taktickom m√≥de ktor√© naplno vyu≈æ√≠va interakt√≠vne prostredie.
    Kapitolu uzatv√°rame opisom syntaxe vyu≈æ√≠vanej na budovanie ≈°trukt√∫r pou≈æ√≠vanej
pri tvorbe t√Ωch matematick√Ωch, a ich hierarchie.

    V poslednej kapitole rozober√°me na≈°u implement√°ciu vety o izomorfizme modul√°rnych
zv√§zov.
    Opisujeme z√°kladn√© defin√≠cie a ≈°trukt√∫ry t√Ωkaj√∫ce sa te√≥rie ƒçiastoƒçn√©ho usporiadania
implementovan√Ωch v r√°mci komunitn√©ho projektu mathlib.
    Na z√°ver podrobne opisujeme n√°≈° pr√≠spevok ≈°trukt√∫ry podzv√§zu do tejto kni≈ænice aj s jeho atrib√∫tmi.

\chapter{Curry-Howardov izomorfizmus}
\section{Intuicionistick√° logika}
    Kon≈°truktivizmus je jeden z filozofick√Ωch smerov ktor√Ω hovor√≠ o tom ≈æe vedmosti
s√∫ tvoren√© a mali by by≈• zahrnut√© k doteraz poznan√©mu.
    Tento filozofick√Ω smer mal vplyv aj na matematiku kde sa na jeho z√°klade
vytvorilo viacero "≈°k√¥l" ako finitizmus, predikativizmus, intuicionizmus.
    \emph{Intuitionizmus} ako jeden z nich je teda kon≈°trukt√≠vny pr√≠stup k matematike
v duchu uƒçenia Brouwera(1881-1966) a Heytinga(1898-1980).
    Filozofick√Ωm z√°kladom tohto pr√≠stupu je princ√≠p ≈æe matematika je v√Ωtvorom ment√°lnej
ƒçinnosti a nepozost√°va z v√Ωsledkov form√°lnej manipul√°cie symbolov ktor√© s√∫ iba
sekund√°rne.
    Jedn√Ωm z princ√≠pov je tak odmietnutie postul√°tu z√°kona vyl√∫ƒçenia tretieho
z klasickej logiky.
\begin{equation}
    p \vee \neg p
\end{equation}
    V pr√≠pade d√¥kazu sporom nad v√Ωrokom $p$ je mo≈æn√© dok√°za≈• existenciu $p$,
ƒço je z kon≈°trukt√≠vneho pohƒæadu nezmysel preto≈æe uva≈æujeme nad pravdivos≈•ou
    v√Ωroku nez√°visle od uva≈æovan√©ho tvrdenia.
V√Ωrok v intuicionistickej logike je teda pravdiv√Ω ak existuje d√¥kaz o jeho pravdivosti
a nepravdiv√Ω ak existuje d√¥kaz ktor√Ω vedie k sporu.
    % a toto je zo sochora
    V logike definujeme d√¥kaz ako z nejak√Ωch predpokladov ako koneƒçn√∫ postupnos≈•
form√∫l, pri ktor√Ωch tvorbe m√¥≈æeme v ka≈ædom kroku spravi≈• jeden z nasleduj√∫cich
√∫konov:
\begin{itemize}
    \item Nap√≠sa≈• postul√°t alebo axi√≥m logiky
    \item Nap√≠sa≈• jeden z predpokladov
    \item Nap√≠sa≈• formulu, ktor√∫ dostaneme aplik√°ciou dedukƒçn√©ho pravidla na niektorej
formuly predch√°dzaj√∫cej v postupnosti.
\end{itemize}
    V≈°etky tieto kroky si postupne zavedieme aj s dedukƒçn√Ωmi pravidlami.
    Pre lep≈°ie pochopenie pojmu formuly a premennej uv√°dzame ich nasleduj√∫cu defin√≠ciu:
    % vyrok, premenna ~ vyrokova premenna
\begin{definition}[V√Ωrokov√° premenn√°, formula]
    Majme spoƒç√≠tateƒæn√∫ mno≈æinu $\mathcal{X}$ v√Ωrokov√Ωch premenn√Ωch. Mno≈æina premenn√Ωch
    alebo form√∫l $\mathcal{A}$ generujeme nasledovnou gramatikou:
    \begin{equation}
        A, B ::= X | A \implies B | A \wedge B | A \vee B | \neg A | \top | \bot
    \end{equation}
    Kde $X \in \mathcal{X}$ reprezentuje v√Ωrokov√∫ premenn√∫, a $A, B \in \mathcal{A}$
    formulu.
\end{definition}
    Formulu ktor√∫ tvor√≠ len v√Ωrokov√° premenn√° naz√Ωvame atomickou.
    V √∫vode tohto textu sme hovorili o postul√°te alebo axi√≥me z√°kone vyl√∫ƒçenia
tretieho ktor√Ω je formulou.
    ƒéal≈°√≠m pr√≠kladom formuly generovanej uvedenou gramatikou je:
\begin{align*}
    \neg A \wedge B \wedge C &\implies A \vee B \\
\end{align*}
    V pr√≠pade ≈æe by sme chceli predch√°dzaj√∫cu formulu ohodnoti≈• je precendencia
neg√°cie vy≈°≈°ia ako konjukcie a disjunkcie a tie ju maj√∫ vy≈°≈°iu ako implik√°cia.
V pr√≠pade formuly obsahuj√∫cej viac za sebou id√∫cich bin√°rnych oper√°torov plat√≠ asoci√°cia
z pravej strany.
    V pr√≠pade ≈æe chceme uvies≈• jeden z predpokladov do d√¥kazu vyber√°me z mno≈æiny
ktor√∫ naz√Ωvame kontextom.
\begin{theorem}
    Kontextom(syst√©m predpokladov) rozumieme zoznam form√∫l znaƒçen√Ωch
    \begin{equation}
        \Gamma = P_{1}, \dots , P_{n}
    \end{equation}
    Dedukciou naz√Ωvame dvojicu pozost√°vaj√∫cu z kontextu a formuly.
    \begin{equation}
        \Gamma \vdash A
    \end{equation}
\end{theorem}
    V√Ωraz $\Gamma \vdash A$ ƒç√≠tame ako premenn√∫ $A$ je mo≈æn√© dok√°za≈• zo syst√©mu 
predpokladov $\Gamma$.
    Nad uveden√Ωmi predpokladmi a postul√°tmi potom pomocou dekuƒçn√Ωch pravidiel prirodzenej
intucionistickej logiky potom odv√°dzame nov√© formuly a roz≈°irujeme tak te√≥riu.
    Zau≈æ√≠vanou not√°ciou pre dedukƒçn√© pravidl√° je nasledovn√°:
    \begin{equation}
        \begin{prooftree}
            \hypo{\Gamma_{1} \vdash A_{1}}
            \hypo{\dots}
            \hypo{\Gamma_{n} \vdash A_{n}}
            \infer3[]{\Gamma \vdash A}
        \end{prooftree}
    \end{equation}
    Horn√∫ ƒças≈• tvor√≠ mno≈æinu dedukci√≠ $\Gamma_{i}$ ktor√© naz√Ωvame prepokladom a
dolnej $\Gamma$ ktor√∫ naz√Ωvame z√°verom.
    V pr√≠pade ≈æe ƒç√≠tame dedkuƒçn√© pravidlo alebo dedkuƒçn√Ω strom tvoren√Ω tak√Ωmito
pravidlami zhora nadol hovor√≠me o dedukcii v opaƒçnom smere o indukcii.
    Prirodzen√° intuicionistick√° logika obsahuje nasleduj√∫ce pravidl√°:
\begin{center}
    \begin{prooftree}
        \infer0[(ax)]{\Gamma,A,\Gamma' \vdash A}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \implies B}
        \hypo{\Gamma \vdash A}
        \infer2[$(\implies_{E})$]{\Gamma \vdash B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$\implies_{I}$]{\Gamma \vdash B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{l}_{E})$]{\Gamma \vdash A}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{r}_{E})$]{\Gamma \vdash B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \hypo{\Gamma \vdash B}
        \infer2[$(\wedge_{I})$]{\Gamma \vdash A \wedge B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \vee B}
        \hypo{\Gamma, A \vdash C}
        \hypo{\Gamma, B \vdash C}
        \infer3[$(\vee_{E})$]{\Gamma \vdash C}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash B}
        \infer1[$(\vee_{I}^{r})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \infer1[$(\vee_{I}^{l})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash \neg A}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{E})$]{\Gamma \vdash \bot}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash \bot}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{I})$]{\Gamma \vdash \neg A}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{center}
    \begin{prooftree}
        \hypo{\Gamma \vdash \bot}
        \infer1[$(\bot_{E})$]{\Gamma \vdash A}
    \end{prooftree}
\end{center}
    Z√°ver pravidiel s doln√Ωm indexom $E$ maj√∫ v z√°vere v√Ωrokov√© premenn√©.
    Pravidl√° s doln√Ωm indexom $I$ √∫vadzaj√∫ neatomick√© formuly.
    Pravidlo $\implies_{E}$ je zn√°me ako \emph{modus ponens}.
    Fragmentom logiky naz√Ωvame, syst√©m ktor√Ω dostaneme ak sa obmedz√≠me len na niektor√©
z dedkuƒçn√Ωch pravidiel.
    My uvedieme implikaƒçn√Ω fragment ktor√Ω je potom pou≈æit√Ω v Curry-Howardovom
izomorfizme.
\begin{theorem}
    Implikaƒçn√Ω fragmento intuionistickej logiky dostaneme v pr√≠pade ak formuly
        bud√∫ tvoren√© gramatikou
    \begin{equation}
        A,B ::= X | A \implies B
    \end{equation}
    a pravidlami (ax), ($\implies_{E}$), ($\implies_{I}$)
\end{theorem}
    Aj keƒè tento fragment tvor√≠ len jedna logick√° spojka a v√Ωrokov√© premenn√© je
mo≈æn√© pomocou nich odvodi≈• v√§ƒç≈°inu logicky ekvivalentn√Ωch form√∫l tvoren√Ωch gramatikou
uvedenou na zaƒçiatku.

% TODO spravit priklad
% (ùê¥‚àßùêµ)‚Üí((ùê¥‚Üíùê∂)‚Üí¬¨(ùêµ‚Üí¬¨ùê∂))

\section{$\lambda$-kalkulus}
    $\lambda$-kalkulus je v√Ωpoƒçtov√Ω model ktor√Ω sa v informatike vyu≈æ√≠va pre svoju
jednoduchos≈• a v√Ωpoƒçtov√∫ schopnos≈•.
    Napriek tomu ≈æe form√°lne tento model tvoria len tri v√Ωrazy je jeho v√Ωpoƒçtov√°
schopnos≈• rovn√° \emph{Turingovmu stroju}.
    To znamen√° ≈æe v ≈àom dok√°≈æeme naprogramova≈• v≈°etky algoritmy ktor√© dok√°≈æe
spracova≈• klasick√Ω poƒç√≠taƒç.
    Pre tieto vlastnosti je vyu≈æ√≠van√Ω aj ako z√°klad pre v≈°etky funkcion√°lne programovacie
jazyky.
    V tejto sekcii si ho form√°lne uvedieme aj s pr√≠kladmi ktor√© ukazuj√∫ ako je
v ≈àom mo≈æn√© zak√≥dova≈• jednoduch√© algoritmy.

\begin{theorem}
    Mno≈æinu $\Lambda$ tvoren√∫ $\lambda$-v√Ωrazmi je potom generovan√° nasledovnou gramatikou:
    \begin{equation}
        t, u ::= x | t u | \lambda x.t
    \end{equation}
    Kde prv√Ω v√Ωraz $x$ patr√≠ do nekoneƒçnej spoƒç√≠tateƒænej mno≈æiny $\mathcal{X}={x,y,z,\dots}$
premenn√Ωch.
\end{theorem}
    Jednotliv√© v√Ωrazy maj√∫ nasledovn√Ω v√Ωznam:
\begin{align*}
     x          & \textrm{ - je premennou }\\
     t u        & \textrm{ - je aplik√°ciou v√Ωrazu $t$ s argumentom $u$ }\\
    \lambda x.t & \textrm{ - je abstrakciou $t$ nad $x$ }
\end{align*}
    Premenn√° $x$ sa vo v√Ωraze $\lambda x . t$ via≈æe na v√Ωraz $t$. O premennej potom
$x$ hovor√≠me ≈æe je viazan√° inak je voƒæn√°.

\begin{center}
    \begin{align*}
        VP(x) &= {x} \\
        VP(\lambda x.t) &= VP(t)  \setminus \{x\} \\
        VP(t v) &= VP(t) \cup VP(v)
    \end{align*}
\end{center}
    Aplik√°cia $\lambda$-v√Ωrazov je implicitne aplikovan√° zƒæava.
    Precedencia aplik√°cie je vy≈°≈°ia ako u abstrakcie.
\begin{equation*}
    \lambda x . t x = \lambda x . (t x)
\end{equation*}
    Abstrakciu viacer√Ωch argumentov je mo≈æn√© prep√≠sa≈• do tvaru po sebe id√∫cich
abstrakci√≠ s jednotliv√Ωmi argumentami.
\begin{equation*}
    \lambda x y z . t = \lambda x . \lambda y . \lambda z . t
\end{equation*}
    Pr√≠kladmi $\lambda$-v√Ωrazov m√¥≈æu by≈•:
\begin{align*}
    & t x                             \\
    & (\lambda y . \lambda x . t y )) \\
    & (\lambda y.y x) (\lambda x . x) \\
\end{align*}
\begin{theorem}
    O substut√≠cii hovor√≠me pri nahraden√≠ jednej premennej druhou.
    \begin{equation}
        t [ y / x ]
    \end{equation}
\end{theorem}

    Z doteraz uveden√Ωch v√Ωrazov n√°m v√Ωpoƒçet ƒçiastoƒçne pripom√≠nala len aplik√°cia na
jednoduch√Ω v√Ωraz.
    Ak za v√Ωraz dosad√≠me jednoduch√∫ abstrakciu, aplik√°ciu tvor√≠ nahradenie
viazanej premennej vo v√Ωraze abstrakcie za aplikovan√∫ premenn√∫.
    Tento √∫kon n√°m zjednodu≈°uje v√Ωraz na jednoduch√∫ aplik√°ciu.
    Toto zjednodu≈°ovanie sa vol√° $\beta$-redukciou.
    Od komplikovanej≈°√≠ch v√Ωrazov sa tak dost√°vame k jednoduch≈°√≠m predstavuj√∫cimi
v√Ωsledky v√Ωpoƒçtu.
    $\beta$-redukcia predstavuje postupnos≈• v ktorej aplikujeme pravidl√°
aplik√°cii.
    Form√°lne je $\beta$-redukcia definovan√° aplikovan√Ωm t√Ωchto pravidiel.

\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda x.t)u \to_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{\lambda}$)]{(\lambda x.t)u \rightarrow_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{l}$)]{t u \rightarrow_{\beta} t' u}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{u \to_{\beta} u'}
        \infer1[($\beta_{r}$)]{t u \rightarrow_{\beta} t u'}
    \end{prooftree}
\end{minipage}
\vskip 0.2in


% TODO vymysliet iny strom, tento je prevzaty
TU TREBA VYMYSLIET INY STROM
\begin{equation}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda y.y)x \to_{\beta} x}
        \infer1[($\beta_{l}$)]{(\lambda y.y)xz \to_{\beta} xz}
        \infer1[($\beta_{\alpha}$)]{\lambda x.(\lambda y.y)xz \to_{\beta} \lambda x . xz}
    \end{prooftree}
\end{equation}
    Pre lep≈°iu predstavu uv√°dzame komplikovanej≈°ie pr√≠klady ktor√Ωmi je mo≈æn√©
zak√≥dova≈• prirodzen√© ƒç√≠sla a jednoduch√∫ podmienku z programovania.
\begin{theorem}
    Definujme rekurziu volania funkcie nasledovne
    \begin{align*}
        f^{0}x &= x \\
        f^{n}x &= f(f^{n-1}x) \\
    \end{align*}
    Potom Churchove ƒç√≠slo $c_{n}$ je $\lambda$-v√Ωraz
    \begin{equation*}
        c_{n} = \lambda s . \lambda z . s^{n} (z)
    \end{equation*}
\end{theorem}
    Prirodzen√© ƒç√≠sla je potom mo≈æn√© definova≈•
\begin{align*}
    0 &= \lambda f x . x \\
    1 &= \lambda f x . f x \\
    1 &= \lambda f x . f (f x) \\
    2 &= \lambda f x . f ( f (f x))
\end{align*}
\begin{align*}
    nasledovnik(n) &=           (\lambda n f x .  f( n f x ))(\lambda f x . f^{n} x) \\
                   &\to_{\beta} \lambda f x . f (( \lambda f x . f^{n} x ) f x)      \\
                   &\to_{\beta} \lambda f x . f (( \lambda x . f^{n} x) x)           \\
                   &\to_{\beta} \lambda f x . f (f^{n} x)                            \\
                   &=           \lambda f x . f^{n+1} x                              \\
                   &= n + 1
\end{align*}
    Oper√°ciu sƒç√≠tania je potom mo≈æn√© vykona≈• pomocou nasleduj√∫ceho v√Ωrazu
\begin{equation*}
    f_{+} = \lambda x. \lambda y. \lambda s. \lambda z. x s (y s z)
\end{equation*}
    Pred vytvoren√≠m v√Ωrazu ktor√Ω predstavuje podmienku si potrebujeme zak√≥dova≈•
booleovsk√© hodnoty:
    \begin{align*}
        True &= \lambda x y . x \\
        False &= \lambda x y . y
    \end{align*}
    Podmienku potom predstavuje nasleduj√∫ci v√Ωraz, na ktor√Ω potom aplikujeme $\lambda$-v√Ωraz
predstavuj√∫ci logick√∫ podmienku.
\begin{align*}
    if = \lambda b x y . b x y
\end{align*}
    Jednotliv√© vetvy v√Ωpoƒçtu potom predstavuj√∫ ƒèal≈°ie dva v√Ωrazy aplikovan√© na cel√Ω
v√Ωraz podmienky a v√Ωrazu.
    Po aplik√°cii v√Ωrazov $t,u$ cez $\beta$-redukcie dost√°vame na konci v√Ωraz $t$
v pr√≠pade pravdiv√©ho vyhodnotenia a $u$ respekt√≠ve $t$ v pr√≠pade nepravdiv√©ho.

\begin{align*}
    if \textrm{ True } t u = (\lambda bxy.bxy)(\lambda xy.x) t u & \to_{\beta} (\lambda xy.(\lambda xy.x)xy)tu \\
                                                     & \to_{\beta} (\lambda y.( \lambda xy.x)ty)u \\
                                                     & \to_{\beta} (\lambda xy.x)tu \\
                                                     & \to_{\beta} (\lambda y.t)u \\
                                                     & \to_{\beta} t
\end{align*}

\section{Typovo jednoduch√Ω $\lambda$-calculus}
    Typov√Ω jednoduch√Ω $\lambda$-kalkulus je roz≈°√≠ren√≠m o jednoduch√© typy ktor√©
priraƒèujeme $\lambda$-v√Ωrazom.
    V√Ωraz $t : T$ tak m√¥≈æeme interpretova≈• sp√¥sobom "$t$ patr√≠ mno≈æine $T$" alebo
z v√Ωpoƒçtov√©ho "v√Ωsledkom v√Ωrazu $t$ je typ $T$". Z praktick√©ho hƒæadiska sa s typmi
stret√°vame v staticky typov√Ωch programovac√≠ch jazykoch kde n√°m zaruƒçuj√∫ ≈æe typovo
spr√°vny v√Ωsledok.
\begin{theorem}
    Majme spoƒç√≠tateƒæn√∫ mno≈æinu $U$ obsahuj√∫cu typov√© premenn√©. Jednoduch√© typy
    s√∫ potom generovan√© gramatikou
    \begin{equation*}
        A,B ::= U | (A \to B)
    \end{equation*}
\end{theorem}
    Teda okrem jednoduch√Ωch typov s√∫ typmi aj funkcie medzi nimi.
    Precedencia zlo≈æenia funkci√≠ typov je zƒæava $A \to ( A  \to B )$. 
    Mno≈æinu tvoriacu premenn√© ktor√Ωm s√∫ priraden√© typy naz√Ωvame kontextom.
\begin{theorem}
    Kontextom je:
    \begin{equation*}
        { x_{1} : \tau_{1}, \dots, x_{n} : \tau_{n} }
    \end{equation*}
    kde $\tau_{1}, \dots, \tau_{n} \in \Pi$ a $x_{1}, \dots , x_{n} \in$
    Obor kontextu je mno≈æina obsahuj√∫ca
    \begin{equation*}
        domain(\Gamma) = { x_{1}, \dots, x_{n} }
    \end{equation*}
    Koobor kontextu je mno≈æina obsahuj√∫ca
    \begin{equation*}
        range( \Gamma ) = { \tau \in \Pi  | (x : \tau ) \in \Gamma }
    \end{equation*}
\end{theorem}
    Pr√≠klady jednoduch√Ωch typov generovan√© gramatikou.
\begin{itemize}
    \item $\vdash \lambda x.x : \sigma \to \sigma$
    \item $\vdash \lambda x. \lambda y.x : \sigma \to \tau \to \sigma$
    \item $\vdash \lambda x. \lambda y. \lambda z.x z (y z): (\sigma \to \tau \to \rho) \to (\rho \to \tau) \to \sigma \to \rho$
\end{itemize}

    V√Ωraz $t$ je typu $A$ ak v kontexte $\Gamma$ je derivovateƒæn√° pomocou
postupnosti nasleduj√∫cich pravidiel:

\begin{center}
    \begin{prooftree}
        \infer0[$(ax)$]{\Gamma \vdash x : \Gamma(x)}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma , x : A \vdash t : B }
        \infer1[$(\overset{I}{\rightarrow})$]{\Gamma \lambda x^{A}.t : A \to B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash t : A \to B }
        \hypo{\Gamma \vdash u : A }
        \infer2[$(\overset{E}{\rightarrow})$]{\Gamma \vdash t u : B}
    \end{prooftree}
\end{minipage}


\begin{itemize}
    \item $(ax)$: v kontexte $x$ je typu $A$
    \item $(\overset{I}{\rightarrow})$: ak je $x$ typu $A$, $t$ je typu B, potom
        funkcia $\lambda x.t$ ktor√° asociuje $x$ $t$ je typu $A \to B$
        \item $(\overset{E}{\rightarrow})$: dan√° je funkcia $t$ je typu $A \to B$
        a argument $u$ je typu $A$, vysledok aplik√°cia $t u$ je typu $B$
\end{itemize}

Pr√≠klad odvodenia typu.

\section{Curry-Howardov izomorfizmus}

    V √∫vode kapitoly sme popisovali kon≈°truktivistick√Ω pr√≠stup ktor√Ω hovoril
o nutnosti skon≈°truova≈• objekt pre d√¥kaz existencie.
    Teda ak chceme dok√°za≈• nejak√© tvrdenie potom ho mus√≠me zostroji≈• z mno≈æiny
predpokladov a axi√≥m.
    \emph{Curry} s \emph{Howard} si v≈°imli ≈æe zostrojovanie d√¥kazu pripom√≠na v√Ωpoƒçet.
    Pre d√¥kaz implik√°cie $a implies b$ mus√≠me uk√°za≈• na z√°klade predpokladu $a$
d√¥sledok $b$ v kon≈°truktivizme zostroji≈• objekt $b$ z objektu $a$ a
z v√Ωpoƒçtov√©ho hƒæadiska zostroji≈• funkciu s v√Ωstupom $b$ na z√°klade vstupu $a$.

    Pri predstaven√≠ jednoduch√Ωch typov sme vraveli o mo≈ænosti interpret√°cie v√Ωrazu
$t : T$ ako $t$ patr√≠ do nejakej mno≈æiny $T$.
    Z kon≈°trukt√≠vneho pohƒæadu sme o logick√Ωch tvrdeniach hovorili ako o objektoch
ktor√© maj√∫ svoje vymedzenie z logick√©ho hƒæadiska.
    V tomto zmysle z mno≈æinov√©ho hƒæadiska prepojenie medzi typov√Ωm $\lambda$-kalkulusom
a logikou prepojenie zn√°zornen√© v nasleduj√∫cej tabuƒæke.
\begin{center}
    \begin{tabular}{ c c }
        Logika &                Typovo jednoduch√Ω $\lambda$ kalkulus \\
        \hline
        tvrdenia                & typy \\
        d√¥kaz tvrdenia $T$      & $\lambda$-v√Ωraz $t$ typu $T$ \\
        $T \implies P$          & typ $T \to P$ \\
        $T \wedge P$            & typ $T \times P$
    \end{tabular}
\end{center}
    Posledn√Ω pr√≠klad tvor√≠ kos√∫ƒçinov√Ω typ ktor√Ω je usporiadanou dvojicou dvoch typov
ktor√Ω je aj priamo podporovan√Ω Lean-om.

Nasleduj√∫ci odsek potrebujem preformulova≈•:

    V sekcii o intuicionistickej logike sme zaviedli gramatiku implikaƒçn√©ho fragmetnu
intucionistickej logiky s troma dedkuƒçn√Ωmi pravidlami $(\implies_{E})$,
    $(\implies_{I})$, $(ax)$.
    V te√≥rii jednoduch√Ωch typov sme zase ukonƒçili pravidlami ktor√© odv√°dzaj√∫
typ pomocou pravidiel $(\overset{I}{\rightarrow})$, $(\overset{E}{\rightarrow})$ a $(ax)$.
    Ak d√°me do rovnosti mno≈æinu propoziƒçn√Ωch premenn√Ωch s mno≈æinou typov√Ωch premenn√Ωch.

    Z form√°lneho hƒæadiska je:
\begin{theorem}{Curry-Howard izomorfizmus}
    \begin{itemize}
        \item Ak $\Gamma \vdash M : \varphi \textrm{ potom } |\Gamma|  \vdash \varphi.$
        \item Ak $\Gamma \vdash \varphi \textrm{ potom existuje } M \in \Lambda_{\Pi}
            \textrm{ tak√© ≈æe } \Delta \vdash M : \varphi, \textrm{ kde }
            \Delta = { ( x_{\varphi} : \varphi ) | \varphi \in \Gamma }$
    \end{itemize}
\end{theorem}

\chapter{Lean dokazovac√≠ asistent}
    Lean je dokazovac√≠ asistent ktor√Ω bol vytvoren√Ω ako otvoren√Ω softv√©rov√Ω projekt
Leonardom de Mourom v Microsoft Reasearch v roku 2013.
    Jazyk sa neust√°le vyv√≠ja a moment√°lne sa nach√°dza vo ≈°tvrtej iter√°cii \cite{lean4}
zatiaƒæ ƒço komunitn√Ω projekt matematickej kni≈ænice mathlib sa st√°le vyv√≠ja v tretej
    verzii \cite{lean3} vyv√≠janej od roku 2017.
    Implement√°cia Lean-u je v jazyku C++ a jeho jadro m√° len 8000 riadkov.
    Prostredie je dostupn√© pre operaƒçn√© syst√©my Linux, Windows a MacOS.
    Interakt√≠vne prostredie pre dokazovanie je podporovan√© pre editory \emph{Emacs} a \emph{Visual Studio Code}.

    Lean podobne ako in√Ω dokazovac√≠ asistent \emph{Coq} je zalo≈æen√© na kalkuluse kon≈°trukci√≠ ktor√Ω je zov≈°eobecnen√≠m 
te√≥rie jednoduch√Ωch typov a te√≥rie z√°vislostn√Ωch typov.

    V √∫vode tejto kapitoly popisujeme interakt√≠vne prostredie a komunitn√Ω projekt
\emph{mathlib}. Opisujeme z√°kladn√∫ syntax ktor√° koren≈°ponduje s jednoduchou te√≥riou
typov a pr√≠kazmi potrebn√© pre pr√°cu s nimi. Syntax potom roz≈°irujeme o mo≈ænos≈•
tvorby defin√≠cii a pr√°cu s nimi a priestorom mien pre vytv√°ranie hierachie z pohƒæadu
organiz√°cie k√≥du.
    Pokraƒçujeme opisom sp√¥sobu tvorby d√¥kazu priamym poskytnut√≠m $\lambda$-v√Ωrazu
a interakt√≠vnou verziou v taktickom m√≥de.
    Kapitola je uzatvoren√° opisom syntaxe popisuj√∫com indukt√≠vne a jednoduch√©
≈°trukt√∫ry ktor√© tvoria tie matematick√© a ich hierarchick√© roz≈°irovanie a priradenie
do tried.

\section{Mathlib}
    Mathlib je komunitn√Ω projekt \cite{mathlib} ktor√©ho cieƒæom je centralizova≈•
matematick√∫ te√≥riu implementovan√∫ v Lean-e.
    Do projektu je mo≈æn√© jednoducho prispieva≈• po udelen√≠ privil√©gi√≠ niektor√Ωm zo
spr√°vcov repozit√°ra a odobren√≠m po≈æiadavky na zaƒçlenenie k√≥du.
    V√§ƒç≈°ina obsahu mathlibu obsahuje matematiku na vysoko≈°kolskej √∫rovni.
    V dobre p√≠sania pr√°ce je najvy≈°≈°ia hierarchia te√≥rie nasledovn√°:
\begin{lstlisting}
algebra/
category_theory/
data/
geometry/
measure_theory/
probability_theory/
algebraic_geometry/
combinatorics/
group_theory/
representation_theory/
algebraic_topology/
computability/
dynamics/
linear_algebra/
number_theory/
ring_theory/
analysis/
control/
field_theory/
logic/
order/
set_theory/
topology/
\end{lstlisting}
    V kontraste s in√Ωmi modern√Ωmi dokazovac√≠mi asistentami m√° mathlib mno≈æstvo
prispievateƒæov akademick√© vzdelanie v ƒçistej matematike \cite{mathlib_paper} ƒço
ovplyvnilo aj jeho obsah.

\section{V√Ωvojov√© prostredie}
    V na≈°om pr√≠pade sme pracovali vo v√Ωvojovom prostred√≠ \emph{Visual studio code}
v kombin√°ci√≠ s jeho leanovsk√Ωm roz≈°√≠ren√≠m ktor√© je mo≈æn√© nain≈°talova≈• cez
\emph{marketplace} Prostredie sa sklad√° z editora podporuj√∫ceho UTF-8 znaky a okno
s interakt√≠vnym v√Ωstupom reaguj√∫ce na polohu kurzora editora a kurzora poƒç√≠taƒçovej
my≈°i.
\begin{center}
    \begin{figure}[!ht]
        \centering
        \includegraphics[scale=0.25]{vscode_printscreen.png}
        \caption{V√Ωvojov√© prostredie}
    \end{figure}
\end{center}
    V pravom okne \emph{Lean infoview} je mo≈æn√© vidie≈• premenn√© s ich prisl√∫chaj√∫cimi
typmi a v pr√≠pade d√¥kazu aj formulu ktor√∫ je potrebn√© dok√°za≈• za znakom $\vdash$.
    Okrem toho poskytuje okno aj v√Ωstup zo zabudovan√Ωch pr√≠kazov prostredia
ako \emph{print} alebo \emph{reduce} ktor√© rozoberieme nesk√¥r.
    V pr√≠pade ≈æe sa nach√°dzame v taktickom m√≥de okrem zavedenia nov√Ωch predpokladov
alebo transform√°cie existuj√∫cich je mo≈æn√© vidie≈• aj zmenu cieƒæa a podcieƒæov
napr√≠klad v pr√≠pade ≈æe sme sa dostali k d√¥kazu vymenovan√≠m pr√≠padov.
\section{$\lambda$-kalkulus}
    Pred predstaven√≠m techn√≠k dokazovania je nutn√© sa obozn√°mi≈• s prvkami funkcionion√°lneho
programovania v Leane.
    V√Ωpoƒçtov√Ω model jednoduch√©ho $\lambda$-kalkulu je z programovac√≠ch paradigiem najbli≈æ≈°ie pr√°ve funkcion√°lnemu sp√¥sobu programovania.
V nasleduj√∫cej ƒçasti predstavujeme z√°klady funkcion√°lneho programovania spolu
    s typmi a n√°strojmi Lean-u na v√Ωvoj a mene≈æment priestoru mien.
\subsection{Kon≈°tanty, aplik√°cie}
    Deklar√°cia kon≈°tanty zav√°dza do syst√©mu nov√∫ deklar√°ciu bez defin√≠cie.
    Z tohto d√¥vodu sa ich pri rozvoji te√≥rie sna≈æ√≠me vyh√Ωba≈•.
    V nasleduj√∫cich pr√≠kladov budeme pracova≈• s prirodzen√Ωmi a cel√Ωmi ƒç√≠slami
ktor√Ωch ≈°trukt√∫ry s√∫ s√∫ƒças≈•ou kontextu bez nutnosti ich importova≈•.
\begin{lstlisting}
constant m : nat
\end{lstlisting}
    Hovor√≠ o deklarovan√≠ kon≈°tanty $m$ ktorej typ je \emph{nat}.
    Alternat√≠vny z√°pis pre prirodzen√© ƒç√≠slo je pomocou sekvencie $\texttt{\textbackslash}nat$
alebo $\texttt{\textbackslash}N$ ktor√∫ skonvertuje leanovsk√© roz≈°√≠renie na znak $\mathbb{N}$.
    Vstavan√Ω pr√≠kaz ktor√Ω poskytuje typ v√Ωrazu zadan√©ho na argumente je \emph{\#check}:
\begin{lstlisting}
#check m
\end{lstlisting}
    Mrie≈æka na zaƒçiatku pr√≠kazu znaƒç√≠ zabudovan√Ω pr√≠kaz.
    V tomto pr√≠pade je to trivi√°lne tak ako bola kon≈°tanta zadefinovan√° s v√Ωstupom
v informaƒçnom okne:
\begin{lstlisting}
m : ‚Ñï
\end{lstlisting}
    Pre zadefinovanie viacer√Ωch kon≈°t√°nt jedn√Ωm pr√≠kazom a nie len v tomto pr√≠pade
existuje plur√°lna verzia pr√≠kazu \emph{constants}.

    Defin√≠cia kon≈°tanty typu funkcie medzi prirodzen√Ωmi ƒç√≠slami vyzer√° nasledovne:
\begin{lstlisting}
constant f : ‚Ñï ‚Üí ‚Ñï
constant h : ‚Ñï -> ‚Ñï -> ‚Ñï
\end{lstlisting}
    Aplik√°cia funkcie sa notaƒçne podob√° aplik√°cii v $\lambda$-kalkule kde argument
jednoducho prip√≠≈°eme za funkciu:
\begin{lstlisting}
#constants m n : ‚Ñï

#check f m
#check h m
#check h m n
\end{lstlisting}
    Zatiaƒæ ƒço v prvom pr√≠pade dostaneme typ $\mathbb{N}$ v druhom pr√≠pade
$\mathbb{N} \to \mathbb{N}$ a v tre≈•om vid√≠me aplik√°ciu na funkciu kde bude v√Ωsledn√Ωm
typom znova jednoduch√Ω typ $\mathbb{N}$.
    Aplik√°cia je asociat√≠vna z ƒæavej strany a  preto je nasleduj√∫ci v√Ωraz potrebn√© 
uz√°tvorkova≈• napravo inak dost√°vame typov√∫ chybu pre funkciu $g$ ktor√° oƒçak√°va 
cel√© ƒç√≠slo a nie typ funkcie f.
\begin{lstlisting}
constant f : ‚Ñï ‚Üí ‚Ñ§
constant g : ‚Ñ§ ‚Üí ‚Ñï
constant a : ‚Ñï

#check g (f a)
\end{lstlisting}
    ƒå√≠seln√© kon≈°tanty m√° v leane typ $\mathbb{N}$.
\begin{lstlisting}
#check 5
#check (-5 : ‚Ñ§)
\end{lstlisting}
    Pri deklar√°cii z√°porn√©ho ƒç√≠sla je tak nutn√© u≈æ explicitne uvies≈• typ.
Nasleduj√∫ce pr√≠klady ilustruj√∫ okrem funkcie $+$ aj implicitn√∫ konverziu medzi typmi.
\begin{lstlisting}
#constants (m : ‚Ñï) (n : ‚Ñ§)

#check 1 + 2
#check m + 1
#check n + 1
#check n + m
#check m + n
\end{lstlisting}
    V pr√≠pade prv√©ho pr√≠kladu dost√°vame typ $\mathbb{N}$ pre nespracovan√Ω v√Ωraz pre
ktor√Ω by sme mohli oƒçak√°va≈• v√Ωsledok $3$.
    Pre druh√Ω a tret√≠ v√Ωraz dost√°vame typy definovan√Ωch kon≈°t√°nt.
    Pri tre≈•om v√Ωraze je vhodn√© si uvedomi≈• u≈æ implicitn√∫ konverziu prirodzen√©ho
ƒç√≠sla na cel√©.
    Konverzia je e≈°te viac zrejm√° pri ≈°tvrtom v√Ωraze kde v√Ωsledn√Ωm typom je
$\mathbb{Z}$.
    Prekvapivo z piateho v√Ωrazu dost√°vame v informaƒçnom okne chybov√Ω v√Ωstup.
    Za neschopnos≈•ou dosta≈• typ stoj√≠ nedefinovan√° konverzia z cel√Ωch do prirodzen√Ωch
ƒç√≠sel.
    Za vysvetlen√≠m stoj√≠ sp√¥sob ak√Ωm pracuje pre≈•a≈æenie infixov√©ho oper√°tora $+$
podobn√Ωm sp√¥sobom ako pre triedy v jazyku $c++$ alebo $python$. ≈†tvrt√Ω a piaty
v√Ωraz je tak mo≈æn√© prep√≠sa≈• aj do tvaru:
\begin{lstlisting}
#check n.add(m)
#check m.add(n)
\end{lstlisting}
    Preto≈æe znak $+$ je pre≈•a≈æen√≠m funkcie \emph{add} nad ≈°trukt√∫rou mno≈æiny dan√Ωch
ƒç√≠sel.
\subsection{Funkcie}
    V predch√°dzaj√∫cej sekcii sme si uk√°zali explicitn√Ω typ ktor√Ω bol funkciou prirodzen√Ωmi
ƒç√≠slami ktor√Ω bol typu $\mathbb{N} \to \mathbb{N}$ alebo $\mathbb{N} \to \mathbb{N} \to \mathbb{N}$.
V Lean-e definujeme anonymn√∫ funkciu alebo $\lambda$-v√Ωraz nasledovne.
\begin{lstlisting}
#check Œª x, x + x
\end{lstlisting}
    Typ argumentu x je odvoden√Ω z v√Ωrazu ktor√Ω na funkciu aplikujeme.
    Pre korektn√∫ aplik√°ciu mus√≠ ma≈• typ aj definovan√∫ funkciu sƒç√≠tania.
    Ak by sme chceli obmedzi≈• argument len na konkr√©tny typ rob√≠me to podobne ako
pri definovan√≠ kon≈°tanty. Potom aplik√°cia
\begin{lstlisting}
#check (Œª (x : ‚Ñï), x + x) (m : ‚Ñ§)
\end{lstlisting}
je u≈æ typovou chybou pri ktorej n√°m informaƒçn√© okno hl√°si
\begin{lstlisting}
type mismatch at application
  (Œª (x : ‚Ñï), x + x) m
term
  m
has type
  ‚Ñ§
but is expected to have type
  ‚Ñï
\end{lstlisting}
    Uvedieme si zop√°r pr√≠kladov v√Ωpoƒçtovo ekvivalentn√Ωch funkcii obvodu obdƒ∫≈ænika typu
$\mathbb{N} \to \mathbb{N} \to \mathbb{N}$.
\begin{lstlisting}
#check Œª (x : ‚Ñï) (y : ‚Ñï), (x + x) + (y + y)
#check Œª (x y : ‚Ñï), (x + x) + (y + y)
#check Œª (x : ‚Ñï), Œª (y : ‚Ñï), (x + x) + (y + y)
\end{lstlisting}
    V≈°etky tri pr√≠klady s√∫ ekvivalentn√© z pohƒæadu typov a predstavuj√∫ in√Ω sp√¥sob
z√°pisu.
    Funkcia v ktorej neuvedieme typ argumentu je polymorfnou.
\begin{lstlisting}
#check Œª x y, x + x + y + y
\end{lstlisting}

    V pr√≠pade ≈æe by sme chceli z√≠ska≈• hodnotu z v√Ωrazu pou≈æijeme pr√≠kaz \emph{\#eval},
alebo \emph{\#reduce}. \emph{Reduce} na rozdiel od \emph{eval} pri vykon√°van√≠ pou≈æ√≠va
jadro na z√≠skanie typu a je tak menej efekt√≠vnym.
\begin{lstlisting}
#eval (Œª (x y : ‚Ñï), (x + x) + (y + y)) 2 3
\end{lstlisting}
    Aplik√°cia n√°m d√°va v√Ωsledok $10$ ktor√Ω je oƒçak√°vanou hodnotou.

    Pre pomenovanie alebo zadefinovanie takejto funkcie pou≈æ√≠vame pr√≠kaz \emph{def}
ktorej tvar v najjednoduch≈°ej podobe m√° tvar:
\begin{lstlisting}
def meno_definicie (argument_1 : typ) (argument_n : typ) :
    typ_navratovej_hodnoty 
:=
    telo funkcie
\end{lstlisting}
V pr√≠pade defin√≠cie ≈°tvorca aj s jeho v√Ωpoƒçtom
\begin{lstlisting}
def obvod_stvorca (x : ‚Ñï) (y : ‚Ñï) : ‚Ñï := x + x + y + y

#eval obsah_stvorca 3 5
\end{lstlisting}

    Kƒæ√∫ƒçov√© slovo \emph{def} ktor√© pou≈æ√≠vame je funkƒçne bez funkƒçn√©ho roziedlu mo≈æn√©
zameni≈• za \emph{theorem}, \emph{lemma}. V pr√≠pade ≈æe chceme uvies≈• iba pr√≠klad
kde meno by p√¥sobilo nadbytoƒçne pou≈æ√≠vame slovo \emph{example}.

\subsection{Typy}
    Doteraz sme uva≈æovali len s typmi mno≈æiny prirodzen√Ωch a cel√Ωch ƒç√≠sel
ktor√© predstavuj√∫ na pozad√≠ Leanu konkr√©tne definovan√∫ ≈°trukt√∫ru.
    Typovanie v Lean-e ale podporuje zavedenie nov√©ho abstraktn√©ho typu ktor√Ω patr√≠ univerzu(universe).
    Zavedenie t√Ωchto univerz je motivovan√© probl√©mom analogick√Ωm s Russelov√Ωm paradoxom
a teda ƒçi mno≈æina v≈°etk√Ωch mno≈æ√≠n obsahuje sam√∫ seba.
    V te√≥rii typov sa jedn√° o Girardov paradox.
    Hierarchia t√Ωchto univerz je usporiadan√° od 0 ƒço je univerzum tvoriace najjednoduch≈°ie
typy tak≈æe \emph{Type} alebo aj \emph{Type 0} je potom typom \emph{Type 1} ktor√Ω
je typom \emph{Type 2}.

    ≈†peci√°lne postavenie v typoch maj√∫ tvrdenia oznaƒçujeme \emph{Prop} ktor√©ho
typom s√∫ v≈°etky d√¥kazy.
    S√∫ postaven√© v hierachii oddelen√© na najni≈æ≈°ej √∫rovni a teda \emph{Prop} je 
typu \emph{Type}.
    Univerzum do ktor√©ho patr√≠ \emph{Prop} oznaƒçujeme \emph{Sort} ƒço je len 
alias.
Plat√≠ vz≈•ah \emph{Sort u + 1} = \emph{Type u}.

V tejto pr√°ci a ani vo v√§ƒç≈°ine pr√°ce s Leanom nie je potrebn√© vyu≈æ√≠va≈• hierachiu
    typov sofistikovanej≈°√≠m ako prezentovan√Ωm sp√¥sobom.
\begin{lstlisting}
universe u v

constant (a : Type u) (b : Type v)
\end{lstlisting}
Druhou mo≈ænos≈•ou je vyu≈æi≈• substituƒçn√∫ syntax kde \emph{*} znamen√° pre ƒæubovoƒæn√© univerzum
a v pr√≠pade \emph{\_} nech√°me doplni≈• typ automaticky Lean-om.
\begin{lstlisting}
constant f : Type _ ‚Üí Type _
constant g : Type

#check f g
\end{lstlisting}
    Kontrola typu aplik√°cie n√°m vyp√≠≈°e typ \emph{Type u\_1} ƒço je sp√¥sob Lean-u oznaƒçova≈•
e≈°te neurƒçen√Ω typ bez konkr√©tneho univerza.
\subsection{Premenn√©}
    V pr√≠pade ≈æe sa sna≈æ√≠me definova≈• viacero funkci√≠ s rovnak√Ωmi argumentami alebo
pou≈æ√≠va≈• objekt ktor√©ho typ je vyjadren√Ω komplikovanej≈°√≠m z√°pisom je vhodn√© si
z√°pis zjednodu≈°i≈• premenn√Ωmi.
    Z inak na pohƒæad komplikovan√©ho z√°pisu
\begin{lstlisting}
universes u v

def kompozicia (Œ± : Type u) (Œ≤ : Type v) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (x : Œ±) :
    Œ±
:=
    g (f x)
\end{lstlisting}
    tak dost√°vame.
    Premenn√© vstupuj√∫ do predpokladov defin√≠cii len tam kde s√∫ pou≈æit√© v jej tele.
\begin{lstlisting}
universes u v z

variable Œ± : Type u
variable Œ≤ : Type v
variable Œ≥ : Type z

def kompozicia (x : Œ±) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) : Œ± := g (f x)
\end{lstlisting}
    Vstupn√© argumenty dokonca m√¥≈æeme vynecha≈• √∫plne, v niektor√Ωch pr√≠padoch to ale
m√¥≈æe by≈• kontraprodukt√≠vne z d√¥vodu orient√°cie pri rozsiahlych z√°pisoch v editore.
\begin{lstlisting}
variables (f : Œ± ‚Üí Œ≤)
          (g : Œ≤ ‚Üí Œ≥)

def kompozicia : Œ± := g (f x)
\end{lstlisting}
Pre doplnenie dod√°vame ≈æe nie je nutn√© ani definova≈• n√°vratov√Ω typ $\alpha$
    respekt√≠ve $\beta$, explicitn√© urƒçenie n√°vratov√©ho typu je ale vhodn√© nie len
    pre ƒçitateƒæa ale aj pre overenie spr√°vnosti v√Ωsledn√©ho typu.
\subsection{Kontext, priestor mien}
    Pre ovl√°danie menn√©ho priestoru a kontextu existuj√∫ v Lean-e r√¥zne mechanizmy
z ktor√Ωch si pop√≠≈°eme len tie najd√¥le≈æitej≈°ie.
    Najjednoduch≈°√≠m je s√∫bor, ktor√©ho defin√≠cie, kon≈°tanty a premenn√© vstupuj√∫ do
kontextu pri deklar√°cii a na konci s√∫boru zanikn√∫.
    Import obsahu in√Ωch s√∫borov sa rob√≠ jednoduch√Ωm pr√≠kazom \emph{import} ktor√Ω
mus√≠ by≈• deklarovan√Ω na zaƒçiatku s√∫boru. V s√∫borovej hierachii sa potom od najvy≈°≈°ej
√∫rovne v jednej z vyhƒæad√°van√Ωch ciest vnor√≠me cez bodku.
\begin{lstlisting}
import order.lattice
\end{lstlisting}
    Pr√≠kaz sa pok√∫si n√°js≈• prieƒçinok \emph{order} so s√∫borom \emph{lattice.lean}.
    V aktu√°lnej verzii Lean-u v ƒçase p√≠sania pr√°ce sa d√° zisti≈• zoznam prehƒæad√°van√Ωch
ciest prep√≠naƒçom \emph{path} priamo programu \emph{lean}.

    Deklar√°cie premenn√Ωch definovan√© v argumetnoch defin√≠cie prepisuj√∫ vonkaj≈°√≠ kontext.
    V pr√≠pade ≈æeby sme chceli rozdeli≈• kontext s√∫boru na men≈°ie sekcie jednoduch√Ωm
n√°strojom je dvojica \emph{section nazov\_sekcie}, \emph{end nazov\_sekcie}.
\begin{lstlisting}
section prirodzene_cisla
  variable Œ± : ‚Ñï
end prirodzene_cisla

section cele_cisla
  variable Œ± : ‚Ñ§
end cele_cisla
\end{lstlisting}
    Pou≈æ√≠vanej≈°√≠m je menn√Ω priestor \emph{namespace nazov} ktor√Ω po zadefinovan√≠ pon√∫ka
mo≈ænos≈• op√§tovn√©ho zavedenia kontextu a vnorenie podobne ako rovnomenn√Ω mechanizmus
v jazyku C++.
\begin{lstlisting}
universe u

namespace skryty

  variable (Œ± : Type u)
  namespace priestor
    def identita (a : Œ±) : Œ± := a
  end priestor
end skryty

#check skryty.priestor.identita

open skryty.priestor

#check identita
\end{lstlisting}
\section{Dokazovanie}

    K dokazovaniu v Leane je mo≈æn√© pristupova≈• viacer√Ωmi sp√¥sobmi.
    Po poskytnut√≠ d√¥kazu u≈æ vn√∫torne Lean-u nez√°le≈æ√≠ na sp√¥sobe ak√Ωm bolo tvrdenie
dok√°zan√©.
    Prv√Ωm sp√¥sobom je priamoƒçiara kon≈°trukcia typu pomocou funkci√≠.
    Druh√Ωm sp√¥sobom je sp√§tn√© dokazovanie ktor√© vyu≈æ√≠va taktick√Ω m√≥d za pomoci
sady pr√≠kazov upravuj√∫cich cieƒæ a s pomocou poloautomatiz√°cie.
    V leanovskej komunite je preferovan√Ω pr√°ve druh√Ω sp√¥sob hoci pre jednoducho
dok√°zateƒæn√© tvrdenia staƒç√≠ a je vyu≈æ√≠van√° aj dopredn√° verzia.

\subsection{Dopredn√© dokazovanie}
    D√¥kaz zostaven√Ω len z $\lambda$-funkci√≠ ktor√© transformuj√∫ argumenty
na v√Ωsledn√Ω typ je pri zlo≈æitej≈°√≠ch d√¥kazoch ≈•a≈æko ƒçitateƒæn√Ω.
    Pre lep≈°iu ƒçitateƒænos≈• poskytuje Lean n√°stroje ktor√© sa sna≈æia kon≈°truova≈• d√¥kazy tak
aby boli ƒçitateƒæn√© ako tie klasick√©.
\begin{lstlisting}
variables p d : Prop

def plati_predpoklad : p ‚Üí d ‚Üí p := Œª hp : p, Œª hd : d, hp
\end{lstlisting}
    Predch√°dzaj√∫ci pr√≠klad je mo≈æn√© prep√≠sa≈• do ƒçitateƒænej≈°ej verzie
\begin{lstlisting}
def plati_predpoklad : p ‚Üí d ‚Üí p :=
  assume hp : p,
  assume hd : d,
  show p, from hp
\end{lstlisting}
Pre lep≈°iu predstavu toho ƒço sa deje na pozad√≠ Lean poskytuje v√Ωstup:
\begin{lstlisting}
pq: Prop
hp: p
hq: q
‚ä¢ p
\end{lstlisting}
    Funkcie s√∫ asociat√≠vne zprava $p \to ( d \to p )$.
    Tvrdenie hovor√≠ "ak plat√≠ $p$, potom z $d$ vypl√Ωva $p$".
\begin{itemize}
    \item Predpokladajme hp,
    \item a predpokladajme hd,
    \item potom vieme uk√°za≈• ≈æe plat√≠ p z predpokladu hp.
\end{itemize}
    O ƒçosi zlo≈æitej≈°√≠m pr√≠kladom je tvrdenie ≈æe ak plat√≠ $p$ konjukcia $q$ tak potom
plat√≠ $q$ konjukcia $p$.
\begin{lstlisting}
def symetria_konjukcie : p ‚àß q ‚Üí q ‚àß p :=
  assume hpq : p ‚àß q,
    have hp   : p     := and.left  hpq,
    have hq   : q     := and.right hpq,
    have hqp  : q ‚àß p := and.intro hq hp,
  show q ‚àß p, from hqp
\end{lstlisting}
    Konjukciu v editore je mo≈æn√© nap√≠sa≈• cez $\texttt{\textbackslash}and$.
    Ak sa pozrieme na typ konjukcie a funkci√≠ ktor√© sme dostali cez pr√≠kaz \emph{check}
dostaneme v√Ωstup:
\begin{lstlisting}
and : Prop ‚Üí Prop ‚Üí Prop
and.left : ?M_1 ‚àß ?M_2 ‚Üí ?M_1
and.right : ?M_1 ‚àß ?M_2 ‚Üí ?M_2
and.intro : ?M_1 ‚Üí ?M_2 ‚Üí ?M_1 ‚àß ?M_2
\end{lstlisting}
    Toto intuit√≠vne koren≈°ponduje s t√Ωm ƒço od t√Ωchto funkci√≠ oƒçak√°vame.
    Tento d√¥kaz je roz≈°√≠ren√Ω o pr√≠kaz \emph{have} ktor√Ω vytv√°ra predpoklad z existuj√∫cich.
    V poslednej f√°ze d√¥kazu je interakt√≠vny v√Ωstup:
\begin{lstlisting}
pq: Prop
hpq: p ‚àß q
hp: p
hq: q
hqp: q ‚àß p
‚ä¢ q ‚àß p
\end{lstlisting}

\subsection{Sp√§tn√© dokazovanie}

    V doprednom dokazovan√≠ sme sa sna≈æili transformova≈• predpoklady tak aby na konci
bol v√Ωsledkom d√¥sledok.
    Ako evokuje n√°zov v sp√§tnom dokazovan√≠ sa sna≈æ√≠me transformova≈• cieƒæ tak aby sme
sa dostali k jedn√©mu z predpokladov.
    Pre tento √∫ƒçel existuje v Lean-e ≈°peci√°lny sp√¥sob dokazovania ktor√Ω naz√Ωvame taktick√Ω
m√≥d.
    Na rozdiel od dopredn√©ho dokazovania je nutn√© ovl√°da≈• v√§ƒç≈°iu sadu pr√≠kazov ktor√©
priamo transformuj√∫ cieƒæ.
    Dokazovanie je tak u≈æ≈°ie prepojen√© s interakt√≠vnym prostred√≠m a pripom√≠na tak hru.
    ƒéal≈°ou v√Ωhodou tohto dokazovania je mo≈ænos≈• vyu≈æitie umelej inteligencie pri vyhƒæadan√≠
d√¥kazu.
    Tak√Ωto pr√≠stup je obzvl√°≈°≈• u≈æitoƒçn√Ω napr√≠klad v pr√≠pade ≈æe mus√≠me dok√°za≈• identitu
ktorej d√¥kaz je pr√°cny, a tvor√≠ ho veƒæa za sebou nasleduj√∫cich vyu≈æit√≠ in√Ωch
ident√≠t ako napr√≠klad vyu≈æitie komutativity alebo asociativity.
    U≈æ≈°ie prepojenie s prostred√≠m a automatiz√°cia vyhƒæadania d√¥kazu tohto m√≥du ale
ide na √∫kor priamej ƒçitateƒænosti.
    Pre √∫plnos≈• dopƒ∫≈àame ≈æe v taktickom m√≥de nie je nutn√© transformova≈• cieƒæ a je mo≈æn√©
vyu≈æi≈• aj kon≈°trukcie dopredn√©ho d√¥kazu.

    Pre dokazovanie v taktickom m√≥de pou≈æ√≠vame kon≈°trukciu ktor√° je ohraniƒçen√°
kƒæ√∫ƒçov√Ωmi slovami \emph{begin} a \emph{end}.

\begin{lstlisting}
def symetria_konjukcie : p ‚àß q ‚Üí q ‚àß p :=
  begin
    intro h,
    cases h with p q,
    split,
    exact q,
    exact p
  end
\end{lstlisting}

    D√¥kaz zaƒç√≠na zaveden√≠m predpokladu z implik√°cie k ostatn√Ωm o ktor√Ωch tvrd√≠me
≈æe s√∫ pravdiv√© pr√≠kazom \emph{intro} a rozdelen√≠m konjukcie pr√≠kazom \emph{cases}
s argumentom zavedenej konjukcie a ich explicitn√Ωm pomenovan√≠m.
    V√Ωstup v informaƒçnom okne potom obsahuje.

\begin{lstlisting}
pq: Prop
p: p
q: q
‚ä¢ q ‚àß p
\end{lstlisting}

Pr√≠kazom \emph{split} potom rozdel√≠me cieƒæ na podciele kde sa sna≈æ√≠me dok√°za≈•
ƒæav√∫ a prav√∫ stranu ktor√∫ vid√≠me v informaƒçnom okne ako:

\begin{lstlisting}
2 goals
pq: Prop
h_left: p
h_right: q
‚ä¢ q
pq: Prop
h_left: p
h_right: q
‚ä¢ p
\end{lstlisting}

D√¥kaz potom uzatvor√≠me pr√≠kazom \emph{exact} ktor√Ω uk√°≈æe na jeden z predpokladov
    s rovnak√Ωm typom ako cieƒæ.

\section{Abstraktn√© ≈°trukt√∫ry v Lean-e}
    V matematike a tak isto aj v programovan√≠ sa ƒçasto vyskytuj√∫ objekty
nad ktor√Ωmi je mo≈æn√© vykon√°va≈• oper√°cie bez ohƒæadu na ich obsah pri splnen√≠
urƒçit√Ωch podmienok.
    V matematike hovor√≠me o ≈°trukt√∫rach, ktor√© maj√∫ striktn√∫ defin√≠ciu v programovan√≠
sa d√° voƒæne hovori≈• o triedach.
    Matematick√© ≈°trukt√∫ry v Lean-e su navrhovan√© pr√°ve pomocou mechanizmu tried,
priƒçom defin√≠cii triedy zodpoved√° ≈°trukt√∫ra spƒ∫≈àaj√∫ca z defin√≠ce vypl√Ωvaj√∫ce podmienky.
    Potom in≈°tanciou triedy m√¥≈æe by≈• znova ≈°trukt√∫ra ktor√° je definovan√° na u≈æ≈°ej mno≈æine
znova spƒ∫≈àaj√∫cej podmienky, pr√≠kladom je vz≈•ah grupy a podgrupy alebo
priestoru a podpriestoru.
    Druh hierachie potom tvor√≠ mo≈ænos≈• roz≈°irovania tried pri ktor√Ωch spƒ∫≈àa okrem
podmienok p√¥vodnej ≈°trukt√∫ry aj ƒèal≈°ie ktor√© ju obohacuj√∫.
    Pr√≠kladom vyu≈æitia m√¥≈æe by≈• pologrupa ktor√° je mno≈æinou s asociat√≠vnou oper√°ciou
a monoidom, ƒço je pologrupa s jednotkou.
\subsection{Indukt√≠vne ≈°trukt√∫ry}

    Indukt√≠vne ≈°trukt√∫ry predstavuj√∫ notaƒçne siln√Ω n√°stroj pre defin√≠ciu objektov
medzi ktor√Ωmi je jednoduch√° asocio√°cia.
    Jednoduch√Ωm pr√≠kladom je zoznam kde asoci√°ciou medzi prvkami tvor√≠ vz≈•ah
usporiadania.
    Komplikovanej≈°√≠ klasick√Ω pr√≠klad tvoria stromov√© ≈°trukt√∫ry tvoriace uzly
s viacer√Ωmi nasledovn√≠kmi.
    V matematike sa s indukciou stret√°vame pri defin√≠cii prirodzen√Ωch ƒç√≠sel
cez Peanove axi√≥my.
    Dve z t√Ωchto axi√≥m hovoria:
\begin{itemize}
    \item 0 je ƒç√≠slo
    \item Ak $a$ je ƒç√≠slo potom nasledovn√≠k $a$ je tie≈æ ƒç√≠slo.
\end{itemize}
    Prv√© pravidlo hovor√≠ o z√°kladnom pr√≠pade, v pr√≠pade zoznamu alebo stromu pr√°zdny
zoznam respekt√≠ve strom.
    Implement√°cia prirodzen√Ωch ƒç√≠sel pomocou indukƒçnej ≈°trukt√∫ry by mohla vyzera≈•
nasledovne:
\begin{lstlisting}
inductive prirodzene : Type
  | nula        : prirodzene
  | nasledovnik : prirodzene ‚Üí prirodzene
\end{lstlisting}
    Za kƒæ√∫ƒçov√Ωm slovom inductive nasleduje n√°zov a sada kon≈°truktorov s n√°vratov√Ωmi
typmi.
    U≈æ z n√°zvu vypl√Ωva s√∫vislos≈• s d√¥kazom s matematickou indukciou kde platnos≈•
nejak√©ho tvrdenia $P(n)$ pre v≈°etky prirodzen√© ƒç√≠sla sa dokazuje pre
\begin{itemize}
    \item $P(0)$, t.j. z√°kladn√Ω pr√≠pad
    \item $\forall n \in \mathbb{N}, P(n) \implies P(n+1)$, indukƒçn√Ω krok
\end{itemize}
    Pre tento typ d√¥kazu existuje v Leane v taktickom m√≥de pr√≠kaz \emph{induction}.
\begin{lstlisting}
example : 5 * n = 4 * n + n :=
    begin
      induction n with d hd,
      ...
    end
\end{lstlisting}
    Po pr√≠kaze induction sa informaƒçnom nach√°dzaj√∫ dva ciele pre obe kon≈°truktory
prirodzen√Ωch ƒç√≠sel \emph{nat.zero} a \emph{nat.succ} podobne ako v na≈°ej uvedenej
≈°trukt√∫re a z√°kladn√©mu pr√≠padu a tvrdeniam matematickej indukcie dokazuj√∫cej platnos≈•
$P$.
\begin{lstlisting}
case nat.zero
‚ä¢ 5 * 0 = 4 * 0 + 0

case nat.succ
d: ‚Ñï
hd: 5 * d = 4 * d + d
‚ä¢ 5 * d.succ = 4 * d.succ + d.succ
\end{lstlisting}

    V pr√≠klade ktor√Ω sme uviedli s√∫ znamienka $+$ a $*$ ktor√© pou≈æ√≠vame
v oper√°ciach nad typom na≈°ej indukt√≠vnej ≈°trukt√∫ry.
    V√Ωsledkom oboch bin√°rnych oper√°cii je znova prirodzen√© ƒç√≠slo.
    Podƒæa predpokladov typ ktor√Ω prisl√∫cha ich defin√≠cii je
$prirodzene \to prirodzene \to prirodzene$.
    Jednou z v√Ωhod indkuƒçne definovan√Ωch ≈°trukt√∫r je jednoduchos≈• definovania
rekurz√≠vnych funkci√≠ ktor√© operuj√∫ nad t√Ωmito ≈°trukt√∫rami.
\begin{lstlisting}
variables (a b: prirodzene)

open prirodzene

def sucet : prirodzene ‚Üí prirodzene ‚Üí prirodzene
  | a    nula         := a
  | a (nasledovnik b) := nasledovnik (sucet a b)
\end{lstlisting}
    V tomto pr√≠pade znamen√° not√°cia $|$ pr√≠pad v ktorom sa sna≈æ√≠me n√°js≈• zhodu
s poskytnut√Ωm argumentom a n√°vratov√Ω typ.
    V tre≈•om pr√≠pade ide o rekurz√≠vne pravidlo ktor√© z argumentu $b$ vytvor√≠ jedo
predchodcu.
    Cel√© pravidlo potom vr√°ti nasledovn√≠ka zo s√∫ƒçtu prv√©ho argumentu a predchodcu
druh√©ho.
    Rekurzia tak pren√°≈°a vlastnos≈• nasledovania z prv√©ho na druh√Ω argument a≈æ
sa argumenty nezhoduj√∫ s prv√Ωm pravidlom a teda argument u≈æ nem√° predchodcu.
    Pre √∫plnos≈• dod√°vame aj technick√Ω detail definovania znamienka $+$ ako volania
funkcie s√∫ƒçtu:
\begin{lstlisting}
local infix ` + ` := sucet
\end{lstlisting}

\subsection{Jednoduch√© ≈°trukt√∫ry}
    V pr√≠pade ≈æe by jeden z kon≈°truktorov neobsahoval typ ktor√Ω poskytuje funkciu
medzi typmi samotnej ≈°trukt√∫ry, ide o obyƒçajn√∫ ≈°trukt√∫ru.
    Ich vyu≈æitie je najm√§ pri definovan√≠ t√Ωch matematick√Ωch a v lean-e maj√∫
≈°peci√°lnu syntax.
    V pr√≠klade uv√°dzame ekvivalentn√© sp√¥soby definovania ≈°trukt√∫r.
\begin{lstlisting}
structure vector :=
  mk :: (x y: ‚Ñù)

structure vector‚ÇÇ :=
  (x : ‚Ñù)
  (y : ‚Ñù)
\end{lstlisting}
    Vytv√°ranie objektov danej ≈°trukt√∫ry m√° explicitn√© priradzovanie prvkom
podƒæa n√°zvov v pr√≠pade jednoduch√Ωch ≈°trukt√∫r je vhodnej≈°ie priradzovanie na
z√°klade poriadia z defin√≠cie ≈°turkt√∫ry.
\begin{lstlisting}
def v‚ÇÇ : vector‚ÇÇ :=
  {
    x := 10.5,
    y := 13.7,
  }

#check (‚ü®10.5, 13.7‚ü© : vector)
\end{lstlisting}
    K jednotliv√Ωm prvkom ≈°trukt√∫ry pristupujeme cez bodku:
\begin{lstlisting}
#eval v.x
\end{lstlisting}
    tak vracia hodnotu 10.5.
    Pre modelovanie hierarchie kde jedna ≈°trukt√∫ra roz≈°iruje druh√∫ pou≈æ√≠vame
kƒæ√∫ƒçov√© slovo \emph{extends}.
    Roz≈°√≠renie na≈°ej ≈°trukt√∫ry o ƒèal≈°iu dimenziu vyzer√° nasledovne:
\begin{lstlisting}
structure vector‚ÇÉ extends vector‚ÇÇ :=
  (z : ‚Ñ§)

def ‚à®‚ÇÉ‚ÇÅ : vector‚ÇÉ :=
  { x := 1, y := 2, z := 3}
\end{lstlisting}
    V pr√≠pade ≈æe chceme vytvori≈• objekt z roz≈°√≠renej ≈°trukt√∫ry a m√°me k dispoz√≠cii
jeho podkladov√Ω je ƒçasto vyu≈æ√≠van√° not√°cia.
\begin{lstlisting}
def ‚à®‚ÇÉ‚ÇÇ : vector‚ÇÉ :=
{
    z := 10, ..v‚ÇÇ
}
\end{lstlisting}
    Z√°vislostn√© typy predstavuj√∫ mechanizmus parametriz√°cie ≈°trukt√∫r a defin√≠cii
na z√°klade poskytnut√©ho typu.
    V pr√≠pade n√°≈°ho vektora by sme t√∫to vlastnos≈• mohli vyu≈æi≈• ak by sme chceli
z√∫≈æi≈• mno≈æinu z ktorej poch√°dza n√°≈° vektora len na cel√© ƒç√≠sla.
\begin{lstlisting}
structure vector { Œ± : Type u } :=
  (x : Œ±)
  (y : Œ±)
  (z : Œ±)

def v‚ÇÅ := (‚ü®10, 13, 3‚ü© : vector)
def v‚ÇÇ := (‚ü®(-10 : ‚Ñ§), 13, 3‚ü© : vector)

#check v‚ÇÅ.z
#check v‚ÇÇ.z
\end{lstlisting}
    Pri prvej kontrole sme dostali typ $\mathbb{N}$.
    V druhom pr√≠pade je ale $z$-tov√° zlo≈æka vektora $v_{2}$ typu $\mathbb{Z}$.
    Nedostatkom uveden√©ho pr√≠kladu je ≈æe mno≈æina $\mathbb{Z}$ obsahuje
mno≈æinu $\mathbb{N}$.
    Pr√≠kladom ktor√Ω lep≈°ie ilustruje mo≈ænosti vyu≈æitia s√∫ matematick√© ≈°trukt√∫ry,
ktor√© s√∫ definovan√© na mno≈æin√°ch ktor√© m√¥≈æu obsahova≈• objekty ƒæubovoƒæn√©ho typu.
\begin{lstlisting}
variables { T : Type* } ( A : ≈°trukt√∫ra‚ÇÅ T ) ( B : ≈°trukt√∫ra‚ÇÇ T)
\end{lstlisting}
    Tak√°to defin√≠cia premenn√Ωch $A$ a $B$ zase zaruƒçuje ≈æe mno≈æina na ktor√Ωch s√∫
≈°trukt√∫ry definovan√© je rovnak√©ho typu.
    V pr√≠pade ≈æe by sme v√Ωraz uz√°tvorkovali do obyƒçajn√Ωch z√°tvoriek pou≈æili v
defin√≠cii:
\begin{lstlisting}
lemma ( T : Type* ) ( A : ≈°trukt√∫ra‚ÇÅ T ) ( B : ≈°trukt√∫ra‚ÇÇ T) : Type :=
begin
    ...
end
\end{lstlisting}
    Mus√≠me pri pou≈æiti alebo zavolan√≠ poskytn√∫≈• aj prv√Ω argument.
    Z tohto d√¥vodu sa tejto kon≈°trukcii hovor√≠ aj implicitn√Ω argument.
\begin{lstlisting}
lemma { T : Type* } ( A : ≈°trukt√∫ra‚ÇÅ T ) ( B : ≈°trukt√∫ra‚ÇÇ T) : Type :=
begin
    ...
end
\end{lstlisting}
Typy na ktor√Ωch s√∫ definovan√© argumenty z√°visia od implictn√©ho.
\subsection{Typov√© triedy}
    Typov√© triedy poskytuj√∫ mechanizmus pomocou ktor√©ho zluƒçujeme rozdielne ≈°trukt√∫ry
s rovnakou vlastnos≈•ou do tried.
    Pr√≠kladom m√¥≈æu by≈• ma≈• vlastnos≈• usporiadania, ma≈• reprezentanta alebo
by≈• grupou.
    Po zadefinovan√≠ triedy potom ≈°trukt√∫ru prirad√≠me do tried in≈°tancovan√≠m.
    In≈°tancovanie pre ≈°trukt√∫ry potom b√Ωva odli≈°n√© v z√°vislosti defin√≠cie ≈°trukt√∫ry.
    Vykon√°vanie d√¥kazov nad typovou triedou potom umo≈æ≈àuje zredukova≈• mno≈æstvo defin√≠cii.
    Nad na≈°imi defin√≠ciami vektorov m√¥≈æeme definova≈• dƒ∫≈æku.
\begin{lstlisting}
class norm (Œ± : Type u) :=
  (length : Œ± ‚Üí ‚Ñù)
\end{lstlisting}
    Potom k defin√≠ciam ≈°trukt√∫r prid√°me in≈°tancie.
\begin{lstlisting}
instance vector‚ÇÇ_norma : norma vector‚ÇÇ :=
 { length := Œª (v : vector‚ÇÇ), sqrt(v.x * v.x + v.y * v.y) }

instance vecotr‚ÇÉ_norma : norma vector‚ÇÉ :=
 { length := Œª (v : vector‚ÇÉ), sqrt(v.x * v.x + v.y * v.y + v.z * v.z) }
\end{lstlisting}
    Triedu potom vyu≈æ√≠vame v defin√≠ciach uveden√≠m do hranat√Ωch z√°tvoriek aj s
argumentom.
\begin{lstlisting}
variables { T : Type* } ( a : ≈°trukt√∫ra‚ÇÅ T ) ( b : ≈°trukt√∫ra‚ÇÇ  T ) [ norma T ]
\end{lstlisting}
    Tento u≈æ komplikovanej≈°√≠ z√°pis hovor√≠ o premenn√Ωch $a$ a $b$ ktor√© s√∫ definovan√©
na rovnakom type ktor√Ω m√° definovan√∫ alebo je in≈°tancovan√Ω dƒ∫≈ækou.

\chapter{Te√≥ria ƒçiastoƒçn√©ho usporiadania}
    V tejto kapitole sa budeme sna≈æi≈• uk√°za≈• mo≈ænosti Lean-u a vyu≈æitie u≈æ existuj√∫cich
defin√≠cii v mathlibe pre definovanie pojmov dok√°zanie viet t√Ωkaj√∫cich sa te√≥rie 
ƒçiastoƒçn√©ho usporiadania.
    Pre tento √∫ƒçel je v Lean-e mo≈ænos≈• definovania vlastnost√≠ usporiadania,
ktor√© n√°sledne mo≈æno aplikova≈• na abstraktn√∫ mno≈æinu objektov.
    V√Ωsledn√Ω typ je potom odvoden√Ω na z√°klade z√°vislostn√Ωch typov.
    Usporiadanie je jednoducho intuit√≠vne pochopiteƒæn√° vlastnos≈• bez matematick√Ωch
predispoz√≠cii.
    V ka≈ædodennom ≈æivote porovn√°vame svoju v√Ω≈°ku, ƒças, ktor√Ω trval na vybehnutie do kopca
alebo aj ƒç√≠selne neohodnoten√©, subjekt√≠vne merateƒæn√© objekty ako ktor√Ω album
od skupiny preferujem.
    Na ot√°zky si potom vieme odpoveda≈• "ja som vy≈°≈°√≠", "zabehol si pomal≈°ie" alebo
tieto "albumy s√∫ neporovnateƒæn√©".
    Te√≥ria usporiadania sa sna≈æ√≠ tieto vlastnosti form√°lne definova≈• a rozv√≠ja≈• ƒèalej
ot√°zkami ako,

\begin{itemize}
    \item Ak√© je horn√© ohraniƒçenie celej mno≈æiny objektov?
    \item Existuje ohraniƒçenie horn√© alebo doln√© pre ƒæubovoƒæn√∫ podmno≈æinu objektov?
    \item Ako vyzer√° zobrazenie zachov√°vaj√∫ce usporiadanie?
\end{itemize}
    Pre struƒçnos≈• sa v r√°mci defin√≠cii obmedz√≠me len na defin√≠ciu rel√°cie usporiadania,
ƒçi≈æe podmno≈æinu kartezi√°nskeho s√∫ƒçinu dvoch mno≈æ√≠n.
\begin{definition}
    Majme mno≈æinu $P$, potom usporiadanie alebo ƒçiastoƒçn√© usporiadanie na mno≈æine
    $P$ je bin√°rna rel√°cia $\leq$ tak√° ≈æe, pre v≈°etky $x,y,z \in P$
    \begin{itemize}
        \item $x \leq x$ reflexivita
        \item $x \leq y$ a $y \leq x$ implikuje $x = y$ antisymetria
        \item $x \leq y$ a $y \leq z$ impikuje $x \leq z$ tranzitivita
    \end{itemize}
\end{definition}
    Ide√°lnym n√°strojom pre uva≈æovanie nad usporiadan√≠m s√∫ \emph{Hasseho} diagramy.
    Ako pr√≠klad uv√°dzame diagram "kocky".
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.20]{cube.png}
    \caption{Usporiadania $\mathcal{P}(\{a,b,c\})$}
\end{figure}

    % TODO prerobit vetu % 
    Na obr√°zku je usporiadanie v≈°etk√Ωch podmno≈æ√≠n trojprvkovej mno≈æiny $\{ a,b,c \}$
vzhƒæadom na kardinalitu podmno≈æ√≠n.
    Za porovnateƒæn√© pova≈æujeme len tie prvky, ktor√© s√∫ "pokryt√©" jednosmernou cestou 
cez orientovan√© hrany grafu.

    V Leane je usporiadanie definovan√© ako roz≈°√≠renie triedy predusporiadania, ktor√°
je rel√°ciou, ktor√° nem√° oproti ƒçiastoƒçn√©mu usporiadaniu vlastnos≈• antisymetrie.

\begin{lstlisting}
class has_le       (Œ± : Type u) := (le : Œ± ‚Üí Œ± ‚Üí Prop)
class has_lt       (Œ± : Type u) := (lt : Œ± ‚Üí Œ± ‚Üí Prop)

class preorder (Œ± : Type u) extends has_le Œ±, has_lt Œ± :=
(le_refl : ‚àÄ a : Œ±, a ‚â§ a)
(le_trans : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c)
(lt := Œª a b, a ‚â§ b ‚àß ¬¨ b ‚â§ a)
(lt_iff_le_not_le : ‚àÄ a b : Œ±, a < b ‚Üî (a ‚â§ b ‚àß ¬¨ b ‚â§ a) . order_laws_tac)
\end{lstlisting}
    ƒåiastoƒçn√© usporiadanie je potom roz≈°√≠ren√≠m predusporiadania o vlastnos≈• antysymetrie.
\begin{lstlisting}
class partial_order (Œ± : Type u) extends preorder Œ± :=
(le_antisymm : ‚àÄ a b : Œ±, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b)
\end{lstlisting}

\section{Zv√§z}
    Zv√§z je ƒçiastoƒçne usporiadan√° mno≈æina, pre ktor√∫ navy≈°e plat√≠, ≈æe pre ka≈æd√© 2 prvky $a, b$
vieme n√°js≈• prvok $c$, ktor√Ω je ich jedineƒçn√Ωm najmen≈°√≠m horn√Ωm, respekt√≠ve(\emph{supremum})
najv√§ƒç≈°√≠m doln√Ωm ohraniƒçen√≠m(\emph{infimum}).
    V pr√≠pade intervalu re√°lnych ƒç√≠sel je toto ohraniƒçenie jednoducho predstaviteƒæn√©
ako bod ohraniƒçuj√∫ce mno≈æinu na ƒç√≠selnej osi.
    Ak ide o ƒçiastoƒçn√© usporiadanie, n√°zov je pre tieto ohraniƒçenia prvkov
motivovan√Ω zobrazen√≠m na grafe.
    \emph{Spojenie} $\sqcup, \vee$ pre supremum, respekt√≠ve \emph{priesek} $\sqcap, \wedge$ pre infimum.
    Popisnej≈°√≠m n√°zvom pre zv√§z je preklad anglicky pou≈æ√≠van√©ho n√°zvu \emph{lattice}
"mrie≈æka" tak isto motivovan√° zobrazen√≠m tak√©ho usporiadania na grafe.
    Pri dokazovan√≠ viet o zv√§zoch je ƒçasto vyu≈æ√≠van√° vlastnos≈• duality najmen≈°ieho
horn√©ho a du√°lne najv√§ƒç≈°ieho doln√©ho ohraniƒçenie pre druh√∫ polovicu d√¥kazu.
\begin{lstlisting}
class has_sup (Œ± : Type u) := (sup : Œ± ‚Üí Œ± ‚Üí Œ±)
class has_inf (Œ± : Type u) := (inf : Œ± ‚Üí Œ± ‚Üí Œ±)

infix ‚äî := has_sup.sup
infix ‚äì := has_inf.inf

class semilattice_sup (Œ± : Type u) extends has_sup Œ±, partial_order Œ± :=
(le_sup_left : ‚àÄ a b : Œ±, a ‚â§ a ‚äî b)
(le_sup_right : ‚àÄ a b : Œ±, b ‚â§ a ‚äî b)
(sup_le : ‚àÄ a b c : Œ±, a ‚â§ c ‚Üí b ‚â§ c ‚Üí a ‚äî b ‚â§ c)

class semilattice_inf (Œ± : Type u) extends has_inf Œ±, partial_order Œ± :=
(inf_le_left : ‚àÄ a b : Œ±, a ‚äì b ‚â§ a)
(inf_le_right : ‚àÄ a b : Œ±, a ‚äì b ‚â§ b)
(le_inf : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ b ‚äì c)

class lattice (Œ± : Type u) extends semilattice_sup Œ±, semilattice_inf Œ±
\end{lstlisting}

\section{Modul√°rne zv√§zy}

    V nasleduj√∫com √∫seku si uk√°≈æeme vetu t√Ωkaj√∫cu sa ≈°peci√°lneho typu zv√§zu s vlastnos≈•ou
modularity a uk√°≈æeme si form√°lny d√¥kaz a jej implement√°ciu v Leane, ktor√∫ si
podrobne rozoberieme.

    O zv√§ze $L$ hovor√≠me, ≈æe je modul√°rny, v pr√≠pade, ≈æe m√° nasleduj√∫cu vlastnos≈•.

\begin{equation*}
    (\forall x,y,z \in L) x \geq y \implies x \wedge ( y \vee z) = (x \wedge y) \vee z
\end{equation*}

    V Leane definovan√Ω ako roz≈°√≠renie zv√§zu:

\begin{lstlisting}
class modular_lattice(Œ± : Type u) extends lattice Œ± :=
  (modular_law: ‚àÄ (x u v : Œ± ), (x ‚â§ u) ‚Üí u ‚äì (v ‚äî x) = (u ‚äì v) ‚äî x )
\end{lstlisting}

    V nasleduj√∫com √∫seku si uk√°≈æeme vetu o izomorfizme pre modul√°rne zv√§zy a podrobne
si rozoberieme implement√°ciu jej d√¥kazu s obsahom prostredia v Leane.

\begin{theorem} \emph{Veta o izomorfizme pre modul√°rne zv√§zy}
Nech L je modul√°rnym zv√§zom a $a, b \in L$. Potom
    \begin{equation}
        \varphi_{b}: x \mapsto x \wedge b, x \in [a, a \vee b],
    \end{equation}
Je izomorfizmom medzi intervalmi $[a, a \vee b]$ a $[ a \wedge b, b]$.
Inverzn√Ωm izomorfizmom je
    \begin{equation}
        \psi_{a}: y \mapsto y \vee a, y \in [a \wedge b, b].
    \end{equation}
\end{theorem}
\emph{D√¥kaz}.
    Staƒç√≠ uk√°za≈•, ≈æe $\varphi_{b}\psi_{a}(y) = y$ pre v≈°etky $y \in [a \wedge b, b]$.
    Z duality potom vypl√Ωva, ≈æe $\psi_{a}\varphi_{b}(x) = x$ pre v≈°etky
$x \in [a, a \vee b ]$,
    Nech $y \in [ a \wedge b, b ]$, potom $\varphi_{b}\psi_{b} = ( y \vee b ) \wedge a$ 
a ak plat√≠ nerovnos≈• $b \geq y$ tak potom z modularity
    \begin{equation}
        \varphi_{b}\psi_{a}(y) =
        ( y \vee b ) \wedge a =
        y \vee ( b \wedge a) =
        y
    \end{equation}
    preto≈æe
    \[
        \pushQED{\qed}
        y \geq a \wedge b. \qedhere
        \popQED
    \]

    Horeuveden√Ω d√¥kaz je zn√°zornen√Ω na nasleduj√∫com obr√°zku.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.35]{modular_lattice_isomorphism.png}
    \caption{Izomorfizmus modul√°rneho zv√§zu}
\end{figure}
k
    V pr√≠pade form√°lneho d√¥kazu sme sa mohli v ƒçasti d√¥kazu odk√°za≈• na dualitu.
    Pri n√°vrhu d√¥kazu v Leane mus√≠me uk√°za≈• d√¥kaz z "oboch" str√°n. Najsk√¥r uvedieme
hotov√Ω d√¥kaz vety:
\begin{lstlisting}
theorem modular_lattice_isomorphism { Œ±: Type u } [ modular_lattice Œ± ] { a b x : Œ±}:
  x ‚â§ a ‚Üí
  x ‚â• b ‚Üí
  x ‚â• a ‚äì b ‚Üí
  x ‚â§ a ‚äî b ‚Üí
  a ‚äì ( b ‚äî x ) = x ‚àß (a ‚äì x) ‚äî b = x
  :=
  begin
    intros h1 h2 h3 h4,
    split,
    {
      rw modular_lattice.modular_law,
      exact sup_eq_right.mpr h3,
      exact h1
    },
    {
      rw inf_comm,
      rw ‚Üê modular_lattice.modular_law,
      exact inf_eq_left.mpr h4,
      exact h2
    }
  end
\end{lstlisting}
    Zaƒç√≠name v taktickom m√≥de ktor√Ω je interakt√≠vnou verziou dokazovania v Leane.
    Po zadan√≠ pr√°zdnej kon≈°trukcie \emph{begin} a \emph{end}
    Interakt√≠vne prostredie vyzer√° nasledovne.
\begin{lstlisting}
Œ±: Type u
_inst_1: modular_lattice Œ±
abx: Œ±
‚ä¢ x ‚â§ a ‚Üí x ‚â• b ‚Üí x ‚â• a ‚äì b ‚Üí x ‚â§ a ‚äî b ‚Üí a ‚äì (b ‚äî x) = x ‚àß a ‚äì x ‚äî b = x
\end{lstlisting}
    Prv√Ωm krokom d√¥kazu je presunutie predpokladov zo sledu implik√°cii do
prostredia pre ƒèal≈°iu pr√°cu s nimi s oznaƒçen√≠m $h1,h2,h3,h4$.
\begin{lstlisting}
Œ±: Type u
_inst_1: modular_lattice Œ±
abx: Œ±
h1: x ‚â§ a
h2: x ‚â• b
h3: x ‚â• a ‚äì b
h4: x ‚â§ a ‚äî b
‚ä¢ a ‚äì (b ‚äî x) = x ‚àß a ‚äì x ‚äî b = x
\end{lstlisting}
    Cieƒæ potom pozost√°va z konjukcie, kde v druhej ƒçasti m√°me v√Ωraz implicitne
oz√°tvorkovan√Ω zƒæava.
    V√Ωraz rozdel√≠me do dvoch podcieƒæov pr√≠kazom \emph{split}, a pre lep≈°iu
ƒçitateƒænos≈• oz√°tvorkujeme mno≈æinov√Ωmi z√°tvorkami. Nach√°dzame sa v stave
\begin{lstlisting}
  begin
    intros h1 h2 h3 h4,
    split,
    {
    },
    {
    }
  end
\end{lstlisting}
v ktorom n√°m lean ukazuje prostredie, kde mus√≠me dok√°za≈• ƒæav√∫ ƒças≈• konjukcie.
\begin{lstlisting}
‚ä¢ a ‚äì (b ‚äî x) = x
\end{lstlisting}
Na cieƒæ pou≈æijeme z defin√≠cie modul√°rneho zv√§zu vlastnos≈• modularity
\begin{lstlisting}
    (modular_law: ‚àÄ (x u v : Œ± ), (x ‚â§ u) ‚Üí u ‚äì (v ‚äî x) = (u ‚äì v) ‚äî x )
\end{lstlisting}
a transformujeme prep√≠≈°eme cieƒæ cez pr√≠kaz
\begin{lstlisting}
rw modular_lattice.modular_law,
\end{lstlisting}
na nasleduj√∫ci, kde m√° $u \sqcap v$ vy≈°≈°iu precedenciu
\begin{lstlisting}
‚ä¢ u ‚äì v ‚äî x = x
\end{lstlisting}
    Nasleduj√∫ca transform√°cia vy≈æaduje znalos≈• u≈æ dok√°zan√Ωch defin√≠ci√≠, ktor√©
boli dok√°zan√© pre podkladov√© ≈°trukt√∫ry. Pou≈æijeme nasleduj√∫cu defin√≠ciu, ktor√° vych√°dza
z kontextu \emph{semilattice\_sup}.
\begin{lstlisting}
% @ [simp] theorem sup_eq_right : a ‚äî b = b ‚Üî a ‚â§ b :=    / TODO NEZABUDNUT
%  le_antisymm_iff.trans $ by simp [ le_refl ]             / ODKOMENTOVAT
\end{lstlisting}
    Zauj√≠mavos≈•ou je, ≈æe si Lean dok√°≈æe substiuova≈• v√Ωraz $u \sqcap v$ za $a$ z uveden√©ho
v√Ωrazu. Pri pou≈æit√≠ vety dost√°vame ekvivalenciu, ktor√° je definovan√° ako ≈°trukt√∫ra.
\begin{lstlisting}
structure iff (a b : Prop) : Prop :=
    intro :: (mp : a ‚Üí b)
             (mpr : b ‚Üí a)
\end{lstlisting}
Z tejto ≈°trukt√∫ry pou≈æijeme implik√°ciu smeruj√∫ca doƒæava nasledovne:
\begin{lstlisting}
    exact sup_eq_right.mpr h3,
\end{lstlisting}
    Cieƒæ je teda transformovan√Ω na:
\begin{lstlisting}
‚ä¢ x ‚â§ a
\end{lstlisting}
ƒço je u≈æ uveden√Ω predpoklad $h1$. T√Ωmto sme dok√°zali jeden z podcieƒæov.
    V tejto chv√≠li by sme sa v literat√∫re mohli odvola≈• na dualitu v√Ωrazov.
    V Leane mus√≠me poskytn√∫≈• d√¥kaz aj o druhom cieli. Ideme dok√°za≈•
\begin{lstlisting}
‚ä¢ a ‚äì x ‚äî b = x
\end{lstlisting}
V tejto chv√≠li chceme znova pou≈æi≈• modularitu, leanu je, ale potrebn√© explicitne poveda≈•,
    ≈æe chceme prep√≠sa≈• v√Ωraz nach√°dzaj√∫ci na pravej strane rovnosti pomocou symbolu
ƒæavej ≈°√≠pky.
\begin{lstlisting}
rw ‚Üê modular_lattice.modular_law,
\end{lstlisting}
    Pou≈æijeme du√°lnu vetu
    du√°lnu k \emph{sup\_eq\_right}.
\begin{lstlisting}
@[simp] theorem inf_eq_left : a ‚äì b = a ‚Üî a ‚â§ b
\end{lstlisting}
    a vyu≈æijeme opaƒçn√© predpoklady k predch√°dzaj√∫cim $h2, h4$.
\begin{lstlisting}
{
    rw ‚Üê modular_lattice.modular_law,
    exact inf_eq_left.mpr h4,
    exact h2
}
\end{lstlisting}

    Po dok√°zan√≠ druh√©ho cieƒæa sme dok√°zali cel√∫ vetu. $\square$

\section{Podzv√§z}
    V r√°mci pr√≠spevku do kni≈ænice \emph{mathlib} sme implementovali ≈°trukt√∫ru
reprezentuj√∫cu podzv√§z. ≈†trukt√∫ra s jej atrib√∫tmi boli implementovan√© podƒæa
zau≈æ√≠van√Ωch zvyklost√≠ projektu. Jej predlohu tvorila ≈°trukt√∫ra $submonoidu$.

Form√°lne je definovan√Ω:
\begin{theorem}
    Nech $L$ je zv√§z. Mno≈æina $K \subseteq L$ je \emph{podzv√§z} $L$ ak pre v≈°etky 
$a,b \in K$ plat√≠, ≈æe, $a \wedge b \in K$, $a \vee b \in K$.
\end{theorem}
Jeho struƒçn√° implement√°cia vyzer√° nasledovne:
\begin{lstlisting}
import order.lattice

structure sublattice ( L : Type* ) [ lattice L ] :=
  ( carrier : set L)
  ( inf_mem'  {a b : L} : a ‚àà carrier ‚Üí b ‚àà carrier ‚Üí a ‚äì b ‚àà carrier )
  ( sup_mem'  {a b : L} : a ‚àà carrier ‚Üí b ‚àà carrier ‚Üí a ‚äî b ‚àà carrier )
\end{lstlisting}
    Pre defin√≠ciu podzv√§zu je nutn√© zavies≈• priestor mien pre zv√§zy ktor√Ω sa v kni≈ænici
\emph{mathlib} v s√∫bore \emph{"src/order/lattice.lean"}.
    Z tohto priestoru pou≈æ√≠vame typov√∫ triedu zv√§zu.
    V pr√≠pade ≈æe chceme vytvori≈• typ \emph{sublattice} je nutn√© poskytn√∫≈•
typ ktor√Ω m√° in≈°tancovan√∫ typov√∫ triedu zv√§zu.
    Prvky ≈°trukt√∫ry potom tvor√≠ \emph{carrier} v preklade nosiƒç ktor√©ho typ
$set$ je $L \to Prop$ a prvky $inf\_mem$ a $sup\_mem$ zaruƒçuj√∫ce uzavretos≈•
    suprema a infima.
    Nasleduj√∫ce defin√≠cie a in≈°tancie s√∫ definovan√© v priestore mien \emph{sublattice}
    Pre pou≈æitie tejto ≈°trukt√∫ry sme ≈°trukt√∫ru in≈°tancovali pre triedu \emph{set\_like}
ktor√° poskytuje mo≈ænos≈• konverzie typu na jednoduch≈°ie ≈°trukt√∫ry.
\begin{lstlisting}
instance : set_like (sublattice L) L :=
  ‚ü®sublattice.carrier, Œª p q h, by cases p; cases q; congr'‚ü©
\end{lstlisting}
    Defin√≠cie oznaƒçen√© znaƒçkou \emph{simp} sl√∫≈æia na zjednodu≈°ovanie v√Ωrazov
pomocou pr√≠kazu \emph{simp} taktick√©ho m√≥du.
\begin{lstlisting}
@[simp]
lemma mem_carrier {SL : sublattice L} {x : L} : x ‚àà SL.carrier ‚Üî x ‚àà SL := iff.rfl
\end{lstlisting}
    V tomto pr√≠pade hovor√≠ ide o ekvivalenciu tvrden√≠ ≈æe prvok patriaci nosiƒçu
≈°trukt√∫ry je ekvivalentn√Ω tvrdeniu ≈æe patr√≠ ≈°trukt√∫re.

    Defin√≠cie oznaƒçen√© znaƒçkami \emph{ext} potom oznaƒçuj√∫ defin√≠cie ktor√©
pou≈æ√≠va pr√≠kaz exact. Vo v≈°eobecnosti ide o defin√≠cie ktor√© hovoria o tom
kedy s√∫ 2 typy rovnak√©.
\begin{lstlisting}
@[ext]
theorem ext {A B : sublattice L}
  (h : ‚àÄ x, x ‚àà A ‚Üî x ‚àà B) : A = B := set_like.ext h
\end{lstlisting}
    Nasleduj√∫ce defin√≠cie sa t√Ωkaj√∫ vytvorenia nov√©ho objektu kop√≠rovan√≠m,
vytvoren√≠m k√≥pie cez pretypovanie a tvrden√≠m a defin√≠ciou ktor√° vr√°ti typ
tvrdenia o rovnosti k√≥pie so ≈°trukt√∫rou podzv√§zu.
\begin{lstlisting}
def copy (SL : sublattice L) (S : set L) (hs : S = SL) : sublattice L :=
{ carrier := S,
  inf_mem' := hs.symm ‚ñ∏ SL.inf_mem',
  sup_mem' := hs.symm ‚ñ∏ SL.sup_mem' }

variables { SL : sublattice L }

lemma coe_copy {B : sublattice L} {A : set L} (hs : A = SL) :
  (SL.copy A hs : set L) = A := rfl

lemma copy_eq {s : set L} (hs : s = SL) : SL.copy s hs = SL :=
  set_like.coe_injective hs
\end{lstlisting}
    V pr√≠pade ≈æe by sme chceli prist√∫pi≈• k defin√≠cii typu infima alebo superma
na≈°ej ≈°trukt√∫ry boli zaveden√© defin√≠cie ktor√© vracaj√∫ ich typ.
\begin{lstlisting}
theorem inf_mem {a b : L} : a ‚àà SL ‚Üí b ‚àà SL ‚Üí a ‚äì b ‚àà SL :=
  sublattice.inf_mem' SL

theorem sup_mem {a b : L} : a ‚àà SL ‚Üí b ‚àà SL ‚Üí a ‚äî b ‚àà SL :=
  sublattice.sup_mem' SL
\end{lstlisting}


\begin{thebibliography}{xx}
    \bibitem{Mimram} Samuel Mimram, Program = Proof, Indenpendently published(July 3, 2020), ISBN-13: 979-8615591839
    \bibitem{SorensenUrzyczyn} Morten Heine B. S√∏rensen, Pawel Urzyczyn, Lectures on the Curry-Howard Isomorphism,
        Elsevier Science (April 4, 2013),  ISBN-13 : 978-0444545961
    \bibitem{lean3} https://github.com/leanprover/lean
    \bibitem{lean4} https://github.com/leanprover/lean4
    \bibitem{mathlib} https://github.com/leanprover-community/mathlib
    \bibitem{mathlib_paper} https://leanprover-community.github.io/papers/mathlib-paper.pdf
\end{thebibliography}

\end{document}

