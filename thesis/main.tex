\documentclass[a4paper,10pt,oneside]{report}%pridat twoside, do [] pre obojstrannu tlac
\pagestyle{headings}
\usepackage[top=2.5cm, bottom=2.5cm, left=3.5cm, right=2cm]{geometry} %odporucane okraje
\linespread{1.50}

%% Generally used
\usepackage{ebproof}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb, upgreek}
\usepackage{mathtools}
\usepackage{color}
%% Generally used

%% Lean specific
\usepackage[utf8x]{inputenc}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{errorcolor}{rgb}{1, 0, 0}           % bright red
\definecolor{stringcolor}{rgb}{0.5, 0.3, 0.2}    % brown
\usepackage{pict2e,picture}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}
%% Lean specific

%% Covering

\newcommand{\coveringA}{%
  \mathrel{-\mkern-4mu}<%
}
\newcommand{\coveringB}{\mathrel{\text{$\vcenter{\hbox{\pictcoveringB}}$}}}

\newcommand{\pictcoveringB}{%
  \begin{picture}(1em,.5em)
  \roundcap
  \put(0,.25em){\line(1,0){.6em}}
  \put(.6em,.25em){\line(3,1){.4em}}
  \put(.6em,.25em){\line(3,-1){.4em}}
  \end{picture}%
}
%% Covering

%% Powerset
\newcommand{\powerset}{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}
%% Powerset
\newcommand{\nothing}{\varnothing}

\newtheorem{theorem}{Theorem}


\author{Mat\'u\v{s} Behun}
\title{Lattice theory notes}

\begin{document}

\tableofcontents

\section{Ãšvod}

%Pri procese rozÅ¡irovania matematickej teÃ³rie vytvÃ¡rame tvrdenia generalizujÃºce jej princÃ­py.
%Ak chceme aby nÃ¡Å¡a teÃ³ria bola sprÃ¡vna, vÅ¡etky jej tvrdenia musia byÅ¥ logicky odvodenÃ© z postulÃ¡tov alebo tvrdenÃ­ z nich odvodenÃ½ch.
%Potvrdenie sprÃ¡vnosti tvrdenia, vyslovenÃ­m predpokladu, axiÃ³mu alebo napÃ­sanÃ­m formule ktorÃº dostaneme aplikÃ¡ciou dedukÄnÃ©ho pravidla na niektorÃ© v postupnosti predchÃ¡dzajÃºce formule nazÃ½vame dÃ´kazom.

%% Je to pravda?
%Z kvalitatÃ­vneho hÄ¾adiska pri vyslovenÃ­ dÃ´kazu uvaÅ¾ujeme o vÅ¡eobecnosti dÃ´kazu a sprÃ¡vnosti aplikÃ¡cie dedukÄnÃ©ho pravidla.
%% Je to vhodnÃ½ prÃ­klad(chcel som uviest priklad na prvy pohlad spravneho tvrdenia ktore bolo dokazane ako nespravne ? Ako sprÃ¡vne citovaÅ¥? NÃ¡pad som mal odtiaÄ¾to https://en.wikipedia.org/wiki/List_of_disproved_mathematical_ideas
%O nutnosti korektnÃ©ho dokazovania tvrdenÃ­ hovorÃ­ naprÃ­klad tvrdenie z teÃ³rie ÄÃ­sel o hornom ohraniÄenÃ­ poÄtu prvoÄÃ­sel logaritmickÃ½m integrÃ¡lom.

%\begin{equation}
    %\pi(x) \leq \int_{0}^{x} \frac{1}{ \ln{t} } dt
%\end{equation}

%Tvrdenie bolo povaÅ¾ovanÃ© za sprÃ¡vne Bernhardom Riemannom a evidencia to taktieÅ¾ naznaÄovala.
%NeskÃ´r sa ukÃ¡zalo Å¾e tvrdenie nie je sprÃ¡vne pri ÄÃ­sle pod hodnotou $10^{317}$.
%% DoplniÅ¥ rok
%Veta o 4 farbÃ¡ch ktorÃ¡ bola vyslovenÃ¡ v roku 1852 Francisom Guthrie ktorÃ¡ hovorÃ­, Å¾e kaÅ¾dÃ¡ rovinnÃ¡ mapa je zafarbiteÄ¾nÃ¡ 4 farbami.
%% 18-faces
%TÃ¡to veta bola nesprÃ¡vne dokÃ¡zanÃ¡ v roku Kempom (1879) and Taitom (1880). Kempov dÃ´kaz bol vyvrÃ¡tenÃ½ o 10 rokov mapov s 18 stenami.
%% Je lepÅ¡ie skloÅˆovaÅ¥ cudzie menÃ¡?
%Pri dÃ´kaze tejto vety bol neskÃ´r v roku 1977 Appelom and Hakenom z Äasti vyuÅ¾itÃ½ poÄÃ­taÄ pre kontrolu Å¡peciÃ¡lnych diskrÃ©tnych prÃ­padov.


\section{PrirodzenÃ¡ intuionistickÃ¡ logika}

\subsection{Formalizovanie dÃ´kazu}

DÃ´kaz z teÃ³rie usporiadania. Tak ako je Program = Proof

OtÃ¡zka ohÄ¾adom konzistentnosti dÃ´kazu.

\subsection{PrirodzenÃ¡ dedukcia}

% Formula vyrokoveho poctu
\begin{theorem}[VÃ½rokovÃ¡ premennÃ¡, formula]
    Majme spoÄÃ­tateÄ¾nÃº mnoÅ¾inu $\mathcal{X}$ vÃ½rokovÃ½ch premennÃ½ch. MnoÅ¾ina vÃ½rokov
    alebo formÃºl $\mathcal{A}$ generovanÃº nasledovnou gramatikou:
    \begin{equation}
        A, B ::= X | A \implies B | A \wedge B | A \vee B | \neg A | \top | \bot
    \end{equation}
    Kde $X \in \mathcal{X}$ reprezentuje vÃ½rokovÃº premennÃº, a $A, B \in \mathcal{A}$
    vÃ½rok.
\end{theorem}

V prÃ­pade nasledovnÃ©ho vÃ½roku je precedencia $\neg$ vyÅ¡Å¡ia ako $\vee$ alebo $\wedge$
a tÃ¡ je vyÅ¡Å¡ia ako $\implies$. BinÃ¡rne operÃ¡tory sÃº asociatÃ­vne z prava.

\begin{align*}
    \neg A \wedge B \wedge C &\implies A \vee B \\
    (\neg A \wedge (B \wedge C)) &\implies (A \vee B) \\
\end{align*}

\begin{theorem}
    Kontextom(systÃ©m predpokladov) rozuemieme zoznam vÃ½rokov znaÄenÃ½ch
    \begin{equation}
        \Gamma = P_{1}, \dots , P_{n}
    \end{equation}
    Dedukciou nazÃ½vame dvojicu pozostÃ¡vajÃºcu z kontextu a vÃ½roku.
    \begin{equation}
        \Gamma \vdash A
    \end{equation}
\end{theorem}

VÃ½raz ÄÃ­tame ako $A$ je moÅ¾nÃ© dokÃ¡zaÅ¥ zo systÃ©mu predpokladov $\Gamma$.

\begin{theorem}
    DedukÄnÃ© pravidlo pozostÃ¡va z mnoÅ¾iny dedukciÃ­ $\Gamma_{i}$ ktorÃ© nazÃ½vame
    prepokladom. DolnÃº ÄasÅ¥ dedukÄnÃ©ho pravidla $\Gamma$ nazÃ½vame zÃ¡verom.
    \begin{equation}
        \begin{prooftree}
            \hypo{\Gamma_{1} \vdash A_{1}}
            \hypo{\dots}
            \hypo{\Gamma_{n} \vdash A_{n}}
            \infer3[]{\Gamma \vdash A}
        \end{prooftree}
    \end{equation}
\end{theorem}
PravidlÃ¡ prirodzenej intuicionistickej logiky:
\begin{center}
    \begin{prooftree}
        \infer0[(ax)]{\Gamma,A,\Gamma' \vdash: A}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \implies B}
        \hypo{\Gamma \vdash A}
        \infer2[$(\implies_{E})$]{\Gamma : B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$\implies_{I}$]{\Gamma : B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{l}_{E})$]{\Gamma : A}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash B}
        \infer1[$(\wedge^{r}_{E})$]{\Gamma : B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \hypo{\Gamma \vdash B}
        \infer2[$(\wedge_{I})$]{\Gamma \vdash A \wedge B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash A \vee B}
        \hypo{\Gamma, A \vdash C}
        \hypo{\Gamma, B \vdash C}
        \infer3[$(\vee_{E})$]{\Gamma \vdash C}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash B}
        \infer1[$(\vee_{I}^{r})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
    \begin{prooftree}
        \hypo{\Gamma \vdash A}
        \infer1[$(\vee_{I}^{l})$]{\Gamma \vdash A \vee B}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash \neg A}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{E})$]{\Gamma \vdash \bot}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma, A \vdash \bot}
        \hypo{\Gamma \vdash A}
        \infer2[$(\neg_{I})$]{\Gamma \vdash \neg A}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{center}
    \begin{prooftree}
        \hypo{\Gamma \vdash \bot}
        \infer1[$(\bot_{E})$]{\Gamma \vdash A}
    \end{prooftree}
\end{center}

V prÃ­pade Å¾e tieto pravidlÃ¡ ÄÃ­tame zhora nadol hovorÃ­me o dedukcii.
Ak ÄÃ­tame pravidlÃ¡ zdola nahor hovorÃ­me o indukÄnom spÃ´sobe.

\begin{theorem}
    Fragmentom intuionistickej logiky nazÃ½vame, systÃ©m ktorÃ½ dostaneme ak ho obmedzÃ­me
        len na niektorÃ© z predchÃ¡dzajÃºcich pravidiel.
\end{theorem}

\begin{theorem}
    ImplikaÄnÃ½m fragmentom intuionistickej logiky dostaneme v prÃ­pade ak formuly
        budÃº tvorenÃ© gramatikou
    \begin{equation}
        A,B ::= X | A \implies B
    \end{equation}
    a pravidlami (ax), ($\implies_{E}$), ($\implies_{I}$)
\end{theorem}

% TODO spravit priklad
% (ð´âˆ§ðµ)â†’((ð´â†’ð¶)â†’Â¬(ðµâ†’Â¬ð¶))

V prÃ­pade Å¾e chceme aby vÃ½rokove formuly korenÅ¡pondovali s typmi ktorÃ© su prezentovanÃ© neskÃ´r.
Ich booleova reprezentÃ¡cia s hodnotami $1,0$ je nahradenÃ¡ otÃ¡zkou existencie prvkov v mnoÅ¾ine.
V prÃ­pade implikÃ¡cie o existencii funkcie v mnoÅ¾ine.
Funkcie v programoch ale mÃ´Å¾u maÅ¥ pri rovnakÃ½ch vstupoch a vÃ½stupoch maÅ¥ rÃ´znu vÃ½poÄtovÃº zloÅ¾itosÅ¥.
DÃ´vod preÄo by sme sa mali pozeraÅ¥ na dÃ´kazy(podÄ¾a publikÃ¡cie Gir11) v troch rovinÃ¡ch.

\begin{itemize}
    \item 1. BooleovskÃ½ - tvrdenia sÃº booleovskÃ© hodnoty, zaujÃ­mame sa o dokÃ¡zateÄ¾nosÅ¥ tvrdenia
    \item 2. ExistenÄnÃ½ - tvrdenia sÃº mnoÅ¾iny, akÃ© funkcie mÃ´Å¾u byÅ¥
    \item 3. ÃšmyselnÃ½/ZÃ¡merovÃ½(Intentional) - zaujÃ­mame sa o zloÅ¾itosÅ¥ vytvorenÃ©ho dÃ´kazu a ako sa zjednoduÅ¡Ã­ cez (cut eliminitation)
\end{itemize}

\subsection{Intuicionizmus}

JednÃ½m zo smerov matematickej filozofie tÃ½kajucej sa rozvoja teÃ³rie je konÅ¡truktivizmus.
KonÅ¡truktivizmus hovorÃ­ o potrebe nÃ¡jsÅ¥ alebo zostrojiÅ¥ matematickÃ½ objekt k tomu
    aby bola dokÃ¡zanÃ¡ jeho existencia.
Jeden z motivaÄnÃ½ch prÃ­kladov takÃ©hoto prÃ­stupu je moÅ¾nosÅ¥ dokÃ¡zania pravdivosti
vÃ½roku $p \vee \neg p$ cez dÃ´kaz sporom $\neg p$ ktorÃ½ nehovorÃ­ ako zostrojiÅ¥ objekt
$p$ len o jeho existencii.
Tento smer tvorÃ­ viacero "Å¡kÃ´l" okrem inÃ½ch finitizmus, predikativizmus, intuicionizmus.
Intuitionizmus je teda konÅ¡truktÃ­vny prÃ­stup k matematike v duchu
    Brouwera(1881-1966) a Heytinga(1898-1980).
FilozofickÃ½m zÃ¡kladom tochto prÃ­stupu princÃ­p Å¾e matematika je vÃ½tvorom mentÃ¡lnej
Äinnosti a nepozostÃ¡va z vÃ½sledkov  formÃ¡lnej manipulÃ¡cie symbolov ktorÃ© sÃº iba
sekundÃ¡rne.
JednÃ½m z princÃ­pov intuicionizmus je odmietnutie tvrdenia postulÃ¡tu klasickej
logiky a to zÃ¡kona vylÃºÄenia tretieho.

\begin{equation}
    p \vee \neg p
\end{equation}

DÃ´vodom je z konÅ¡truktÃ­vneho pohÄ¾adu nezmyselnosÅ¥ uvaÅ¾ovania nad pravdivosÅ¥ou
    vÃ½roku nezÃ¡visle od uvaÅ¾ovanÃ©ho tvrdenia.
VÃ½rok je teda pravdivÃ½ ak existuje dÃ´kaz o jeho pravidovsti a nepravdivÃ©
    ak existuje dÃ´kaz ktorÃ½ vedie k sporu.

\begin{itemize}
    \item konjukcii $ p \wedge q $ ako o vÃ½roku hovoriacom o existencii dÃ´kazov $p$ a zÃ¡roveÅˆ $q$,
    \item disjunkcii $ p \wedge q $ ako existencii konÅ¡trukcii dÃ´kazu jednÃ©ho z vÃ½rokov $p, q$,
    \item $ p \implies q $ je metÃ³da(funkcia) transformÃ¡cie kaÅ¾dej konÅ¡trukcie $p$ k dÃ´kazu $q$,
    \item neexistencie dÃ´kazu nepravdivÃ©ho tvrdenia, iba dÃ´kazu ktorÃ½ vedie k sporu $p \implies \bot$
    \item konÅ¡trukcia $\neg p$ je metÃ³da ktorÃ¡ vytvorÃ­ kaÅ¾dÃº konÅ¡trukciu $p$ na neexistujÃºci objekt
\end{itemize}

konjukcii $ A \wedge B $ ako $ A \times B $
$ A \vee B $ ako $ A \sqcup B $ disjunktne zjednotenie
$ \neg A = A \implies \perp $ existencie kontraprÃ­kladu

\section{Lambda kalkulus}

\begin{theorem}
    Majme nekoneÄnÃº mnoÅ¾inu $ \mathcal{X}={x,y,z,\dots}$ ktorÃ½ch elementy nazÃ½vame premennÃ©.
MnoÅ¾inu $\Lambda$ tvorenÃº $\lambda$-termÃ­nmy je potom generovanÃ¡ nasledovnou gramatikou:
    \begin{equation}
        t, u ::= x | t u | \lambda x.t
    \end{equation}
\end{theorem}
\noindent VÃ½znam jednotlivÃ½ch termÃ­nov je
\begin{align*}
     x          & \textrm{ - je premennou }\\
     t u        & \textrm{ - je aplikÃ¡ciou termÃ­nu $t$ s argumentom $u$ }\\
    \lambda x.t & \textrm{ - je abstrakciou $t$ nad $x$ }
\end{align*}
PrÃ­klady lambda termÃ­nov:

\begin{align*}
    & t x \\
    & (\lambda y . \lambda x . t y )) \\
    & (\lambda y.y x) (\lambda x . x) \\
    & t u v = ( t u ) v
\end{align*}

AplikÃ¡cia $\lambda$-termÃ­nov je implicitne aplikovanÃ¡ zÄ¾ava.

Pri vÃ½raze
\begin{equation}
    \lambda x . t x = \lambda x . (t x)
\end{equation}
je precedencia aplikÃ¡cie vyÅ¡Å¡ia ako abstrakcia.

A abstrakciu s troma argumentmi je moÅ¾nÃ© prepÃ­saÅ¥ do troch po sebe nasledujÃºcich.
\begin{equation}
    \lambda x y z . t = \lambda x . \lambda y . \lambda z . t
\end{equation}

\begin{theorem}
    PremennÃ¡ x sa vo vÃ½raze
    \begin{equation}
        \lambda x . t
    \end{equation}
    abstrakciou viaÅ¾e na termÃ­n $t$. O premennej $x$ hovorÃ­me Å¾e je viazanÃ¡.
    O premennÃ½ch ktorÃ© nie sÃº viazanÃ© sÃº voÄ¾nÃ©.
    \begin{align*}
        VP(x) &= {x} \\
        VP(\lambda x.t) &= VP(t)  \setminus \{x\} \\
        VP(t v) &= VP(t) \cup VP(v)
    \end{align*}
\end{theorem}

\begin{theorem}
    PremenovanÃ­m nazÃ½vame nahradenie voÄ¾nÃ½ch premennÃ½ch v termÃ­ne.
    \begin{equation}
        t \{ y / x \}
    \end{equation}
\end{theorem}
V termÃ­ne $t$ je premenovanÃ¡ premennÃ¡ $x$ za $y$.

% TODO pridaj priklady
\subsection{$\alpha$-ekvivalencia}
\begin{theorem}
    O vÃ½razov hovorÃ­me Å¾e sÃº alfa-ekvivalentnÃ© ak sa vÃ½razy rovnajÃº aÅ¾ na premenovanie.
\end{theorem}

\begin{theorem}
    O substutÃ­cii hovorÃ­me pri nahradenÃ­ jednej premenej druhou.
    \begin{equation}
        t [ y / x ]
    \end{equation}
\end{theorem}

Nahradenie je silnejÅ¡ie a vieme nahradiÅ¥ aj premmennÃ© viazannÃ© abstrakciou.

\subsection{$\beta$-ekvivalencia}

\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda x.t)u \to_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{\lambda}$)]{(\lambda x.t)u \rightarrow_{\beta} t [ u / x ]}
    \end{prooftree}
\end{minipage}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{t \to_{\beta} t'}
        \infer1[($\beta_{l}$)]{t u \rightarrow_{\beta} t' u}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{u \to_{\beta} u'}
        \infer1[($\beta_{r}$)]{t u \rightarrow_{\beta} t u'}
    \end{prooftree}
\end{minipage}
\vskip 0.2in

% TODO vymysliet iny strom, tento je prevzaty
\begin{equation}
    \begin{prooftree}
        \infer0[($\beta_{s}$)]{(\lambda y.y)x \to_{\beta} x}
        \infer1[($\beta_{l}$)]{(\lambda y.y)xz \to_{\beta} xz}
        \infer1[($\beta_{\alpha}$)]{\lambda x.(\lambda y.y)xz \to_{\beta} \lambda x . xz}
    \end{prooftree}
\end{equation}

\begin{theorem}
    Definujme rekurziu volania funkcie nasledovne
    \begin{align}
        f^{0}x &= x \\
        f^{n}x &= f(f^{n-1}x) \\
    \end{align}
    Potom Churchove ÄÃ­slo $c_{n}$ je $\lambda$-termÃ­n
    \begin{equation}
        c_{n} = \lambda s . \lambda z . s^{n} (z)
    \end{equation}
\end{theorem}

PrirodzenÃ© ÄÃ­sla je potom definovaÅ¥
\begin{align*}
    0 &= \lambda f x . x \\
    1 &= \lambda f x . f x \\
    1 &= \lambda f x . f (f x) \\
    2 &= \lambda f x . f ( f (f x))
\end{align*}

\begin{align*}
    succ(n) &=           (\lambda n f x .  f( n f x ))(\lambda f x . f^{n} x) \\
           &\to_{\beta} \lambda f x . f (( \lambda f x . f^{n} x ) f x)      \\
           &\to_{\beta} \lambda f x . f (( \lambda x . f^{n} x) x)           \\
           &\to_{\beta} \lambda f x . f (f^{n} x)                            \\
           &=           \lambda f x . f^{n+1} x                              \\
           &= n + 1
\end{align*}

OperÃ¡ciu sÄÃ­tania je potom moÅ¾nÃ© definovaÅ¥ vykonaÅ¥
\begin{theorem}
    $f_{+} = \lambda x. \lambda y. \lambda s. \lambda z. x s (y s z)$
\end{theorem}

PodobnÃ½m spÃ´sobom mÃ´Å¾eme vytvoriÅ¥ 
\begin{theorem}
    \begin{align*}
        True &= \lambda x y . x \\
        False &= \lambda x y . y
    \end{align*}
\end{theorem}

\begin{align*}
    if = \lambda b x y . b x y
\end{align*}

\begin{align*}
    if \textrm{ True } t u = (\lambda bxy.bxy)(\lambda xy.x) tu & \to_{\beta} (\lambda xy.(\lambda xy.x)xy)tu \\
                                                     & \to_{\beta} (\lambda y.( \lambda xy.x)ty)u \\
                                                     & \to_{\beta} (\lambda xy.x)tu \\
                                                     & \to_{\beta} (\lambda y.t)u \\
                                                     & \to_{\beta} t
\end{align*}

\begin{theorem}
    JednoduchÃ½ $\lambda$ kalkulus je ekvivalentnÃ½ vÃ½poÄtovej sile turingovho stroja.
    Bez dÃ´kazu
\end{theorem}

\section{Typovo jednoduchÃ½ $\lambda$-calculus}

TypovÃ½ lambda calculus je rozÅ¡Ã­renÃ­m jednoduchÃ©ho o typy

\begin{theorem}
    Majme mnoÅ¾inu $U$ spoÄÃ­tateÄ¾nÃº nekoneÄnÃº abecedu obsahujÃºcu typovÃ© premennÃ©.
    Potom mnoÅ¾ina $\Pi$ obsahuje reÅ¥azce jednoduchÃ½ch typov ktorÃ© su generovanÃ©
    gramatikov:
    \begin{equation}
        \Pi ::= U | (\Pi \to \Pi)
    \end{equation}
\end{theorem}

\begin{theorem}
    Kontextom rozumieme mnoÅ¾inu $C$ tvoriacu 
    \begin{equation}
        { x_{1} : \tau_{1}, \dots, x_{n} : \tau_{n} }
    \end{equation}
    kde $\tau_{1}, \dots, \tau_{n} \in \Pi$ a $x_{1}, \dots , x_{n} \in$
    Koobor kontextu je mnoÅ¾ina obsahujÃºca
    \begin{equation}
        domain(\Gamma) = { x_{1}, \dots, x_{n} }
    \end{equation}
    Oboor kontextu je mnoÅ¾ina obsahujÃºca
    \begin{equation}
        range( \Gamma ) = { \tau \in \Pi  | (x : \tau ) \in \Gamma }
    \end{equation}
\end{theorem}

\noindent PrÃ­klady generovanÃ© gramatikou
\begin{itemize}
    \item $\vdash \lambda x.x : \sigma \to \sigma$
    \item $\vdash \lambda x. \lambda y.x : \sigma \to \tau \to \sigma$
    \item $\vdash \lambda x. \lambda y. \lambda z.x z (y z): (\sigma \to \tau \to \rho) \to (\rho \to \tau) \to \sigma \to \rho$
\end{itemize}

\begin{theorem}
    PostupnosÅ¥ je trojica znaÄenÃ¡
    \begin{equation}
        \Gamma \vdash t : A
    \end{equation}
tvorenÃ¡ kontextom $\Gamma$, $\lambda$-termÃ­nom $t$ a typom $A$.
\end{theorem}

TermÃ­n $t$ je typu $A$ ak v kontexte $\Gamma$ ak je postupnosÅ¥ derivovateÄ¾nÃ¡ pomocou pravidiel:
\begin{itemize}
    \item ax: v kontexte $x$ je typu $A$
    \item $\overset{I}{\rightarrow}$: ak je $x$ typu $A$, $t$ je typu B, potom
        funkcia $\lambda x.t$ ktorÃ¡ asociuje $x$ $t$ je typu $A \to B$
    \item $\overset{E}{\rightarrow}$: danÃ¡ je funkcia $t$ je typu $A \to B$
        a argument $u$ je typu $A$, vysledok aplikÃ¡cia $t u$ je typu $B$
\end{itemize}

\begin{center}
    \begin{prooftree}
        \infer0[ax]{\Gamma \vdash x : \Gamma(x)}
    \end{prooftree}
\end{center}
\vskip 0.2in
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma , x : A \vdash t : B }
        \infer1[$\overset{I}{\rightarrow}$]{\Gamma \lambda x^{A}.t : A \to B}
    \end{prooftree}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{prooftree}
        \hypo{\Gamma \vdash t : A \to B }
        \hypo{\Gamma \vdash u : A }
        \infer2[$\overset{E}{\rightarrow}$]{\Gamma \vdash t u : B}
    \end{prooftree}
\end{minipage}

\section{Curry-Howardov izomorfizmus}

\begin{center}
    \begin{tabular}{ c c }
        IntuinistickÃ¡ logika & Typovo jednoduchÃ½ $\lambda$ kalkulus \\
        \hline
        termÃ­n                  & dÃ´kaz \\
        typovÃ¡ premennÃ¡         & propoziÄnÃ¡ premennÃ¡ \\
    \end{tabular}
\end{center}

\begin{theorem}{Curry-Howard isomorphism}
    \begin{itemize}
        \item If $\Gamma \vdash M : \varphi \textrm{ potom } |\Gamma|  \vdash \varphi.$
        \item If $\Gamma \vdash \varphi \textrm{ potom existuje } M \in \Lambda_{\Pi}
            \textrm{ takÃ© Å¾e } \Delta \vdash M : \varphi, \textrm{ kde }
            \Delta = { ( x_{\varphi} : \varphi ) | \varphi \in \Gamma }$
    \end{itemize}
\end{theorem}

\section{PoÄÃ­taÄom asistovanÃ© dokazovanie}
    To com som vravel v prezentacii, historia, na zaciatku sa pouzivalo
\section{Lean-theorem-prover}
    Lean je dokazovacÃ­ asistent ktorÃ½ bol vytvorenÃ½ otvorenÃ½ softvÃ©rovÃ½ projekt
Leonardom de Mourom v Microsoft Reasearch v roku 2013. Jazyk sa neustÃ¡le vyvÃ½ja
a momentÃ¡lne sa nachÃ¡dza vo Å¡tvrtej iterÃ¡cii zatiaÄ¾ Äo komunitnÃ½ projekt matematickej
kniÅ¾nice mathlib sa stÃ¡le vyvÃ½ja v tretej verzii.
\subsection{Constracting proof}

\subsection{Forward proofs}
    \subsubsection{assume}
    \subsubsection{calc}
    \subsubsection{fix}
    \subsubsection{have}
    \subsubsection{let}
    \subsubsection{show}
\subsection{Backward proofs}
    \subsubsection{cc}
    \subsubsection{clear}
    \subsubsection{exact}
    \subsubsection{induction}
    \subsubsection{intro}
    \subsubsection{refl}
    \subsubsection{refl}
\subsubsection{Inductive types}

\section{TeÃ³ria usporiadania}
    V tejto kapitole sa budeme snaÅ¾iÅ¥ ukÃ¡zaÅ¥ moÅ¾nosti Lean-u a vyuÅ¾itie uÅ¾ existujÃºcich
definÃ­cii v mathlibe pre dokÃ¡zanie viet tÃ½kajÃºce sa teÃ³rie usporiadania.
    Pre tento ÃºÄel je Lean ideÃ¡lny z pohÄ¾adu Å¾e naÅ¡e moÅ¾nosti definovania vlastnostÃ­
usporiadania potom moÅ¾no aplikovaÅ¥ na abstraktnÃº mnoÅ¾inu objektov.
    % Toto by bolo dobrÃ© rozpracovaÅ¥ Äalej, moÅ¾no konkrÃ©tny prÃ­klad
    VÃ½slednÃ½ typ je potom odvodenÃ½ na zÃ¡klade zÃ¡vislostnÃ½ch typov.
    Usporiadanie je jednoducho intuitÃ­vne uchopiteÄ¾nÃ¡ vlastnosÅ¥ bez matematickÃ½ch
preddispozÃ­ciÃ­.
    V beÅ¾nom Å¾ivote porovnÃ¡vame svoju vÃ½Å¡ku, Äas ktorÃ½ trval na vybehnutie do kopca
alebo aj ÄÃ­selne neohodnotenÃ©, subjektÃ­vne merateÄ¾nÃ© objekty ako ktorÃ½ album
od skupiny mÃ¡m radÅ¡ej.
    Na otÃ¡zky si potom vieme odpovedaÅ¥ "ja som vyÅ¡Å¡Ã­", "zabehol si pomalÅ¡ie" alebo
tieto albumy sa nedajÃº porovnaÅ¥.

TeÃ³ria usporiadania sa snaÅ¾Ã­ tieto vlastnoti formÃ¡lne definovaÅ¥ a rozvÃ­jaÅ¥ Äalej
otÃ¡zkami ako, akÃ© je hornÃ© celej mnoÅ¾iny objektov. Existuje ohraniÄenie hornÃ© alebo
dolnÃ© pre Ä¾ubovoÄ¾nÃº podmnoÅ¾inu objektov?
    Pre struÄnosÅ¥ sa v rÃ¡mcii definÃ­cii obmedzÃ­me len na definÃ­ciu usporiadania
ako relÃ¡cie ÄiÅ¾e podmnoÅ¾inu karteziÃ¡nskeho sÃºÄinu dvoch mnoÅ¾Ã­n.

\begin{theorem}
    MajmÃ¤ mnoÅ¾inu $P$, potom usporiadanie alebo ÄiastoÄnÃ© usporiadanie na mnoÅ¾ine
    $P$ je binÃ¡rna relÃ¡cia $\leq$ takÃ¡ Å¾e, pre vÅ¡etky $x,y,z \in P$
    \begin{itemize}
        \item $x \leq x$ vlastnoÅ¥ reflexivity
        \item $x \leq y$ a $y \leq x$ implikuje $x = y$ antisymetria
        \item $x \leq y$ a $y \leq z$ impikuje $x \leq z$ tranzitivita
    \end{itemize}
\end{theorem}

    IdeÃ¡lny nÃ¡strojom pre uvaÅ¾ovanie nad usporiadanÃ­m sÃº \emph{Hasseho} diagramy.
    Ako prÃ­klad uvÃ¡dzame diagram "kocky".

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.15]{cube.png}
    \caption{Usporiadania $\mathcal{P}(\{a,b,c\})$}
\end{figure}

    Na obrÃ¡zku je usporiadanie mnoÅ¾iny vÅ¡etkÃ½ch mnoÅ¾Ã­n trojprvkovej mnoÅ¾iny $\{ a,b,c \}$.
    Usporiadanie tvorÃ­ binÃ¡rna relÃ¡cia kardinality podmnoÅ¾Ã­nm priÄom porovnÃ¡vame
len podmnoÅ¾iny obsahujÃºce spoloÄnÃ½ prvok.
    VyÅ¡Å¡ie sÃº poloÅ¾enÃ© vaÄÅ¡ie prvky a porovnateÄ¾nÃ½mi prvkami povaÅ¾ujeme len tie
ktorÃ© sÃº "pokrytÃ©" jednosmernou cestou cez orientovanÃ© hrany grafu.

    V Leane je usporiadanie definovÃ© ako rozÅ¡Ã­renie triedy predusporiadania ktorÃ¡
je relÃ¡ciou ktorÃ¡ nemÃ¡ oproti ÄiastoÄnÃ©mu usporiadaniu vlastnosÅ¥ antisymetrie.

\begin{lstlisting}
class has_le       (Î± : Type u) := (le : Î± â†’ Î± â†’ Prop)
class has_lt       (Î± : Type u) := (lt : Î± â†’ Î± â†’ Prop)

class preorder (Î± : Type u) extends has_le Î±, has_lt Î± :=
(le_refl : âˆ€ a : Î±, a â‰¤ a)
(le_trans : âˆ€ a b c : Î±, a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c)
(lt := Î» a b, a â‰¤ b âˆ§ Â¬ b â‰¤ a)
(lt_iff_le_not_le : âˆ€ a b : Î±, a < b â†” (a â‰¤ b âˆ§ Â¬ b â‰¤ a) . order_laws_tac)
\end{lstlisting}
ÄŒiastoÄnÃ© usporiadanie je potom rozÅ¡Ã­renÃ­m predusporiadania o vlastnosÅ¥ antysymetrie.
\begin{lstlisting}
class partial_order (Î± : Type u) extends preorder Î± :=
(le_antisymm : âˆ€ a b : Î±, a â‰¤ b â†’ b â‰¤ a â†’ a = b)
\end{lstlisting}

DOPLN PRIKLAD NAJLEPSIE AK NAS USPORIADANY POSET Z PRIKLADU

\subsubsection{ZvÃ¤z}
    ZvÃ¤z je usporiadanÃ¡ mnoÅ¾ina pre ktorÃº navyÅ¡e platÃ­ Å¾e pre kaÅ¾dÃ© 2 prvky $a, b$
vieme nÃ¡jsÅ¥ prvok $c$ ktorÃ© je ich najmenÅ¡Ã­m hornÃ½m respektÃ­ve(\emph{supremum})
najvÃ¤ÄÅ¡Ã­m dolnÃ½m ohraniÄenÃ­m(\emph{infinum}).
    V prÃ­pade intervalu reÃ¡lnych ÄÃ­sel je toto ohraniÄenie jednoducho predstaviteÄ¾nÃ©
ako bod ohraniÄujÃºce mnoÅ¾inu na ÄÃ­selnej osi.
    Ak ide o ÄiastoÄnÃ© usporiadanie je nÃ¡zov pre tieto ohraniÄenia prvkov
motivovanÃ½ zobreznÃ­m na grafe.
    \emph{Spojenie} $\sqcup, \vee$ pre supremum respektÃ­ve \emph{stretnutie} $\sqcap, \wedge$ pre infinum.
    PopisnejÅ¡Ã­m nÃ¡zvom pre zvÃ¤z je preklad anglicky pouÅ¾Ã­vanÃ©ho nÃ¡zvu \emph{lattice}
"mrieÅ¾ka" tak isto motivoavnÃ¡ zobrazenÃ­m takÃ©ho usporiadania na grafe.
    Pri dokazovanÃ­ viet o zvÃ¤zoch je Äasto vyuÅ¾Ã­vanÃ¡ vlastnosÅ¥ duality najmenÅ¡ieho
hornÃ©ho a duÃ¡lne najvÃ¤ÄÅ¡ieho dolnÃ©ho ohraniÄenie pre druhÃº polovicu dÃ´kazu.
    V prÃ­pade zvÃ¤zu je tÃ¡to vlastnosÅ¥ vyuÅ¾itÃ¡ rovno v definÃ­cii zvÃ¤zu ako spojenie
duÃ¡lnej definÃ­cie suprÃ©moveho a infinumovÃ©ho semizvÃ¤zvu.

\begin{lstlisting}
class has_sup (Î± : Type u) := (sup : Î± â†’ Î± â†’ Î±)
class has_inf (Î± : Type u) := (inf : Î± â†’ Î± â†’ Î±)

infix âŠ” := has_sup.sup
infix âŠ“ := has_inf.inf

class semilattice_sup (Î± : Type u) extends has_sup Î±, partial_order Î± :=
(le_sup_left : âˆ€ a b : Î±, a â‰¤ a âŠ” b)
(le_sup_right : âˆ€ a b : Î±, b â‰¤ a âŠ” b)
(sup_le : âˆ€ a b c : Î±, a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c)

class semilattice_inf (Î± : Type u) extends has_inf Î±, partial_order Î± :=
(inf_le_left : âˆ€ a b : Î±, a âŠ“ b â‰¤ a)
(inf_le_right : âˆ€ a b : Î±, a âŠ“ b â‰¤ b)
(le_inf : âˆ€ a b c : Î±, a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c)

class lattice (Î± : Type u) extends semilattice_sup Î±, semilattice_inf Î±
\end{lstlisting}

Na nasledujÃºcich grafoch si ukÃ¡Å¾eme ako vyzerajÃº zvÃ¤zy.

PRIDAT VLASTNY PRIKLAD, OPYTAT SA
\begin{lstlisting}
def poset_nat : sublattice â„• :=
    { carrier := {n : â„• | 1 â‰¤ n},
    inf_mem :=
      beginÂ·
        intro a,
        intro b,
        intro a_set,
        intro b_set,
        simp at a_set,
        simp at b_set,
        simp,
        split,
        exact a_set,
        exact b_set,
      end,
    sup_mem := by finish,
}
\end{lstlisting}

\subsubsection{ModulÃ¡rne zvÃ¤zy}

V nasledujÃºcom Ãºseku si ukÃ¡Å¾eme vetu tÃ½kajÃºcu sa Å¡peciÃ¡lneho typu zvÃ¤zu s vlastnosÅ¥ou
    modularity a ukÃ¡Å¾eme si formÃ¡lny dÃ´kaz a jej implementÃ¡ciu v Leane  ktorÃº si
    podrobne rozoberieme.

O zvÃ¤ze $L$ hovorÃ­me Å¾e je modulÃ¡rny v prÃ­pade Å¾e spÄºÅˆa nasledujÃºcu vlastnosÅ¥.

\begin{equation*}
    (\forall x,y,z \in L) x \geq y \implies x \wedge ( y \vee z) = (x \wedge y) \vee z
\end{equation*}

V Leane definovanÃ½ ako rozÅ¡Ã­renie zvÃ¤zu:

\begin{lstlisting}
class modular_lattice(Î± : Type u) extends lattice Î± :=
  (modular_law: âˆ€ (x u v : Î± ), (x â‰¤ u) â†’ u âŠ“ (v âŠ” x) = (u âŠ“ v) âŠ” x )
\end{lstlisting}

V nasledujÃºcom Ãºseku si ukÃ¡Å¾eme vetu o modulÃ¡rnom izomorfizme a podrobne
    si rozoberieme implementÃ¡ciu jej dÃ´kazu s obsahom prostredia v Leane.

\subsection{ModulÃ¡rne zvÃ¤zy}
    \begin{theorem} \emph{Veta o izomorfizme modulÃ¡rnych zvÃ¤zov}
    Nech L je modulÃ¡rnym zvÃ¤zom a $a, b \in L$. Potom
        \begin{equation}
            \varphi_{b}: x \mapsto x \wedge b, x \in [a, a \vee b],
        \end{equation}
    Je izomorfizmom medzi intervalmi $[a, a \vee b]$ a $[ a \wedge b, b]$.
    InverznÃ½m izomorfizmom je
        \begin{equation}
            \psi_{a}: y \mapsto x \vee a, y \in [a \wedge b, b].
        \end{equation}
    \end{theorem}
    \emph{DÃ´kaz}.  StaÄÃ­ ukÃ¡zaÅ¥ Å¾e $\varphi_{b}\psi_{a}(y) = y$ pre vÅ¡etky $x \in [a, a \vee b]$.
    Z duality vyplÃ½va Å¾e $\varphi_{b}\psi_{a}(y) = y$ pre vÅ¡etky
        $y \in [a \wedge b, b]$,
    Majme $x \in [a, a \vee b]$. Potom
        $\psi_{a}\varphi_{b} = ( x \wedge b ) \vee a$ nerovnosÅ¥ $a \leq x$ platÃ­
        potom aj modularita
        \begin{equation}
            \varphi_{a}\psi_{b}(x) =
            ( x \wedge b ) \vee a =
            x \wedge ( b \vee a) =
            x
        \end{equation}
        pretoÅ¾e
        \[
            \pushQED{\qed}
            x \leq a \vee b. \qedhere
            \popQED
        \]

    PredstavenÃ½ dÃ´kaz je znÃ¡zornenÃ½ na nasledujÃºcom grafe.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.35]{modular_lattice_isomorphism.png}
    \caption{Izomorfizmus modulÃ¡rneho zvÃ¤zu}
\end{figure}

    V prÃ­pade formÃ¡lneho dÃ´kazu sme sa mohli v Äasti dÃ´kazu odkÃ¡zaÅ¥ na dualitu. 
    V prÃ­ nÃ¡vrhu dÃ´kazu v Leane musÃ­m ukÃ¡zaÅ¥ dÃ´kaz z "oboch" strÃ¡n.

\begin{lstlisting}
theorem modular_lattice_isomorphism { Î±: Type u } [ modular_lattice Î± ]
{ u v w x y : Î± } :
  x â‰¤ u â†’
  x â‰¥ v â†’
  x â‰¥ u âŠ“ v â†’
  x â‰¤ u âŠ” v â†’
  u âŠ“ ( v âŠ” x ) = x âˆ§ (u âŠ“ x) âŠ” v = x
  :=
  begin
 1        intros h1 h2 h3 h4,
 2        split,
 3        {
 4          rw modular_lattice.modular_law,
 5          exact sup_eq_right.mpr h3,
 6          exact h1
 7        },
 8        {
 9          rw inf_comm,
10          rw â† modular_lattice.modular_law,
11          exact inf_eq_left.mpr h4,
11          exact h2
12        }
  end
\end{lstlisting}
    ZaÄÃ­name v taktickom mÃ³de prÃ¡zdnou konÅ¡trukciou \emph{begin} a \emph{end}
    InteraktÃ­vne prostredie vyzerÃ¡ nasledovne.
\begin{lstlisting}
Î±: Type u
_inst_1: modular_lattice Î±
u v w x y : Î±
âŠ¢ x â‰¤ u â†’ x â‰¥ v â†’ x â‰¥ u âŠ“ v â†’ x â‰¤ u âŠ” v â†’ u âŠ“ (v âŠ” x) = x âˆ§ u âŠ“ x âŠ” v = x
\end{lstlisting}
    PrvÃ½m krokom dÃ´kazu je presunutie predpokladov zo sledu implikÃ¡cii do
prostredia pre ÄalÅ¡iu prÃ¡cu s nimi s oznaÄenÃ­m $h1,h2,h3,h4$.
\begin{lstlisting}
Î±: Type u
_inst_1: modular_lattice Î±
uvwxy: Î±
h1: x â‰¤ u
h2: x â‰¥ v
h3: x â‰¥ u âŠ“ v
h4: x â‰¤ u âŠ” v
âŠ¢ u âŠ“ (v âŠ” x) = x âˆ§ u âŠ“ x âŠ” v = x
\end{lstlisting}
    CieÄ¾ potom pozostÃ¡va z konjukcie kde v druhej Äasti mÃ¡me vÃ½raz implicitne
ozÃ¡tvorkovanÃ½ zÄ¾ava.
    VÃ½raz rozdelÃ­me do dvoch podcieÄ¾ov prÃ­kazom \emph{split}, a pre lepÅ¡iu
ÄitateÄ¾nosÅ¥ ozÃ¡tvorkujeme mnoÅ¾inovÃ½mi zÃ¡tvorkami. NachÃ¡dzame sa v stave
\begin{lstlisting}
  begin
    intros h1 h2 h3 h4,
    split,
    {
    },
    {
    }
  end
\end{lstlisting}
v ktorom nÃ¡m lean ukazuje prostredie kde musÃ­me dokÃ¡zaÅ¥ Ä¾avÃº ÄasÅ¥ konjukcie.
\begin{lstlisting}
âŠ¢ u âŠ“ (v âŠ” x) = x
\end{lstlisting}
Na cieÄ¾ pouÅ¾ijeme z definÃ­cie modulÃ¡rneho zvÃ¤zu vlastnosÅ¥ modularity
\begin{lstlisting}
    (modular_law: âˆ€ (x u v : Î± ), (x â‰¤ u) â†’ u âŠ“ (v âŠ” x) = (u âŠ“ v) âŠ” x )
\end{lstlisting}
a transformujeme prepÃ­Å¡eme cieÄ¾ cez prÃ­kaz
\begin{lstlisting}
rw modular_lattice.modular_law,
\end{lstlisting}
na nasledujÃºci kde mÃ¡ $u \sqcap v$ vyÅ¡Å¡iu precedenciu
\begin{lstlisting}
âŠ¢ u âŠ“ v âŠ” x = x
\end{lstlisting}
    NasledujÃºca transformÃ¡cia vyÅ¾aduje znalosÅ¥ uÅ¾ dokÃ¡zanÃ½ch definÃ­ciÃ­ ktorÃ©
boli dokÃ¡zanÃ© pre podkladovÃ© Å¡truktÃºry. PouÅ¾ijeme nasledujÃºcu definÃ­ciu ktorÃ¡ vychÃ¡dza
z kontextu \emph{semilattice\_sup}.
\begin{lstlisting}
% @[simp] theorem sup_eq_right : a âŠ” b = b â†” a â‰¤ b :=    / TODO NEZABUDNUT
%  le_antisymm_iff.trans $ by simp [le_refl]             / ODKOMENTOVAT
    \end{lstlisting}
    ZaujÃ­mavosÅ¥ou je Å¾e si Lean dokÃ¡Å¾e substiuovaÅ¥ vÃ½raz $u \sqcap v$ za $a$ z uvedenÃ©ho
vÃ½razu. Pri pouÅ¾itÃ­ vety dostÃ¡vame ekvivalenciu ktorÃ¡ je definovanÃ¡ ako Å¡truktÃºra.
\begin{lstlisting}
structure iff (a b : Prop) : Prop :=
    intro :: (mp : a â†’ b)
             (mpr : b â†’ a)
\end{lstlisting}
Z tejto Å¡truktÃºry pouÅ¾ijeme implikÃ¡ciu smerujÃºca doÄ¾ava nasledovne
\begin{lstlisting}
    exact sup_eq_right.mpr h3,
\end{lstlisting}
    CieÄ¾ je teda transformovanÃ½ na
\begin{lstlisting}
âŠ¢ x â‰¤ u
\end{lstlisting}
Äo je uÅ¾ uvedenÃ½ predpoklad $h1$. TÃ½mto sme dokÃ¡zali jeden z podcieÄ¾ov.
    V tejto chvÃ­li by sme sa v literatÃºre mohli odvolaÅ¥ na dualitu vÃ½razov.
    V Leane musÃ­me poskytnÃºÅ¥ dÃ´kaz aj o druhom cieli. Ideme dokÃ¡zaÅ¥
\begin{lstlisting}
âŠ¢ u âŠ“ x âŠ” v = x
\end{lstlisting}
V tejto chÃ­li chceme znova pouÅ¾iÅ¥ modularitu, leanu je ale potrebnÃ© explicitne povedaÅ¥
    Å¾e chceme prepÃ­saÅ¥ vÃ½raz nachÃ¡dzajÃºci na pravej strane rovnosti pomocou symbolu
Ä¾avej Å¡Ã­pky.
\begin{lstlisting}
rw â† modular_lattice.modular_law,
\end{lstlisting}
    PouÅ¾ijeme duÃ¡lnu vetu
    duÃ¡lnu k \emph{sup\_eq\_right}.
\begin{lstlisting}
@[simp] theorem inf_eq_left : a âŠ“ b = a â†” a â‰¤ b
\end{lstlisting}
    a vyuÅ¾ijeme opaÄnÃ© predpoklady k predchÃ¡dzajÃºcim $h2, h4$.
\begin{lstlisting}
{
    rw â† modular_lattice.modular_law,
    exact inf_eq_left.mpr h4,
    exact h2
}
\end{lstlisting}

Po dokÃ¡zanÃ­ druhÃ©ho cieÄ¾a sme dokÃ¡zali celÃº vetu. $\square$

\begin{thebibliography}{xx}
    \bibitem{Mimram} Samuel Mimram, Program = Proof, Indenpendently published(July 3, 2020), ISBN-13: 979-8615591839
    \bibitem{SorensenUrzyczyn} Morten Heine B. SÃ¸rensen, Pawel Urzyczyn, Lectures on the Curry-Howard Isomorphism,
        Elsevier Science (April 4, 2013),  ISBN-13 : 978-0444545961
    \bibitem{}
\end{thebibliography}

Slovicka na ktore nepoznam preklad a ne
\begin{itemize}
    \item join - spojenie
    \item meet - stretnutie
\end{itemize}

\end{document}

\begin{verbatim}
    structure point :=
      ( x : nat )
      ( y : nat )

    /-- alternative notation -/
    structure point_alternative :=
      mk :: (x : nat) (Y : nat)

    def p1 : point :=
    {
      x   := 10,
      y   := 20,
    }

    /- same point, different notation, same notation for ordered seti -/
    def p2 : point := $\langle 10, 20 \rangle$

    /- instance only one part of structure, rest implicitly from other instance
    def p3 : point := {
        x := 20,
        ..p
    }
\end{verbatim}

% sposob ukladania kodu

\subsubsection{Type classes}

